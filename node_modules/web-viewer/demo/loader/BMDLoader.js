/**
 * @author muwj 2016/12/15
 */

var CLOUD = CLOUD || {};
CLOUD.Loader = CLOUD.Loader || {};

CLOUD.Loader.BMDLoader = function ( scene_n, mpk_n ) {

	this.scene_count = scene_n;
	this.mpk_count = mpk_n;
	this.sceneArray = new Array( scene_n );
	this.mpkArray = new Array( mpk_n );
	this.symbol = null;
	this.material = null;

	this.sceneID = null;
	this.meshID = null;
	this.materialID = null;

	this.geometry_box  = new THREE.BoxBufferGeometry( 1, 1, 1 );
	this.geometry_pipe = new THREE.CylinderBufferGeometry( 1, 1, 1, 8, 1, false );

    this.addMaterialBind   = this.addMaterial.bind(this);
    this.addMeshBind       = this.addMesh.bind(this);
	this.addSymbolBind     = this.addSymbol.bind(this);
    this.addSceneBind      = this.addScene.bind(this);
    this.addMaterialIDBind = this.addMaterialID.bind(this);
    this.addMeshIDBind     = this.addMeshID.bind(this);
    this.addSceneIDBind    = this.addSceneID.bind(this);
};

CLOUD.Loader.BMDLoader.prototype = {

	constructor: CLOUD.Loader.BMDLoader,

    addMaterial: function ( e ) {

        if (e.target.readyState == 4) {
            if (e.target.status == 200) {
                this.material = new CLOUD.Loader.MaterialReader( e.target.response );
            }
        }
    },

    addMesh: function ( e ) {

        if (e.target.readyState == 4) {
            if (e.target.status == 200) {
            	var mpk_reader = new CLOUD.Loader.MPKReader( e.target.response );
				if ( mpk_reader.header.blockId < this.mpk_count ) {
					this.mpkArray[mpk_reader.header.blockId] = mpk_reader;
				}
            }
        }
    },

	addSymbol: function ( e ) {

		if (e.target.readyState == 4) {
			if (e.target.status == 200) {
				this.symbol = new CLOUD.Loader.SymbolReader( e.target.response );
			}
		}
	},

    addScene: function ( e ) {

        if (e.target.readyState == 4) {
            if (e.target.status == 200) {
            	var scene_reader = new CLOUD.Loader.SceneReader( e.target.response );
				if ( scene_reader.header.blockId < this.scene_count ) {
					this.sceneArray[scene_reader.header.blockId] = scene_reader;
				}
            }
        }
    },

    addMaterialID: function ( e ) {

        if (e.target.readyState == 4) {
            if (e.target.status == 200) {
                this.materialID = new CLOUD.Loader.IdReader( e.target.response );
            }
        }
    },

    addMeshID: function ( e ) {

        if (e.target.readyState == 4) {
            if (e.target.status == 200) {
                this.meshID = new CLOUD.Loader.IdReader( e.target.response );
            }
        }
    },

    addSceneID: function ( e ) {

        if (e.target.readyState == 4) {
            if (e.target.status == 200) {
                this.sceneID = new CLOUD.Loader.IdReader( e.target.response );
            }
        }
    },

	loadMaterial: function ( url ) {

        var xmlRequest = new XMLHttpRequest();
        xmlRequest.onreadystatechange = this.addMaterialBind;
        xmlRequest.open( "GET", url, true );
        xmlRequest.responseType = 'arraybuffer';
        xmlRequest.send(null);
	},

	loadMesh: function ( url ) {

        var xmlRequest = new XMLHttpRequest();
        xmlRequest.onreadystatechange = this.addMeshBind;
        xmlRequest.open( "GET", url, true );
        xmlRequest.responseType = 'arraybuffer';
        xmlRequest.send(null);
	},

	loadSymbol: function ( url ) {

		var xmlRequest = new XMLHttpRequest();
		xmlRequest.onreadystatechange = this.addSymbolBind;
		xmlRequest.open( "GET", url, true );
		xmlRequest.responseType = 'arraybuffer';
		xmlRequest.send(null);
	},

	loadScene: function ( url ) {

        var xmlRequest = new XMLHttpRequest();
        xmlRequest.onreadystatechange = this.addSceneBind;
        xmlRequest.open( "GET", url, true );
        xmlRequest.responseType = 'arraybuffer';
        xmlRequest.send(null);
	},

	loadMaterialID: function ( url ) {

        var xmlRequest = new XMLHttpRequest();
        xmlRequest.onreadystatechange = this.addMaterialIDBind;
        xmlRequest.open( "GET", url, true );
        xmlRequest.responseType = 'arraybuffer';
        xmlRequest.send(null);
	},

	loadMeshID: function ( url ) {

        var xmlRequest = new XMLHttpRequest();
        xmlRequest.onreadystatechange = this.addMeshIDBind;
        xmlRequest.open( "GET", url, true );
        xmlRequest.responseType = 'arraybuffer';
        xmlRequest.send(null);
	},

	loadSceneID: function ( url ) {

        var xmlRequest = new XMLHttpRequest();
        xmlRequest.onreadystatechange = this.addSceneIDBind;
        xmlRequest.open( "GET", url, true );
        xmlRequest.responseType = 'arraybuffer';
        xmlRequest.send(null);
	},

	getScene: function ( id ) {

		if( id >= 0 && id < this.sceneArray.length ){
			return this.sceneArray[id];
		}
	},

	getMpk: function( id ) {

		if( id >= 0 && id < this.mpkArray.length ){
			return this.mpkArray[id];
		}
	},

	getSymbol: function() {

		return this.symbol;
	},

	getMaterial: function( id ) {

		return this.material.getData( id );
	},

	getMaterialID: function ( id ) {

		return this.materialID.getId( id );
	},

	getMeshID: function ( id ) {

		return this.meshID.getId( id );
	},

	getSceneID: function ( id ) {

		return this.sceneID.getId( id );
	},

	readSymbol: function ( id, matrix_up, onRead ) {

		if( this.symbol == null ){
			return;
		}
		var symbolCount = this.symbol.header.symbolCount;
		if(id >= 0 && id < symbolCount){

			var symbol_cur = this.symbol.getSymbolInfo(id);
			for(var i = symbol_cur.itemIndex; i < symbol_cur.itemCount; ++i){

				var item = this.symbol.getItemInfo(i);
				var matrix_cur = this.symbol.getMatrixInfo(item.matrixId).matrix;
				var material_cur = this.material.getDataInfo(item.materialId);

				var material_3js = new THREE.MeshBasicMaterial({
					color : material_cur.color
				});

				if(item.type == 1){

					var meshAttr = this.symbol.getMeshAttrInfo(item.attrIndex);
					var mpk = this.mpkArray[meshAttr.blockId];

					if (!mpk) continue;

					var meshData = mpk.getMeshInfo(meshAttr.meshId);
					var positions = mpk.getPtBuffer(meshAttr.meshId);
					var pos_index = mpk.getIdxBuffer(meshAttr.meshId);

					if(meshData == undefined || positions == undefined || pos_index == undefined){
						console.log(i);
						console.log(item);
						continue;
					}

					var geometry_mesh = new THREE.BufferGeometry();
					geometry_mesh.setIndex(new THREE.BufferAttribute(pos_index, 1));
					geometry_mesh.addAttribute('position', new THREE.BufferAttribute(positions, 3));

					var matrix_tmp = new THREE.Matrix4();
					matrix_tmp.setPosition(meshData.baseVector);
					matrix_tmp.scale(new THREE.Vector3(meshData.baseScale, meshData.baseScale, meshData.baseScale));

					var matrix_world = new THREE.Matrix4();
					if(meshData.baseScale != 0.0){

						matrix_world.multiplyMatrices(matrix_up, matrix_cur.clone().multiply(matrix_tmp));
					}
					else {
						matrix_world.multiplyMatrices(matrix_up, matrix_cur);
					}

					var mesh_3js = new THREE.Mesh(geometry_mesh, material_3js);
					matrix_world.decompose(mesh_3js.position, mesh_3js.quaternion, mesh_3js.scale);
					geometry_mesh.computeBoundingSphere();

					onRead(mesh_3js);
				}
				else if(item.type == 2){

					var geomAttr = this.symbol.getGeomInfo(item.attrIndex);

					var startPt = geomAttr.startPt;
					var endPt = geomAttr.endPt;

					var dir = new THREE.Vector3();
					dir.subVectors(endPt, startPt);

					var len = dir.length();
					dir.normalize();

					var radius = geomAttr.radius;
					if(radius <= 1){
						radius = 100;
					}

					var unitY = new THREE.Vector3(0, 1, 0);
					var scale = new THREE.Vector3(radius, len, radius);
					var quat = new THREE.Quaternion().setFromUnitVectors(unitY, dir);
					var position = startPt.clone().addScaledVector(dir, len * 0.5);

					var matrix_tmp = new THREE.Matrix4().compose(position, quat, scale);
					var matrix_world = new THREE.Matrix4();
					matrix_world.multiplyMatrices(matrix_up, matrix_cur.clone().multiply(matrix_tmp));
					var mesh_3js = new THREE.Mesh(this.geometry_box, material_3js);
					matrix_world.decompose(mesh_3js.position, mesh_3js.quaternion, mesh_3js.scale);

					onRead(mesh_3js);
				}
				else if(item.type == 3){

					var geomAttr = this.symbol.getGeomInfo(item.attrIndex);

					var startPt = geomAttr.startPt;
					var endPt = geomAttr.endPt;

					var dir = new THREE.Vector3();
					dir.subVectors(endPt, startPt);

					var len = dir.length();
					dir.normalize();

					var radius = geomAttr.radius;
					if(radius <= 1){
						radius = 100;
					}

					var unitY = new THREE.Vector3(0, 1, 0);
					var scale = new THREE.Vector3(radius, len, radius);
					var quat = new THREE.Quaternion().setFromUnitVectors(unitY, dir);
					var position = startPt.clone().addScaledVector(dir, len * 0.5);

					var matrix_tmp = new THREE.Matrix4().compose(position, quat, scale);
					var matrix_world = new THREE.Matrix4();
					matrix_world.multiplyMatrices(matrix_up, matrix_cur.clone().multiply(matrix_tmp));
					var mesh_3js = new THREE.Mesh(this.geometry_pipe, material_3js);
					matrix_world.decompose(mesh_3js.position, mesh_3js.quaternion, mesh_3js.scale);

					onRead(mesh_3js);
				}
				else if(item.type == 4){

					var bbox = item.boundingBox;
					var boxSize = bbox.size();
					var boxCenter = bbox.center();

					var matrix_tmp = new THREE.Matrix4().scale(new THREE.Vector3(boxSize.x, boxSize.y, boxSize.z));
					matrix_tmp.setPosition(boxCenter);

					var matrix_world = new THREE.Matrix4();
					matrix_world.multiplyMatrices(matrix_up, matrix_cur.clone().multiply(matrix_tmp));

					var mesh_3js = new THREE.Mesh(this.geometry_box, material_3js);
					matrix_world.decompose(mesh_3js.position, mesh_3js.quaternion, mesh_3js.scale);

					onRead(mesh_3js);
				}
			}
		}
	},

	readScene: function ( id, onRead ) {

		var sceneCount = this.sceneArray.length;
		if(id >= 0 && id < sceneCount){

			var scene = this.sceneArray[id];

			if (!scene) return;

			var cellCount = scene.header.cellCount;

			for (var cell_i = 0; cell_i < cellCount; ++cell_i){

				var cell = scene.getCellInfo(cell_i);
				var mpks = scene.getCellMpks(cell_i);

				for(var i = cell.itemIndex; i < cell.itemCount; ++i){

					var item = scene.getItemInfo(i);
					if(item == undefined){
						continue;
					}

					var matrix_cur = scene.getMatrixInfo(item.matrixId).matrix;

					if(item.type == 0){

						this.readSymbol(item.attrIndex, matrix_cur, onRead);
					}
					else {

						var material_cur = this.material.getDataInfo(item.materialId);
						var material_3js = new THREE.MeshBasicMaterial({
							color : material_cur.color
						});

						if(item.type == 1){

							var meshAttr = scene.getMeshAttrInfo(item.attrIndex);
							var mpk = this.mpkArray[meshAttr.blockId];

							if (!mpk) continue;

							var meshData = mpk.getMeshInfo(meshAttr.meshId);
							var positions = mpk.getPtBuffer(meshAttr.meshId);
							var pos_index = mpk.getIdxBuffer(meshAttr.meshId);

							if(meshData == undefined || positions == undefined || pos_index == undefined){
								console.log(i);
								console.log(item);
								continue;
							}

							var geometry_mesh = new THREE.BufferGeometry();
							geometry_mesh.setIndex(new THREE.BufferAttribute(pos_index, 1));
							geometry_mesh.addAttribute('position', new THREE.BufferAttribute(positions, 3));

							var matrix_tmp = new THREE.Matrix4();
							matrix_tmp.setPosition(meshData.baseVector);
							matrix_tmp.scale(new THREE.Vector3(meshData.baseScale, meshData.baseScale, meshData.baseScale));

							var matrix_world = matrix_cur.clone();
							if(meshData.baseScale != 0.0){
								matrix_world.multiply(matrix_tmp);
							}

							var mesh_3js = new THREE.Mesh(geometry_mesh, material_3js);
							matrix_world.decompose(mesh_3js.position, mesh_3js.quaternion, mesh_3js.scale);
							geometry_mesh.computeBoundingSphere();

							onRead(mesh_3js);
						}
						else if(item.type == 2){

							var geomAttr = scene.getGeomInfo(item.attrIndex);

							var startPt = geomAttr.startPt;
							var endPt = geomAttr.endPt;

							var dir = new THREE.Vector3();
							dir.subVectors(endPt, startPt);

							var len = dir.length();
							dir.normalize();

							var radius = geomAttr.radius;
							if(radius <= 1){
								radius = 100;
							}

							var unitY = new THREE.Vector3(0, 1, 0);
							var scale = new THREE.Vector3(radius, len, radius);
							var quat = new THREE.Quaternion().setFromUnitVectors(unitY, dir);
							var position = startPt.clone().addScaledVector(dir, len * 0.5);

							var matrix_tmp = new THREE.Matrix4().compose(position, quat, scale);
							var matrix_world = matrix_cur.clone().multiply(matrix_tmp);
							var mesh_3js = new THREE.Mesh(this.geometry_box, material_3js);
							matrix_world.decompose(mesh_3js.position, mesh_3js.quaternion, mesh_3js.scale);

							onRead(mesh_3js);
						}
						else if(item.type == 3){

							var geomAttr = scene.getGeomInfo(item.attrIndex);

							var startPt = geomAttr.startPt;
							var endPt = geomAttr.endPt;

							var dir = new THREE.Vector3();
							dir.subVectors(endPt, startPt);

							var len = dir.length();
							dir.normalize();

							var radius = geomAttr.radius;
							if(radius <= 1){
								radius = 100;
							}

							var unitY = new THREE.Vector3(0, 1, 0);
							var scale = new THREE.Vector3(radius, len, radius);
							var quat = new THREE.Quaternion().setFromUnitVectors(unitY, dir);
							var position = startPt.clone().addScaledVector(dir, len * 0.5);

							var matrix_tmp = new THREE.Matrix4().compose(position, quat, scale);
							var matrix_world = matrix_cur.clone().multiply(matrix_tmp);
							var mesh_3js = new THREE.Mesh(this.geometry_pipe, material_3js);
							matrix_world.decompose(mesh_3js.position, mesh_3js.quaternion, mesh_3js.scale);

							onRead(mesh_3js);
						}
						else if(item.type == 4){

							var bbox = item.boundingBox;
							var boxSize = bbox.size();
							var boxCenter = bbox.center();

							var matrix_tmp = new THREE.Matrix4().scale(new THREE.Vector3(boxSize.x, boxSize.y, boxSize.z));
							matrix_tmp.setPosition(boxCenter);
							var matrix_world = matrix_cur.clone().multiply(matrix_tmp);

							var mesh_3js = new THREE.Mesh(this.geometry_box, material_3js);
							matrix_world.decompose(mesh_3js.position, mesh_3js.quaternion, mesh_3js.scale);

							onRead(mesh_3js);
						}
					}
				}
			}
		}
	}

};
