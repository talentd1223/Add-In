var DebugUI = function (viewer, stats, serverUrl) {
    "use strict";

    var scope = this;

    this.id = "";
    this.projectId = "";
    this.intersect = null;
    this.selectionList = [];

    this.setSelections = function (selections) {
        this.selectionList.length = 0;
        for (var i = 0, len = selections.length; i < len; i++) {
            this.selectionList.push(selections[i]);
        }
    };

    viewer.addCallbacks("render", function () {

        var intersectDiv = document.getElementById('my_location_panel');

        if (intersectDiv && scope.intersect) {

            var wPoint = scope.intersect.worldPosition;
            var cPoint = viewer.worldToClient(wPoint);

            intersectDiv.style.left = cPoint.x + "px";
            intersectDiv.style.top = cPoint.y + "px";

        }

    });

    // 在 pick 位置创建面板用于定位查看
    this.showLocationDiv = function () {

        var intersectDiv = document.getElementById('my_location_panel');

        if (!intersectDiv) {

            intersectDiv = document.createElement("div");
            intersectDiv.id = "my_location_panel";
            intersectDiv.style.visibility = "visible";
            intersectDiv.style.position = 'absolute';
            intersectDiv.style.width = "64px";
            intersectDiv.style.height = "64px";
            intersectDiv.style.opacity = 0.5;
            intersectDiv.style.background = 'yellow';
            intersectDiv.style.border = '1px dashed red';
            // intersectDiv.style.borderRadius = "50%";

        }

        if (this.intersect && this.intersect.worldPosition) {

            var wPoint = this.intersect.worldPosition;
            var cPoint = viewer.worldToClient(wPoint);

            intersectDiv.style.left = cPoint.x + "px";
            intersectDiv.style.top = cPoint.y + "px";

            if (!intersectDiv.parentNode) {
                document.body.appendChild(intersectDiv);
            }

        } else {

            if (intersectDiv.parentNode) {
                intersectDiv.parentNode.removeChild(intersectDiv);
            }

        }
    };

    var pick = false;
    var onMeasurePick = function (evt) {

        var scene = viewer.getScene();
        if (evt.pick) {

            if (evt.pickPoint != null) {

                if (!pick) {

                    pick = true;

                    if (scene.hasObjectGroup(CLOUD.ObjectGroupType.MEASURELINE)) {
                        scene.removeObjectGroupByName(CLOUD.ObjectGroupType.MEASURELINE);
                    }

                    var positions = new Array();
                    positions.push(evt.pickPoint.x);
                    positions.push(evt.pickPoint.y);
                    positions.push(evt.pickPoint.z);

                    positions.push(evt.pickPoint.x);
                    positions.push(evt.pickPoint.y);
                    positions.push(evt.pickPoint.z);

                    var measureGeometry = new THREE.LineSegmentsGeometry();
                    measureGeometry.setPositions(positions);
                    measureGeometry.positions = positions;

                    var geometry = new THREE.LineSegmentsGeometry();

                    var measureLine = new THREE.LineSegments2(measureGeometry);
                    var measureMaterial = measureLine.material;
                    measureMaterial.depthTest = false;
                    measureMaterial.linewidth = 5.0;
                    measureMaterial.resolution.set( window.innerWidth, window.innerHeight );
                    
                    var group = scene.getOrCreateObjectGroup(CLOUD.ObjectGroupType.MEASURELINE, {priority: 1, globalSpace: true});
                    group.add(measureLine);
                    group.updateMatrixWorld(true);
                    viewer.cameraControl.updateHighlight();

                }
                else {

                    pick = false;
                    var group = scene.getOrCreateObjectGroup(CLOUD.ObjectGroupType.MEASURELINE, {priority: 1, globalSpace: true});
                    var measureLine = group.children[0];
                    var measureGeometry = measureLine.geometry;
                    // measureGeometry.vertices[1].copy(evt.pickPoint);
                    // measureGeometry.verticesNeedUpdate = true;
                    // measureGeometry.attributes.instanceStart.data.array[3] = measureGeometry.attributes.instanceEnd.data.array[3] = evt.pickPoint.x;
                    // measureGeometry.attributes.instanceStart.data.array[4] = measureGeometry.attributes.instanceEnd.data.array[4] = evt.pickPoint.y;
                    // measureGeometry.attributes.instanceStart.data.array[5] = measureGeometry.attributes.instanceEnd.data.array[5] = evt.pickPoint.z;
                    var positions = measureGeometry.positions;
                    positions[3] = evt.pickPoint.x;
                    positions[4] = evt.pickPoint.y;
                    positions[5] = evt.pickPoint.z;
                    measureGeometry.setPositions(positions);

                    group.updateMatrixWorld(true);
                    viewer.cameraControl.updateHighlight();

                }

            }

        }
        else {

            if (evt.pickLine != null) {

                var measureGeometry = new THREE.Geometry();
                measureGeometry.vertices.push(evt.pickLine[0].clone());
                measureGeometry.vertices.push(evt.pickLine[1].clone());

                var measureLine = new THREE.Line(measureGeometry);
                var measureMaterial = measureLine.material;
                measureMaterial.depthTest = false;

                if (scene.hasObjectGroup(CLOUD.ObjectGroupType.MEASUREPICKLINE)) {
                    scene.removeObjectGroupByName(CLOUD.ObjectGroupType.MEASUREPICKLINE);
                }
                var group = scene.getOrCreateObjectGroup(CLOUD.ObjectGroupType.MEASUREPICKLINE, {priority: 1, globalSpace: true});
                group.add(measureLine);
                group.updateMatrixWorld(true);

            }
            else{

                if (scene.hasObjectGroup(CLOUD.ObjectGroupType.MEASUREPICKLINE)) {
                    scene.removeObjectGroupByName(CLOUD.ObjectGroupType.MEASUREPICKLINE);
                }

            }

            if (evt.pickPoint != null) {

                if (evt.pickLine == null && !evt.pickPlane) {

                    var measureGeometry = new THREE.Geometry();
                    measureGeometry.vertices.push(evt.pickPoint);

                    var measurePoint = new THREE.Points(measureGeometry);
                    if (scene.hasObjectGroup(CLOUD.ObjectGroupType.MEASUREPICKPOINT)) {
                        scene.removeObjectGroupByName(CLOUD.ObjectGroupType.MEASUREPICKPOINT);
                    }
                    var group = scene.getOrCreateObjectGroup(CLOUD.ObjectGroupType.MEASUREPICKPOINT, {priority: 1, globalSpace: true});
                    group.add(measurePoint);
                    group.updateMatrixWorld(true);

                }
                else{

                    if (scene.hasObjectGroup(CLOUD.ObjectGroupType.MEASUREPICKPOINT)) {
                        scene.removeObjectGroupByName(CLOUD.ObjectGroupType.MEASUREPICKPOINT);
                    }

                }

                if (pick) {

                    group = scene.getOrCreateObjectGroup(CLOUD.ObjectGroupType.MEASURELINE, {priority: 1, globalSpace: true});
                    var measureLine = group.children[0];
                    var measureGeometry = measureLine.geometry;
                    // measureGeometry.vertices[1].copy(evt.pickPoint);
                    // measureGeometry.verticesNeedUpdate = true;
                    // measureGeometry.attributes.instanceStart.data.array[3] = measureGeometry.attributes.instanceEnd.data.array[3] = evt.pickPoint.x;
                    // measureGeometry.attributes.instanceStart.data.array[4] = measureGeometry.attributes.instanceEnd.data.array[4] = evt.pickPoint.y;
                    // measureGeometry.attributes.instanceStart.data.array[5] = measureGeometry.attributes.instanceEnd.data.array[5] = evt.pickPoint.z;
                    var positions = measureGeometry.positions;
                    positions[3] = evt.pickPoint.x;
                    positions[4] = evt.pickPoint.y;
                    positions[5] = evt.pickPoint.z;
                    measureGeometry.setPositions(positions);

                    group.updateMatrixWorld(true);

                }
                
            }

            viewer.cameraControl.updateHighlight();

        }

    };
    viewer.registerEventListener(CLOUD.EVENTS.ON_MEASURE_PICK, onMeasurePick);

    var viewHandler = {
        names: ['home', 'front', 'back', 'left', 'right',
            'top', 'bottom', 'southEast', 'southWest', 'northEast',
            'northWest',
            'setTopView', 'goToInitialView', 'goToHomeView',
            'activeAnimation', 'deactiveAnimation',
            'moveCameraToCenter'],
        home: function () {
            viewer.setStandardView(CLOUD.EnumStandardView.ISO);
        },
        front: function () {
            viewer.setStandardView(CLOUD.EnumStandardView.Front);
        },
        back: function () {
            viewer.setStandardView(CLOUD.EnumStandardView.Back);
        },
        left: function () {
            viewer.setStandardView(CLOUD.EnumStandardView.Left);
        },
        right: function () {
            viewer.setStandardView(CLOUD.EnumStandardView.Right);
        },
        top: function () {
            viewer.setStandardView(CLOUD.EnumStandardView.Top);
        },
        bottom: function () {
            viewer.setStandardView(CLOUD.EnumStandardView.Bottom);
        },
        southEast: function () {
            viewer.setStandardView(CLOUD.EnumStandardView.SouthEast);
        },
        southWest: function () {
            viewer.setStandardView(CLOUD.EnumStandardView.SouthWest);
        },
        northEast: function () {
            viewer.setStandardView(CLOUD.EnumStandardView.NorthEast);
        },
        northWest: function () {
            viewer.setStandardView(CLOUD.EnumStandardView.NorthWest);
        },
        setTopView: function () {

            var box = viewer.getScene().getBoundingBoxWorld();
            box.min = new THREE.Vector3(box.min.x * 0.5, box.min.y * 0.5, box.min.z * 0.5);
            box.min = new THREE.Vector3(box.max.x * 0.5, box.max.y * 0.5, box.max.z * 0.5);

            viewer.setTopView(box);
        },
        goToInitialView: function () {
            viewer.goToInitialView();
        },
        goToHomeView: function () {
            viewer.goToHomeView();
        },
        // 激活场景动画
        activeAnimation: function () {
            viewer.setTransitionAnimationState(true);
        },
        // 关闭场景动画
        deactiveAnimation: function () {
            viewer.setTransitionAnimationState(false);
        },
        // 相机移动到场景中心位置
        moveCameraToCenter: function () {
            var box = viewer.getBoundingBoxWorld();
            var center = box.getCenter();
            viewer.locateToPoint(center);
        }
    };

    var renderHandler = {
        names: ['saveCamera', 'restoreCamera', 'cameraToOrthographic', 'cameraToPerspective'],
        enableIncrementRender: true,
        cameraInfo: "",
        limitFrameTime: 30,
        lightIntensityFactor: 1.0,

        saveCamera: function () {
            renderHandler.cameraInfo = viewer.getCamera();
            console.log(renderHandler.cameraInfo);
        },
        restoreCamera: function () {
            viewer.setCamera(renderHandler.cameraInfo);
            console.log(viewer.getCamera());
        },
        cameraToOrthographic: function () {
            viewer.toDefaultOrthographicCamera(true);
        },
        cameraToPerspective: function () {
            viewer.toDefaultPerspectiveCamera(true);
        }

    };

    var LightingHandler = {
        index: 0,
        helper: false,
        sunLight: 0.72,
        ambientLight: 0.6,
        fillLight01: 0.0,
        fillLight02: 0.0,
        fillLight03: 0.0
    };

    var IBLHandler = {
        enable: false,
        index: 0,
        debug: 0,
        roughness: 1.0,
        metalness: 0.0,
        shift: 0.5,
        A: 0.64,
        B: 0.03,
        C: 0.02,
        D: 0.54,
        E: 0.0,
        F: 0.81,
        scale: 0.92,

        setCubemapMaterial: function (name, value) {

            var scene = viewer.getScene();
            var flag = scene.hasObjectGroup(CLOUD.ObjectGroupType.IBLCUBE);
            if (flag) {
                var cubeMesh = scene.getOrCreateObjectGroup(CLOUD.ObjectGroupType.IBLCUBE).children[0];
                cubeMesh.material.uniforms[name].value = value;
            }

        },
    };

    var clipPlanesHandler = {
        names: ['clipPlanesStore', 'clipPlanesRestore', 'clipPlanesReset'],
        EnableClipPlanes: false,
        VisibleClipPlanes: false,
        RotatableClipPlanes: false,
        EnablePickClipPlanes: false,
        face: 0,
        offset: 0,
        faceName: 'right',
        axis: 0,
        rotate: 0,
        axisName: 'x',
        clipState: "",
        clipPlaneService: new CLOUD.ClipPlaneService(viewer),
        clipPlanesStore: function () {
            clipPlanesHandler.clipState = clipPlanesHandler.clipPlaneService.saveState();
        },
        clipPlanesRestore: function () {
            clipPlanesHandler.clipPlaneService.loadState(clipPlanesHandler.clipState);
            viewer.render();
        },
        clipPlanesReset: function () {
            clipPlanesHandler.clipPlaneService.reset();
            viewer.render();
        }
    };

    var fillClipPlaneHandler = {
        EnableFillClipPlane: false,
        VisibleFillClipPlane: false,
        RotatableFillClipPlane: false,
        RotY: false,
        EnablePickFillClipPlane: false,
        offset: 0,
        normal: 3
    };

    var zoomHandler = {
        names: ['zoomIn', 'zoomOut', 'zoomAll', 'zoomToBuilding', 'zoomSelection', 'zoomToBBox', 'fitAndRotateBySelection'],
        selectedBox: null,
        margin: 0.0,
        zoomIn: function () {
            viewer.zoomIn();
        },
        zoomOut: function () {
            viewer.zoomOut();
        },
        zoomAll: function () {
            viewer.zoomAll();
        },
        zoomToBuilding: function () {
            viewer.zoomToBuilding(0, 1.15);
        },
        zoomSelection: function () {
            viewer.zoomToSelection();
        },
        zoomToBBox: function () {

            if (!zoomHandler.selectedBox) {
                zoomHandler.selectedBox = viewer.getScene().getBoundingBoxWorld();
            }

            viewer.zoomToBBox(zoomHandler.selectedBox.clone());
        },
        zoomWithMargin: function (margin) {
            viewer.zoomAll(margin);
        },

        fitAndRotateBySelection: function () {
            viewer.fitAndRotateBySelection();
        }
    };

    var editorHandler = {
        names: ['fly', 'walk', 'pick', 'orbit', 'zoom', 'pan'],
        clipPlanes: false,
        fillClipPlane: false,
        rectPick: false,
        rectZoom: false,
        measure: false,

        toggleTool: function (toolName, state) {
            if (state) {
                viewer.editorManager.enableTool(viewer, toolName);
            } else {
                viewer.editorManager.disableTool(toolName);
            }

            viewer.render();
        },

        fly: function () {
            viewer.setEditorMode(CLOUD.EditorMode.FLY);
            scope.show(false);
        },
        walk: function () {
            viewer.setEditorMode(CLOUD.EditorMode.WALK);
            scope.show(false);
        },
        pick: function () {
            viewer.setPickMode();
            scope.show(false);
        },
        orbit: function () {
            viewer.setOrbitMode();
            scope.show(false);
        },
        zoom: function () {
            viewer.setZoomMode();
            scope.show(false);
        },
        pan: function () {
            viewer.setPanMode();
            scope.show(false);
        }
    };

    var filterHandler = {
        names: [
            'saveFilter', 'loadFilter',
            'setCategoryFilter', 'setFileFilter',
            'highlight',
            'makeSelectedTranslucent', 'makeSelectedOthersTranslucent', 'cancelTranslucentAll',
            'makeTranslucentScene', 'cancelSceneTranslucent', 'hideScene', 'showScene',
            'hideSelected', 'hideUnselected', 'cancelSelected',
            'showAll',
            'isolateHide', 'isolateTranslucent',
            'isolateHideSelections', 'isolateTranslucentSelections', 'clearIsolate',
            'setIsolateMaterial', 'resetIsolateMaterial',
            'setOverrideConditions', 'setHiddenOthersConditions',
            'isolateByBox'
        ],
        filterState: "",
        userFilterEnabled: false,
        fileFilterEnabled: false,
        highlightEnabled: false,
        saveFilter: function () {
            var obj = viewer.getFilter().saveState();
            this.filterState = JSON.stringify(obj);
            console.log(filterHandler.filterState);
        },
        loadFilter: function () {
            var obj = JSON.parse(filterHandler.filterState);
            viewer.getFilter().loadState(obj);
            console.log(obj);
            viewer.render();
        },
        setCategoryFilter: function () {
            var categoryIds = [];
            var filter = viewer.getFilter();

            if (!scope.selectionList) {
                return;
            }

            for (var i = 0, len = scope.selectionList.length; i < len; i++) {
                var uid = scope.selectionList[i];
                var info = viewer.getComponentInfoByUserId(uid);
                if (info && info.userData && info.userData.categoryId) {
                    if (info.userData.categoryId && categoryIds.indexOf(info.userData.categoryId) === -1) {
                        categoryIds.push(info.userData.categoryId);
                    }
                }
            }

            if (categoryIds.length < 1) {
                return;
            }

            filterHandler.userFilterEnabled = !filterHandler.userFilterEnabled;

            if (filterHandler.userFilterEnabled) {
                // filter.addToUserVisibleList("categoryId", categoryIds);
                filter.addToUserList(CLOUD.EnumUserType.HIDDEN_DATA, "categoryId", categoryIds);
            } else {
                // filter.clearUserVisibleList("categoryId");
                filter.clearUserList(CLOUD.EnumUserType.HIDDEN_DATA, "categoryId");

            }

            viewer.render();
        },

        setFileFilter: function () {
            var fileIds = [];
            var filter = viewer.getFilter();

            if (!scope.selectionList) {
                return;
            }

            for (var i = 0, len = scope.selectionList.length; i < len; i++) {
                var uid = scope.selectionList[i];
                var info = viewer.getComponentInfoByUserId(uid);
                if (info && info.userData && info.userData.sceneId)  {
                    var sceneId = info.userData.sceneId;
                    var idx = sceneId.indexOf('.');
                    var fileId;
                    if (idx !== -1) {
                        fileId = sceneId.substring(0, idx);
                    } else {
                        fileId = sceneId;
                    }
                    if (fileIds.indexOf(fileId) === -1) {
                        fileIds.push(fileId);
                    }
                }
            }

            if (fileIds.length < 1) {
                return;
            }

            filterHandler.fileFilterEnabled = !filterHandler.fileFilterEnabled;

            if (filterHandler.fileFilterEnabled) {
                // filter.addToFileList(fileIds);
                filter.addToIdList(CLOUD.EnumIdBasedType.FILE_HIDDEN, fileIds)
            } else {
                // filter.clearFileList();
                filter.clearIdList(CLOUD.EnumIdBasedType.FILE_HIDDEN)
            }

            viewer.render();
        },
        highlight: function () {

            if (!scope.selectionList) {
                return;
            }
            var filter = viewer.getFilter();
            var nodeIds = scope.selectionList;

            filterHandler.highlightEnabled = !filterHandler.highlightEnabled;

            if (filterHandler.highlightEnabled) {
                filter.setOverrideListByColor("youName", nodeIds, {color: 0xff0000, opacity: 0.8});
            } else {
                filter.clearOverrideList("youName");
            }

            viewer.render();

        },
        // 半透明[选中]的构件
        makeSelectedTranslucent: function () {
            CLOUD.FilterUtil.makeSelectedTranslucent(viewer);
            viewer.render();
        },
        // 半透明[未选中]的构件
        makeSelectedOthersTranslucent: function () {
            CLOUD.FilterUtil.makeSelectedOthersTranslucent(viewer);
            viewer.render();
        },
        // 取消半透明
        cancelTranslucentAll: function () {
            var filter = viewer.getFilter();
            filter.cancelTranslucent();
            viewer.render();
        },
        // 半透明场景
        makeTranslucentScene: function () {
            var filter = viewer.getFilter();
            filter.makeSceneTranslucent();
            viewer.render();
        },
        // 取消场景半透明
        cancelSceneTranslucent: function () {
            var filter = viewer.getFilter();
            filter.cancelSceneTranslucent();
            viewer.render();
        },

        // 隐藏场景
        hideScene: function () {
            var filter = viewer.getFilter();
            filter.hideScene();
            viewer.render();
        },
        // 取消隐藏场景
        showScene: function () {
            var filter = viewer.getFilter();
            filter.showScene();
            viewer.render();
        },

        // 隐藏[选中]的构件
        hideSelected: function () {
            var filter = viewer.getFilter();
            filter.clearIdList(CLOUD.EnumIdBasedType.HIDDEN);
            filter.clearIdList(CLOUD.EnumIdBasedType.VISIBLE);

            CLOUD.FilterUtil.hideSelections(viewer);
            viewer.render();
        },
        // 隐藏[未选中]的构件
        hideUnselected: function () {
            var filter = viewer.getFilter();
            filter.clearIdList(CLOUD.EnumIdBasedType.HIDDEN);
            filter.clearIdList(CLOUD.EnumIdBasedType.VISIBLE);
            CLOUD.FilterUtil.hideUnselections(viewer);
            viewer.render();
        },
        // 取消选中
        cancelSelected: function () {
            viewer.clearSelection();
            viewer.render();
        },
        // 恢复
        showAll: function () {
            var filter = viewer.getFilter();
            filter.clear();
            viewer.render();
        },
        isolateHide: function () {
            if (!scope.selectionList) {
                return;
            }

            var conditions = [];

            for (var i = 0, len = scope.selectionList.length; i < len; i++) {
                var uid = scope.selectionList[i];
                var info = viewer.getComponentInfoByUserId(uid);
                if (info && info.userData && info.userData.categoryId) {
                    conditions.push({categoryId: info.userData.categoryId});
                }
            }

            viewer.isolate(conditions, "hide");
            viewer.render();
        },
        isolateTranslucent: function () {

            if (!scope.selectionList) {
                return;
            }

            var conditions = [];

            for (var i = 0, len = scope.selectionList.length; i < len; i++) {
                var uid = scope.selectionList[i];
                var info = viewer.getComponentInfoByUserId(uid);
                if (info && info.userData && info.userData.categoryId) {
                    conditions.push({categoryId: info.userData.categoryId});
                }
            }

            viewer.isolate(conditions, "translucent");
            viewer.render();
        },

        isolateHideSelections: function () {
            CLOUD.FilterUtil.isolateSelections(CLOUD.EnumIsolateState.HIDDEN_OTHERS, viewer);
            viewer.render();
        },
        isolateTranslucentSelections: function () {
            // filter.clearAllIsolateList();
            CLOUD.FilterUtil.isolateSelections(CLOUD.EnumIsolateState.TRANSLUCENT_OTHERS, viewer);
            viewer.render();
        },

        clearIsolate: function () {
            var filter = viewer.getFilter();
            filter.clearAllIsolateList();
            filter.clearAllIsolateConditions();
            viewer.render();
        },

        setIsolateMaterial: function () {
            viewer.setIsolateMaterial({color: 0xffff00});
            viewer.render();
        },

        resetIsolateMaterial: function () {
            viewer.resetIsolateMaterial();
            viewer.render();
        },

        setOverrideConditions: function () {

            if (!scope.selectionList) {
                return;
            }

            var filter = viewer.getFilter();
            var conditions = [];

            for (var i = 0, len = scope.selectionList.length; i < len; i++) {
                var uid = scope.selectionList[i];
                var info = viewer.getComponentInfoByUserId(uid);
                if (info && info.userData) {
                    conditions.push({
                        condition: {sceneId: info.userData.sceneId, categoryId: info.userData.categoryId},
                        color: {color: 0xff0000, opacity: 0.5}
                    });
                }
            }

            filter.setConditions(CLOUD.EnumConditionType.OVERRIDE, conditions);
            viewer.render();
        },

        setHiddenOthersConditions: function () {
            if (!scope.selectionList) {
                return;
            }

            var filter = viewer.getFilter();
            var conditions = [];

            for (var i = 0, len = scope.selectionList.length; i < len; i++) {
                var uid = scope.selectionList[i];
                var info = viewer.getComponentInfoByUserId(uid);
                if (info && info.userData) {
                    if (i % 3 === 1) {
                        conditions.push({specialty: info.userData.specialty});
                    } else {
                        conditions.push({categoryId: info.userData.categoryId});
                    }
                }
            }

            filter.setConditions(CLOUD.EnumConditionType.HIDDEN_OTHERS, conditions);
            viewer.render();
        },

        isolateByBox: function () {

            if (!scope.selectionList) {
                return;
            }

            var filter = viewer.getFilter();
            var box = new THREE.Box3();

            for (var i = 0, len = scope.selectionList.length; i < len; i++) {
                var uid = scope.selectionList[i];
                var info = viewer.getComponentInfoByUserId(uid);
                if (info) {
                    box.union(info.boundingBox);
                }
            }

            var ids = viewer.getObjectsInBox(box);
            filter.addToIsolateList(CLOUD.EnumIsolateState.TRANSLUCENT_OTHERS, ids);
            // filter.addToIsolateList(CLOUD.EnumIsolateState.HIDDEN_OTHERS, ids);

            viewer.render();
        }
    };

    var sceneHandler = {
        names: ['loadModel', 'unloadModel', 'unloadAllModel', 'showModel', 'hideModel', 'showScene', 'loadedOnDemand', 'loadedAllMpks'],
        model: null,
        bVisible: false,
        loadModel: function () {
            sceneHandler.model = viewer.load("smallHouse", serverUrl);
            scope.show(false);
        },
        unloadModel: function () {
            viewer.unload("navisworks");
            scope.show(false);
        },
        unloadAllModel: function () {
            sceneHandler.model = null;
            viewer.unloadAll();
            scope.show(false);
        },
        showModel: function () {
            viewer.showModel("navisworks");
            scope.show(false);
        },
        hideModel: function () {
            viewer.hideModel("navisworks");
            scope.show(false);
        },
        showScene: function () {

            if (sceneHandler.model) {

                viewer.showScene(sceneHandler.model, sceneHandler.bVisible);

                sceneHandler.bVisible = !sceneHandler.bVisible;
            }

            scope.show(false);
        },
        loadedOnDemand: function () {
            var conditions = [
                // {levelName: "-1654412967852844670", specialty: "åå»º"},
                // {levelName: "-1654412967852844670", specialty: "ç²è£ä¿®"},
                // {levelName: "-3928521365127602219", specialty: "åå»º"},
                // {levelName: "-3928521365127602219", specialty: "ç²è£ä¿®"},
                // {levelName: "4908688574038536051", specialty: "åå»º"},
                // {levelName: "4908688574038536051", specialty: "ç²è£ä¿®"},
                // {levelName: "6310943268018496696", specialty: "åå»º"},
                // {levelName: "6310943268018496696", specialty: "ç²è£ä¿®"},
                {levelName: "721696291655931787", specialty: "åå»º"},
                {levelName: "721696291655931787", specialty: "土建"}
            ];
            viewer.setConditionsOnDemandLoad(conditions, undefined, undefined, function () {
                var box = viewer.getBoundingBoxOnDemand();
                viewer.zoomToBBox(box);
                // viewer.render();
            });
        },
        loadedAllMpks: function () {
            viewer.setConditionsOnDemandLoad(undefined, undefined, undefined, function () {
                var box = viewer.getBoundingBoxOnDemand();
                viewer.zoomToBBox(box);
                // viewer.render();
            });
        }
    };

    var performanceHandler = {
        handle: 0,
        octantDepth: 5,
        isShowOctantBox: false,
        autoUpdate: false,
        autoRotateSpeed: 2,
        objectPoolSize: 100000,

        animate: function () {

            if (viewer) {
                viewer.rotateByAxis(-performanceHandler.autoRotateSpeed);
            }

            // if (performanceHandler.handle > 0) {
            //
            //     performanceHandler.stopAnimate();
            // }

            performanceHandler.handle = requestAnimationFrame(performanceHandler.animate);

            stats.update();
        },
        stopAnimate: function () {

            cancelAnimationFrame(performanceHandler.handle);
        }
    };

    var movementHandler = {

        names: ['moveNone', 'moveUp', 'moveDown', 'moveLeft', 'moveRight', 'moveForward', 'moveBack',
            'setReverseWheelDirection'],

        enabled: false,

        speedRate: 1.0,

        moveNone: function () {
            viewer.moveTo(CLOUD.MoveDirection.NONE);
        },

        moveUp: function () {
            viewer.moveTo(CLOUD.MoveDirection.UP);
        },

        moveDown: function () {
            viewer.moveTo(CLOUD.MoveDirection.DOWN);
        },

        moveLeft: function () {
            viewer.moveTo(CLOUD.MoveDirection.LEFT);
        },

        moveRight: function () {
            viewer.moveTo(CLOUD.MoveDirection.RIGHT);
        },

        moveForward: function () {
            viewer.moveTo(CLOUD.MoveDirection.FORWARD);
        },

        moveBack: function () {
            viewer.moveTo(CLOUD.MoveDirection.BACK);
        },

        setReverseWheelDirection: function () {

            this.enabled = !this.enabled;
            viewer.setReverseWheelDirection(this.enabled);
            viewer.render();

        },

        setMovementSpeedRate: function (rate) {
            viewer.setMovementSpeedRate(rate);
        }
    };

    var occlusionTranslucentHandler = {

        opacity: 0.5,

        distance: 1000,

        enabled: false,

        enableOcclusionTranslucent: function (enable) {
            viewer.enableOcclusionTranslucent(enable);
        },

        setOcclusionOpacity: function (opacity) {
            viewer.setOcclusionOpacity(opacity);
        },

        setOcclusionDistanceToCamera: function (distance) {
            viewer.setOcclusionDistanceToCamera(distance);
        }

    };

    var walkHandler = {

        height: 1750,

        heightForAbsolute: 1750,

        initialCameraHeight: null,

        isLockHeight: false,

        isLookMousePressed: true,
        isWorkingWithGravity: false,
        speedRate: 1,

        setWalk: function () {

            viewer.setEditorMode(CLOUD.EditorMode.WALK);
            scope.show(false);

        },

        setRoamingWalkHeight: function (height) {

            var box = viewer.getBoundingBoxWorld();
            var elevations = [];

            var minVal = box.min.z;
            var maxVal = box.max.z;

            for (var i = 0; i < 5; ++i) {

                var elevation = minVal + (maxVal - minVal) * i / 5;

                elevations.push(elevation);

            }

            // console.log("height", height);

            viewer.setRoamingWalkHeight(elevations, height);
        },

        setRoamingWalkAbsoluteHeight: function (height) {

            if (viewer.camera) {

                if (walkHandler.initialCameraHeight === null) {

                    var cameraInfo = viewer.cameraToWorld({
                        position: viewer.camera.position,
                        target: viewer.camera.target,
                        up: viewer.camera.up
                    });
                    walkHandler.initialCameraHeight = cameraInfo.position.z;

                }

                var absHeight = walkHandler.initialCameraHeight + height;

                viewer.setRoamingWalkAbsoluteHeight(absHeight);

            }

        },

        setWalkHeightLocked: function (lock) {
            viewer.setWalkHeightLocked(lock);
        },

        setWalkLookMousePressed: function (press) {
            viewer.setWalkLookMousePressed(press);
        },
        setWalkingWithGravity: function (press) {
            CLOUD.GlobalData.WalkingWithGravity = press;
        },
        setWalkSpeedRate: function (rate) {
            viewer.setWalkSpeedRate(rate);
        }

    };

    var testHandler = {

        names: ['releaseViewer',
            'screenShot', 'asyncScreenShot',
            'zoomToBoxByUserId',
            'setCategoriesToHighPriority', 'clearAllCategoriesFromHighPriority',
            'lockAxisZ',
            'testBoxClipping',
            'rotationBySelection', 'rotationByCenter', 'rotationByMouse', 'rotationByCamera',
            'setOrbitButtonLeft', 'setOrbitButtonRight',
            'worldToClient', 'clientToWorld', 'insideCamera', 'changeCubeMap',
            'cameraTransformTest',
            'enableTextureMapping'],
        isLock: false,

        textureEnabled: true,

        enabled: false,

        cameraInfoWorld: null,

        clientXY: {x: 0, y: 0},

        releaseViewer: function () {
            viewer.destroy();
        },

        screenShot: function () {

            // 在新窗口中显示图片
            var win = window.open();

            function snapshot(dataUrl) {

                if (dataUrl) {
                    // 在新窗口中显示图片
                    // var win = window.open();
                    win.document.write('<!DOCTYPE html><html lang="en">');
                    win.document.write('<head><meta charset="utf-8"><title>Cloud Viewer - Screen Shot</title>');
                    win.document.write('<link href="../css/main.css" rel="stylesheet" /></head>');
                    win.document.write('<div class="viewport"><div><img src="' + dataUrl + '" /> </div>');
                    win.document.write('</html>');
                    win.document.close();
                }
            }

            //viewer.getRenderBufferScreenShot(undefined, snapshot);
            viewer.screenShot(800, 600, snapshot);
        },

        markerScreenShot: function () {

            var win = window.open();

            function snapshot(dataUrl) {

                if (dataUrl) {
                    // 在新窗口中显示图片
                    // var win = window.open();
                    win.document.write('<!DOCTYPE html><html lang="en">');
                    win.document.write('<head><meta charset="utf-8"><title>Cloud Viewer - Screen Shot</title>');
                    win.document.write('<link href="../css/main.css" rel="stylesheet" /></head>');
                    win.document.write('<div class="viewport"><div><img src="' + dataUrl + '" /> </div>');
                    win.document.write('</html>');
                    win.document.close();
                }
            }

            markerManager.getScreenSnapshot(snapshot);

        },

        asyncScreenShot: function () {

            // 在新窗口中显示图片
            var win = window.open();

            function snapshot(dataUrl) {

                if (dataUrl) {
                    // 在新窗口中显示图片
                    // var win = window.open();
                    win.document.write('<!DOCTYPE html><html lang="en">');
                    win.document.write('<head><meta charset="utf-8"><title>Cloud Viewer - Screen Shot</title>');
                    win.document.write('<link href="../css/main.css" rel="stylesheet" /></head>');
                    win.document.write('<div class="viewport"><div><img src="' + dataUrl + '" /> </div>');
                    win.document.write('</html>');
                    win.document.close();
                }
            }

            viewer.canvas2image(undefined, snapshot);

        },

        zoomToBoxByUserId: function () {

            if (scope.id === "") {
                return;
            }

            var id = scope.id;
            var node = viewer.getScene().getNodeById(id);
            var bBox = CLOUD.GeomUtil.getBoundingBoxWorldOfMesh(node, viewer.getScene().getMatrixGlobal());
            viewer.zoomToBBox(bBox);
        },

        setCategoriesToHighPriority: function () {

            // wanda 03
            // 室外：
            // LC&GS_-2001340   // "categoryId":"-2001340","categoryName":"地形"
            // LC&GS_-2000032   // "categoryId":"-2000032","categoryName":"楼板"
            // CW&LI_-2000011  // "categoryId":"-2000011","categoryName":"墙"
            // LR_-2000170      // "categoryId":"-2000170","categoryName":"幕墙嵌板"
            //
            // 室内：
            // IN&GS_-2000032   // "categoryId":"-2000032","categoryName":"楼板"
            // IN&GS_-2000011   // "categoryId":"-2000011","categoryName":"墙"
            // IN&GS_-2000126   //"categoryId":"-2000126","categoryName":"栏杆扶手"
            // IN&GS_-2000038   //"categoryId":"-2000038","categoryName":"天花板"
            //
            // AR_-2000011      // "categoryId":"-2000011","categoryName":"墙"
            // ST_-2000011      // "categoryId":"-2000011","categoryName":"墙"
            // ST_-2001320     //"categoryId":"-2001320","categoryName":"结构框架"
            // ST_-2000032     // "categoryId":"-2000032","categoryName":"楼板"
            //
            // ST_-2001330 　　//"categoryId":"-2001330","categoryName":"结构柱"

            // var categories = [-2008079,-2008055,-2008049,-2008044,-2003400,-2001360,-2001320,-2001300,-2001260,-2001140,-2001120,-2000170,-2000151,-2000126,-2000032,-2000023,-2000011];
            // var categories = [-2001260,-2001360, -2000170, -2000032];
            // var categories = [-2001260,-2001360, -2000032];
            var categoriesOuter = ["LC&GS_-2001340", "LC&GS_-2000032", "CW&LI_-2000011", "LR_-2000170"];
            viewer.setCategoriesToHighPriority(categoriesOuter, 1);

            var categoriesInner = ["IN&GS_-2000032", "IN&GS_-2000011", "IN&GS_-2000126", "IN&GS_-2000038",
                "AR_-2000011", "ST_-2000011", "ST_-2001320", "ST_-2000032", "ST_-2001330"];
            viewer.setCategoriesToHighPriority(categoriesInner, 0);

            viewer.render();
        },
        clearAllCategoriesFromHighPriority: function () {
            viewer.clearAllCategoriesFromHighPriority();
            viewer.render();
        },
        lockAxisZ: function () {
            testHandler.isLock = !testHandler.isLock;
            viewer.lockAxisZ(testHandler.isLock);
            viewer.render();
        },
        // test integrated box clipping - xiaojian
        testBoxClipping: function () {
            var editorType = viewer.getEditorType();
            viewer.setEditorMode(editorType.ClipByBox, false);
            var clipPlanes = viewer.getScene().getClipPlanes();
            clipPlanes.enable(true, true);
            viewer.render();
        },

        rotationBySelection: function () {
            viewer.setPointRotateMode(CLOUD.PointRotateMode.SELECTION);
        },

        rotationByCenter: function () {
            viewer.setPointRotateMode(CLOUD.PointRotateMode.CENTER);
        },

        rotationByMouse: function () {
            viewer.setPointRotateMode(CLOUD.PointRotateMode.MOUSEPOINT);
        },

        rotationByCamera: function () {
            viewer.setPointRotateMode(CLOUD.PointRotateMode.CAMERA);
        },

        setOrbitButtonLeft: function () {

            viewer.setOrbitButton('left');

        },

        setOrbitButtonRight: function () {

            viewer.setOrbitButton('right');

        },

        worldToClient: function () {

            var intersect = scope.intersect;
            var intersectDiv = document.getElementById('my_test_intersect');

            if (!intersectDiv) {
                intersectDiv = document.createElement("div");
                intersectDiv.id = "my_test_intersect";
                document.body.appendChild(intersectDiv);
            }

            if (intersect) {

                var wPoint = intersect.worldPosition;
                var cPoint = viewer.worldToClient(wPoint);

                intersectDiv.style.visibility = "visible";
                intersectDiv.style.position = 'absolute';
                intersectDiv.style.left = cPoint.x + "px";
                intersectDiv.style.top = cPoint.y + "px";
                intersectDiv.style.width = "50px";
                intersectDiv.style.height = "50px";
                intersectDiv.style.opacity = 0.5;
                intersectDiv.style.background = 'yellow';
                intersectDiv.style.border = '1px dashed red';

            } else {

                intersectDiv.style.visibility = "hidden";

            }

        },

        clientToWorld: function () {

            var intersect = scope.intersect;
            var intersectDiv = document.getElementById('my_test_intersect');

            if (!intersectDiv) {
                intersectDiv = document.createElement("div");
                intersectDiv.id = "my_test_intersect";
                document.body.appendChild(intersectDiv);
            }

            if (intersect) {

                var wPoint = intersect.worldPosition;
                var cPoint = viewer.worldToClient(wPoint);
                var wPoint2 = viewer.clientToWorld(cPoint);

                if (Math.abs(wPoint.x - wPoint2.x) < 2 &&
                    Math.abs(wPoint.y - wPoint2.y) < 2) {

                    intersectDiv.style.visibility = "visible";
                    intersectDiv.style.position = 'absolute';
                    intersectDiv.style.left = cPoint.x + "px";
                    intersectDiv.style.top = cPoint.y + "px";
                    intersectDiv.style.width = "50px";
                    intersectDiv.style.height = "50px";
                    intersectDiv.style.opacity = 0.5;
                    intersectDiv.style.background = 'wheat';
                    intersectDiv.style.border = '1px dashed blue';

                } else {

                    intersectDiv.style.visibility = "hidden";

                }

            } else {

                intersectDiv.style.visibility = "hidden";

            }
        },

        insideCamera: function () {

            var intersect = scope.intersect;

            if (intersect) {

                var wPoint = intersect.worldPosition;
                var inCamera = viewer.insideCamera(wPoint);

                //console.log("in camera:" + inCamera);
                alert("in camera:" + inCamera);
            }

        },

        changeCubeMap: function () {
            viewer.initIBL("images/HighContrast.jpg", false, false);

            viewer.render();
        },

        enableTextureMapping: function () {

            this.textureEnabled = !this.textureEnabled;

            viewer.enableTextureMapping(this.textureEnabled);
            viewer.render();
        },


        cameraTransformTest: function () {

            if (viewer.camera) {

                var cameraInfo = {position: viewer.camera.position, target: viewer.camera.target, up: viewer.camera.up};
                var cameraInfoWorld = viewer.cameraToWorld(cameraInfo);
                var cameraInfo2 = viewer.cameraToDrawing(cameraInfoWorld);

                console.log("cameraInfo", cameraInfo);
                console.log("cameraInfo2", cameraInfo2);

                viewer.render();
            }

        }

    };

    var markerHandler = {

        names: ["activate", "deactivate", "add", "addItems", "remove", "removeById", "save", "load", "clear", "show", "hide", "getItemById", "getItems"],
        helper: new CLOUD.Marker3D(viewer),
        items: null,

        activate: function () {
            var helper = markerHandler.helper;
            helper.activate();
            viewer.render();
        },

        deactivate: function () {
            var helper = markerHandler.helper;
            helper.deactivate();
            viewer.render();
        },

        save: function () {

            var helper = markerHandler.helper;
            this.items = helper.getItems();
        },

        load: function () {

            var helper = markerHandler.helper;

            if (this.items) {
                helper.load(this.items);
                viewer.render();
            }

        },

        clear: function () {

            var helper = markerHandler.helper;
            helper.clear();
            viewer.render();
        },

        add: function () {

            var helper = markerHandler.helper;

            if (scope.intersect) {

                var worldPosition = {
                    x: scope.intersect.worldPosition.x,
                    y: scope.intersect.worldPosition.y,
                    z: scope.intersect.worldPosition.z
                };

                var item = {
                    position: worldPosition,
                    size: 64,
                    iconUrl: "../textures/sprites/circle.png",
                    tooltip: "circle-64"
                };

                helper.add([item]);
                // viewer.render();
            }

        },

        addItems: function () {

            var helper = markerHandler.helper;

            if (scope.intersect) {

                var box = viewer.getBoundingBoxWorld();
                var size = box.getSize();
                var minCorner = box.min;
                var worldPosition = {
                    x: scope.intersect.worldPosition.x,
                    y: scope.intersect.worldPosition.y,
                    z: scope.intersect.worldPosition.z
                };

                var items = [
                    {
                        position: {x: worldPosition.x, y: worldPosition.y, z: worldPosition.z},
                        size: 32,
                        iconUrl: "../textures/sprites/circle1.png", // 增加一个错误地址
                        tooltip: "circle-error"
                    },
                    {
                        position: {x: worldPosition.x, y: worldPosition.y, z: worldPosition.z},
                        size: 32,
                        iconUrl: "../textures/sprites/circle.png",
                        tooltip: "circle-32"
                    },
                    {
                        position: {
                            x: minCorner.x + Math.floor(Math.random() * size.x),
                            y: minCorner.y + Math.floor(Math.random() * size.y),
                            z: minCorner.z + Math.floor(Math.random() * size.z)
                        },
                        size: 64,
                        iconUrl: "../textures/sprites/circle.png",
                        tooltip: "circle-64"
                    },
                    {
                        position: {
                            x: minCorner.x + Math.floor(Math.random() * size.x),
                            y: minCorner.y + Math.floor(Math.random() * size.y),
                            z: minCorner.z + Math.floor(Math.random() * size.z)
                        },
                        size: 64,
                        iconUrl: "../textures/sprites/circle.png",
                        tooltip: "circle-64"
                    },
                    {
                        position: {
                            x: minCorner.x + Math.floor(Math.random() * size.x),
                            y: minCorner.y + Math.floor(Math.random() * size.y),
                            z: minCorner.z + Math.floor(Math.random() * size.z)
                        },
                        size: 32,
                        iconUrl: "../textures/sprites/ball.png",
                        tooltip: "ball-32"
                    },
                    {
                        position: {
                            x: minCorner.x + Math.floor(Math.random() * size.x),
                            y: minCorner.y + Math.floor(Math.random() * size.y),
                            z: minCorner.z + Math.floor(Math.random() * size.z)
                        },
                        size: 64,
                        iconUrl: "../textures/sprites/ball.png",
                        tooltip: "ball-64"
                    }
                ];

                helper.add(items);
            }


        },

        remove: function () {

            var helper = markerHandler.helper;
            var items = helper.getItems();

            if (items) {

                var idx = Math.floor(Math.random() * 5);

                if (idx >= items.length) {
                    idx = items.length - 1;
                }

                helper.remove(items[idx]);
                viewer.render();
            }


        },

        removeById: function () {

            var helper = markerHandler.helper;

            var items = helper.getItems();

            if (items) {

                var idx = Math.floor(Math.random() * 5);

                if (idx >= items.length) {
                    idx = items.length - 1;
                }

                var item = items[idx];

                helper.removeById(item.id);
                viewer.render();
            }

        },

        show: function () {
            var helper = markerHandler.helper;
            helper.show();
            viewer.render();
        },

        hide: function () {
            var helper = markerHandler.helper;
            helper.hide();
            viewer.render();
        },

        getItemById: function () {

            var helper = markerHandler.helper;
            var items = helper.getItems();
            var message = "";

            if (items) {

                message = JSON.stringify(helper.getItemById(items[0].id));

            } else {
                message = "getItemById : no item";
            }

            alert(message);

        },

        getItems: function () {

            var helper = markerHandler.helper;

            alert(JSON.stringify(helper.getItems()));
        }

    };

    var gui = new dat.GUI();
    // 设置gui面板样式
    gui.domElement.className = 'gui-panel';

    this.getGUI = function () {
        return gui;
    };

    this.addControls = function () {
        gui.closed = true;
        gui.add(this, 'id').listen();
        gui.add(this, 'projectId').listen();

        var editorFolder = gui.addFolder('Editor');
        for (var i = 0, len = editorHandler.names.length; i < len; ++i) {
            editorFolder.add(editorHandler, editorHandler.names[i]);
        }

        editorFolder.add(editorHandler, 'clipPlanes').name('ClipPlanes').listen()
            .onChange(
                function (value) {
                    editorHandler.toggleTool(CLOUD.EditToolMode.CLIP_BY_BOX, value);
                }
            );
        editorFolder.add(editorHandler, 'fillClipPlane').name('fillClipPlane').listen()
            .onChange(
                function (value) {
                    editorHandler.toggleTool(CLOUD.EditToolMode.CLIP_FILL, value);
                }
            );
        editorFolder.add(editorHandler, 'rectPick').name('rectPick').listen()
            .onChange(
                function (value) {
                    editorHandler.toggleTool(CLOUD.EditToolMode.PICK_BY_RECT, value);
                }
            );
        editorFolder.add(editorHandler, 'rectZoom').name('rectZoom').listen()
            .onChange(
                function (value) {
                    editorHandler.toggleTool(CLOUD.EditToolMode.ZOOM_BY_RECT, value);
                }
            );
        editorFolder.add(editorHandler, 'measure').name('measure').listen()
            .onChange(
                function (value) {
                    editorHandler.toggleTool(CLOUD.EditToolMode.PICK_BY_MEASURE, value);
                }
            );

        var viewFolder = gui.addFolder('View');
        for (var i = 0, len = viewHandler.names.length; i < len; ++i) {
            viewFolder.add(viewHandler, viewHandler.names[i]);
        }

        var zoomFolder = gui.addFolder('Zoom');
        for (var i = 0, len = zoomHandler.names.length; i < len; ++i) {
            zoomFolder.add(zoomHandler, zoomHandler.names[i]);
        }
        zoomFolder.add(zoomHandler, 'margin', -1.0, 1.0).step(0.01).listen().onChange(
            function (value) {
                zoomHandler.margin = value;
                zoomHandler.zoomWithMargin(value);
            }
        );

        var renderFolder = gui.addFolder('Render');
        for (var i = 0, len = renderHandler.names.length; i < len; ++i) {
            renderFolder.add(renderHandler, renderHandler.names[i]);
        }

        renderFolder.add(renderHandler, 'limitFrameTime', 0.0, 1000.0).step(10).name('limitTime(ms)').listen().onChange(
            function (value) {
                viewer.setLimitFrameTime(value);
                viewer.render();
            }
        );

        renderFolder.add(renderHandler, 'lightIntensityFactor', 0.0, 2.5).step(0.01).listen().onChange(
            function (value) {
                viewer.setLightIntensityFactor(value);
                viewer.render();
            }
        );

        var lightingFolder = gui.addFolder("Lighting");
        lightingFolder.add(LightingHandler, 'index', 0, 3).step(1).listen().onChange(
            function (value) {
                viewer.setLightPreset(value);
                viewer.render();
            }
        );
        lightingFolder.add(LightingHandler, 'sunLight', 0, 1).step(0.01).listen().onChange(
            function (value) {
                var sunLight = viewer.getScene().sunLight;
                if (sunLight) {
                    sunLight.intensity = value;
                    viewer.render();
                }
            }
        );
        lightingFolder.add(LightingHandler, 'ambientLight', 0, 1).step(0.01).listen().onChange(
            function (value) {
                var ambientLight = viewer.getScene().ambientLight;
                if (ambientLight) {
                    ambientLight.intensity = value;
                    viewer.render();
                }
            }
        );
        lightingFolder.add(LightingHandler, 'fillLight01', 0, 1).step(0.01).listen().onChange(
            function (value) {
                var fillLight01 = viewer.getScene().fillLight01;
                if (fillLight01) {
                    fillLight01.intensity = value;
                    viewer.render();
                }
            }
        );
        lightingFolder.add(LightingHandler, 'fillLight02', 0, 1).step(0.01).listen().onChange(
            function (value) {
                var fillLight02 = viewer.getScene().fillLight02;
                if (fillLight02) {
                    fillLight02.intensity = value;
                    viewer.render();
                }
            }
        );
        lightingFolder.add(LightingHandler, 'fillLight03', 0, 1).step(0.01).listen().onChange(
            function (value) {
                var fillLight03 = viewer.getScene().fillLight03;
                if (fillLight03) {
                    fillLight03.intensity = value;
                    viewer.render();
                }
            }
        );
        lightingFolder.add(LightingHandler, 'helper').name('helper').listen().onChange(
            function (value) {
                if (value) {
                    viewer.getScene().addLightHelper();
                }
                else {
                    viewer.getScene().clearLightHelper();
                }
                viewer.getScene().lightHelper = value;
                viewer.render();
            }
        );

        var IBLFolder = gui.addFolder('IBL');
        IBLFolder.add(IBLHandler, 'enable').name('enable').listen()
            .onChange(
                function (value) {
                    viewer.getIBLManager().enableIBL(value);
                    if (!value) {
                        viewer.render();
                    }
                }
            );
        IBLFolder.add(IBLHandler, 'index', 0, 14).step(1).listen().onChange(
            function (value) {
                viewer.getIBLManager().initIBLByIndex(value);
            }
        );
        IBLFolder.add(IBLHandler, 'debug', 0, 7).step(1).listen().onChange(
            function (value) {
                viewer.modelManager.updateMaterialsValue('debug', value);
                viewer.render();
            }
        );

        IBLFolder.add(IBLHandler, 'roughness', 0.0, 1.0).step(0.05).listen().onChange(
            function (value) {
                viewer.modelManager.updateMaterialsValue('roughness', value);
                viewer.render();
            }
        );

        IBLFolder.add(IBLHandler, 'metalness', 0.0, 1.0).step(0.05).listen().onChange(
            function (value) {
                viewer.modelManager.updateMaterialsValue('metalness', value);
                viewer.render();
            }
        );

        IBLFolder.add(IBLHandler, 'shift', -1.0, 1.0).step(0.01).listen().onChange(
            function (value) {
                IBLHandler.setCubemapMaterial('shift', value);
                viewer.setExposureShift(value);
            }
        );

        IBLFolder.add(IBLHandler, 'A', 0.0, 1.0).step(0.01).listen().onChange(
            function (value) {
                IBLHandler.setCubemapMaterial('A', value);
                viewer.modelManager.updateMaterialsValue('A', value);
                viewer.render();
            }
        );

        IBLFolder.add(IBLHandler, 'B', 0.0, 1.0).step(0.01).listen().onChange(
            function (value) {
                IBLHandler.setCubemapMaterial('B', value);
                viewer.modelManager.updateMaterialsValue('B', value);
                viewer.render();
            }
        );

        IBLFolder.add(IBLHandler, 'C', 0.0, 1.0).step(0.01).listen().onChange(
            function (value) {
                IBLHandler.setCubemapMaterial('C', value);
                viewer.modelManager.updateMaterialsValue('C', value);
                viewer.render();
            }
        );

        IBLFolder.add(IBLHandler, 'D', 0.0, 1.0).step(0.01).listen().onChange(
            function (value) {
                IBLHandler.setCubemapMaterial('D', value);
                viewer.modelManager.updateMaterialsValue('D', value);
                viewer.render();
            }
        );

        IBLFolder.add(IBLHandler, 'E', 0.0, 1.0).step(0.01).listen().onChange(
            function (value) {
                IBLHandler.setCubemapMaterial('E', value);
                viewer.modelManager.updateMaterialsValue('E', value);
                viewer.render();
            }
        );

        IBLFolder.add(IBLHandler, 'F', 0.0, 1.0).step(0.01).listen().onChange(
            function (value) {
                IBLHandler.setCubemapMaterial('F', value);
                viewer.modelManager.updateMaterialsValue('F', value);
                viewer.render();
            }
        );

        IBLFolder.add(IBLHandler, 'scale', 0.0, 1.0).step(0.000005).listen().onChange(
            function (value) {
                IBLHandler.setCubemapMaterial('scale', value);
                viewer.modelManager.updateMaterialsValue('scale', value);
                viewer.render();
            }
        );


        var clipPlanesFolder = gui.addFolder('ClipPlanes');
        clipPlanesFolder.add(clipPlanesHandler, 'EnableClipPlanes').name('Enable').listen()
            .onChange(
                function (value) {
                    clipPlanesHandler.clipPlaneService.toggle(value, clipPlanesHandler.VisibleClipPlanes);
                }
            );
        clipPlanesFolder.add(clipPlanesHandler, 'VisibleClipPlanes').name('Visible').listen()
            .onChange(
                function (value) {
                    clipPlanesHandler.clipPlaneService.setVisible(value);
                    viewer.render();
                }
            );
        clipPlanesFolder.add(clipPlanesHandler, 'RotatableClipPlanes').name('Rotatable').listen()
            .onChange(
                function (value) {
                    clipPlanesHandler.clipPlaneService.setRotatable(value);
                }
            );
        clipPlanesFolder.add(clipPlanesHandler, 'EnablePickClipPlanes').name('EnablePick').listen()
            .onChange(
                function (value) {
                    clipPlanesHandler.clipPlaneService.enablePick(value);
                }
            );
        clipPlanesFolder.add(clipPlanesHandler, 'clipPlanesStore');
        clipPlanesFolder.add(clipPlanesHandler, 'clipPlanesRestore');
        clipPlanesFolder.add(clipPlanesHandler, 'clipPlanesReset');
        clipPlanesFolder.add(clipPlanesHandler, 'face', 0, 5).step(1).listen().onChange(
            function (value) {
                if (value == 0) {
                    clipPlanesHandler.faceName = 'right';
                }
                else if (value == 1) {
                    clipPlanesHandler.faceName = 'left';
                }
                else if (value == 2) {
                    clipPlanesHandler.faceName = 'top';
                }
                else if (value == 3) {
                    clipPlanesHandler.faceName = 'bottom';
                }
                else if (value == 4) {
                    clipPlanesHandler.faceName = 'front';
                }
                else if (value == 5) {
                    clipPlanesHandler.faceName = 'back';
                }
            }
        );

        function getTool(name) {
            var tools = viewer.editorManager.tools;
            for (var i = 0; i < tools.length; i++) {
                if (tools[i].getName() == name) {
                    return tools[i];
                }
            }

            return null;
        }

        clipPlanesFolder.add(clipPlanesHandler, 'offset', -250, 250).step(10).listen().onChange(
            function (value) {
                var clipPlaneEditor = getTool(CLOUD.EditToolMode.CLIP_BY_BOX);
                clipPlaneEditor.moveSectionPlane(clipPlanesHandler.faceName, value);
                viewer.render();
            }
        );
        clipPlanesFolder.add(clipPlanesHandler, 'axis', 0, 2).step(1).listen().onChange(
            function (value) {
                if (value == 0) {
                    clipPlanesHandler.axisName = 'x';
                }
                else if (value == 1) {
                    clipPlanesHandler.axisName = 'y';
                }
                else if (value == 2) {
                    clipPlanesHandler.axisName = 'z';
                }
            }
        );
        clipPlanesFolder.add(clipPlanesHandler, 'rotate', -3.14, 3.14).step(0.1).listen().onChange(
            function (value) {
                var clipPlaneEditor = getTool(CLOUD.EditToolMode.CLIP_BY_BOX);
                clipPlaneEditor.rotateSectionBox(clipPlanesHandler.axisName, value);
                viewer.render();
            }
        );

        var fillClipPlaneFolder = gui.addFolder('FillClipPlane');
        fillClipPlaneFolder.add(fillClipPlaneHandler, 'EnableFillClipPlane').name('Enable').listen()
            .onChange(
                function (value) {
                    var fillClipPlaneEditor = getTool(CLOUD.EditToolMode.CLIP_FILL);
                    fillClipPlaneEditor.toggle(value, fillClipPlaneHandler.VisibleFillClipPlane);
                    viewer.render();
                }
            );
        fillClipPlaneFolder.add(fillClipPlaneHandler, 'VisibleFillClipPlane').name('Visible').listen()
            .onChange(
                function (value) {
                    var fillClipPlaneEditor = getTool(CLOUD.EditToolMode.CLIP_FILL);
                    fillClipPlaneEditor.visible(value);
                    viewer.render();
                }
            );
        fillClipPlaneFolder.add(fillClipPlaneHandler, 'RotatableFillClipPlane').name('Rotatable').listen()
            .onChange(
                function (value) {
                    var fillClipPlaneEditor = getTool(CLOUD.EditToolMode.CLIP_FILL);
                    fillClipPlaneEditor.rotatable(value);
                    viewer.render();
                }
            );
        fillClipPlaneFolder.add(fillClipPlaneHandler, 'RotY').name('RotY').listen()
            .onChange(
                function (value) {
                    var fillClipPlaneEditor = getTool(CLOUD.EditToolMode.CLIP_FILL);
                    fillClipPlaneEditor.rotX = !value;
                    viewer.render();
                }
            );
        fillClipPlaneFolder.add(fillClipPlaneHandler, 'offset', -500, 500).step(10).listen().onChange(
            function (value) {
                var fillClipPlaneEditor = getTool(CLOUD.EditToolMode.CLIP_FILL);
                fillClipPlaneEditor.setOffset(value);
                viewer.render();
            }
        );
        fillClipPlaneFolder.add(fillClipPlaneHandler, 'normal', 0, 5).step(1).listen().onChange(
            function (value) {
                var fillClipPlaneEditor = getTool(CLOUD.EditToolMode.CLIP_FILL);
                fillClipPlaneEditor.changeNormal(value);
                viewer.render();
            }
        );

        var sceneFolder = gui.addFolder('Scene');
        for (var i = 0, len = sceneHandler.names.length; i < len; ++i) {
            sceneFolder.add(sceneHandler, sceneHandler.names[i]);
        }

        var filterFolder = gui.addFolder('Filters');
        for (var i = 0, len = filterHandler.names.length; i < len; ++i) {
            filterFolder.add(filterHandler, filterHandler.names[i]);
        }

        var movementFolder = gui.addFolder('Movement');
        for (var i = 0, len = movementHandler.names.length; i < len; ++i) {
            movementFolder.add(movementHandler, movementHandler.names[i]);
        }

        movementFolder.add(movementHandler, 'speedRate', 0.01, 10.0).step(0.1).listen().onChange(
            function (value) {

                movementHandler.speedRate = value;
                movementHandler.setMovementSpeedRate(value);
            }
        );

        var performanceFolder = gui.addFolder('performance');
        performanceFolder.add(performanceHandler, 'isShowOctantBox').name('show octant box').listen().onChange(
            function (value) {
                CLOUD.GlobalData.ShowOctant = value;
                viewer.render();
            }
        );
        performanceFolder.add(performanceHandler, 'octantDepth', 0, 20).step(1).name('OctantDepth').listen().onChange(
            function (value) {
                viewer.setOctantDepth(value);
                viewer.render();
            }
        );
        performanceFolder.add(performanceHandler, 'autoUpdate').name('auto update').listen().onChange(
            function (value) {
                if (value) {
                    stats.domElement.style.display = '';
                    performanceHandler.animate();
                } else {
                    stats.domElement.style.display = 'none';
                    performanceHandler.stopAnimate();
                }
            }
        );
        performanceFolder.add(performanceHandler, 'autoRotateSpeed', 1, 20).step(1).name('autoRotateSpeed').listen().onChange(
            function (value) {
                if (viewer.cameraControl) {
                    viewer.cameraControl.autoRotateSpeed = value;
                }
            }
        );
        performanceFolder.add(performanceHandler, 'objectPoolSize', 10000, 400000).step(10000).name('objectPoolSize').listen().onChange(
            function (value) {
                viewer.resizePool(value);
                viewer.render();
            }
        );


        var occlusionTranslucentFolder = gui.addFolder('occlusion');


        occlusionTranslucentFolder.add(occlusionTranslucentHandler, 'enabled').name('enabled').listen().onChange(
            function (value) {
                occlusionTranslucentHandler.enableOcclusionTranslucent(value);
                viewer.render();
            }
        );

        occlusionTranslucentFolder.add(occlusionTranslucentHandler, 'opacity', 0.0, 1.0).step(0.1).name('opacity').listen().onChange(
            function (value) {
                occlusionTranslucentHandler.setOcclusionOpacity(value);
                viewer.render();
            }
        );

        occlusionTranslucentFolder.add(occlusionTranslucentHandler, 'distance', 1, 5000.0).step(100).name('distance').listen().onChange(
            function (value) {
                occlusionTranslucentHandler.setOcclusionDistanceToCamera(value);
                viewer.render();
            }
        );

        var testFolder = gui.addFolder('Test');
        for (var i = 0, len = testHandler.names.length; i < len; ++i) {
            testFolder.add(testHandler, testHandler.names[i]);
        }

        var walkFolder = gui.addFolder('Walk');

        walkFolder.add(walkHandler, 'setWalk');

        // walkFolder.add(walkHandler, 'height', 0, 2000.0).step(100).name('height').listen().onChange(
        //     function (value) {
        //         walkHandler.setRoamingWalkHeight(value);
        //     }
        // );
        //
        // walkFolder.add(walkHandler, 'heightForAbsolute', -10000, 10000.0).step(1000).name('heightForAbsolute').listen().onChange(
        //     function (value) {
        //         walkHandler.setRoamingWalkAbsoluteHeight(value);
        //     }
        // );

        walkFolder.add(walkHandler, 'isLockHeight').name('lock').listen().onChange(
            function (value) {
                walkHandler.setWalkHeightLocked(value);
                viewer.render();
            }
        );

        walkFolder.add(walkHandler, 'isLookMousePressed').name('MousePressed').listen().onChange(
            function (value) {
                walkHandler.setWalkLookMousePressed(value);
                // viewer.render();
            }
        );
        walkFolder.add(walkHandler, 'isWorkingWithGravity').name('Gravity').listen().onChange(
            function (value) {
                walkHandler.setWalkingWithGravity(value);
                // viewer.render();
            }
        );
        walkFolder.add(walkHandler, 'speedRate', 0, 4).step(0.1).name('speed Rate').listen().onChange(
            function (value) {
                walkHandler.setWalkSpeedRate(value);
            }
        );

        var markerFolder = gui.addFolder('Marker3D');
        for (var i = 0, len = markerHandler.names.length; i < len; ++i) {
            markerFolder.add(markerHandler, markerHandler.names[i]);
        }

        // 移除css样式
        function removeCssOfPropertyName() {

            var textList = [];
            var i, j, len, len2;

            for (i = 0, len = viewHandler.names.length; i < len; ++i) {
                textList.push(viewHandler.names[i]);
            }

            for (i = 0, len = editorHandler.names.length; i < len; ++i) {
                textList.push(editorHandler.names[i]);
            }

            for (i = 0, len = zoomHandler.names.length; i < len; ++i) {
                textList.push(zoomHandler.names[i]);
            }

            for (i = 0, len = clipPlanesHandler.names.length; i < len; ++i) {
                textList.push(clipPlanesHandler.names[i]);
            }

            for (i = 0, len = filterHandler.names.length; i < len; ++i) {
                textList.push(filterHandler.names[i]);
            }

            for (i = 0, len = sceneHandler.names.length; i < len; ++i) {
                textList.push(sceneHandler.names[i]);
            }

            for (i = 0, len = testHandler.names.length; i < len; ++i) {
                textList.push(testHandler.names[i]);
            }

            for (i = 0, len = markerHandler.names.length; i < len; ++i) {
                textList.push(markerHandler.names[i]);
            }

            var propertyName = document.querySelectorAll(".property-name");

            for (i = 0, len = propertyName.length; i < len; ++i) {

                for (j = 0, len2 = textList.length; j < len2; ++j) {

                    if (propertyName[i].innerHTML === textList[j]) {
                        propertyName[i].className = "";
                    }
                }

            }

        }

        removeCssOfPropertyName();

    };

    this.show = function (bShow) {
        gui.closed = !bShow;
    };
};


