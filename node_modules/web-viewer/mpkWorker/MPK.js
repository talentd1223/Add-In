/**
 * @author muwj 2016/12/15
 * @editor xiaoj 2017/03/24  remove THREE.Vector dependency for web worker usage
 */
var MPK = MPK || {};

MPK.MPKHeader = function( buffer ) {

    var header = new Uint32Array( buffer, 0, 6 );

    this.blockId      = header[0];
    this.vtFormat     = header[1];
    this.meshCount    = header[2];
    this.meshOffset   = header[3];
    this.bufferSize   = header[4];
    this.bufferOffset = header[5];

    header = null;
};

MPK.MeshData = function( buffer, offset ) {

    var mesh_info = new Uint32Array( buffer, offset, 5 );

    this.mesh_id      = mesh_info[0];
    this.ptCount      = mesh_info[1];
    this.idxCount     = mesh_info[2];
    this.dataOffset   = mesh_info[3];
    this.vertexFormat = mesh_info[4];

    var base_info = new Float32Array( buffer, offset + 4 * 5, 4 );

    this.baseScale = base_info[0];
    this.baseX = base_info[1];
    this.baseY = base_info[2];
    this.baseZ = base_info[3];

    mesh_info = null;
    base_info = null;
};

MPK.MPKReader = function( buffer ) {

    this.header = new MPK.MPKHeader( buffer );

    this.meshSize = 4 * 9;
    this.maxSize  = 4 * 64;
    this.meshBuffer = buffer.slice( this.header.meshOffset,   this.header.meshOffset   + this.header.meshCount * this.meshSize );
    this.geomBuffer = buffer.slice( this.header.bufferOffset, this.header.bufferOffset + this.header.bufferSize );

    // for data reading
    this.mesh_cur_id = -1;
    var tmp_buffer = new ArrayBuffer( this.maxSize );
    this.mesh_cur = new MPK.MeshData( tmp_buffer, 0 );
};

MPK.MPKReader.prototype = {

    constructor: MPK.MPKReader,

    getMeshData: function( index ) {

        if( index >= 0 && index < this.header.meshCount ) {

            return new MPK.MeshData( this.meshBuffer, index * this.meshSize );
        }
    },

    getMeshInfo: function( index ) {

        if( index == this.mesh_cur_id ) {
            return this.mesh_cur;
        }

        if( index >= 0 && index < this.header.meshCount ) {

            var data_i = new Uint32Array( this.meshBuffer, index * this.meshSize, 5 );
            this.mesh_cur.mesh_id      = data_i[0];
            this.mesh_cur.ptCount      = data_i[1];
            this.mesh_cur.idxCount     = data_i[2];
            this.mesh_cur.dataOffset   = data_i[3];
            this.mesh_cur.vertexFormat = data_i[4];

            var data_f = new Float32Array( this.meshBuffer, index * this.meshSize + 4 * 5, 4 );
            this.mesh_cur.baseScale = data_f[0];

            //this.mesh_cur.baseVector.set(data_f[1], data_f[2], data_f[3]);
            this.mesh_cur.baseX = data_f[1];
            this.mesh_cur.baseY = data_f[2];
            this.mesh_cur.baseZ = data_f[3];

            this.mesh_cur_id = index;
            return this.mesh_cur;
        }
    },

    getPtBuffer: function( index ) {

        if( index >= 0 && index < this.header.meshCount ) {

            var mesh = this.getMeshInfo( index );
            if( mesh === undefined ) {
                return undefined;
            }

            if( mesh.baseScale == 0.0 ) {
                return new Float32Array( this.geomBuffer, mesh.dataOffset, mesh.ptCount * 3 );
            }
            else {
                return new Uint16Array( this.geomBuffer, mesh.dataOffset, mesh.ptCount * 3 );
            }
        }
    },

    getIdxBuffer: function ( index ) {

        if( index >= 0 && index < this.header.meshCount ) {

            var mesh = this.getMeshInfo( index );
            if( mesh === undefined ) {
                return undefined;
            }

            var offset = mesh.dataOffset;
            if( mesh.baseScale == 0.0 ) {
                offset += mesh.ptCount * 3 * 4;
            }
            else {
                offset += mesh.ptCount * 3 * 2;
                if( mesh.ptCount % 2 == 1 ) {
                    offset += 2;
                }
            }

            if( mesh.ptCount > 65535 ) {
                return new Uint32Array( this.geomBuffer, offset, mesh.idxCount );
            }
            else {
                return new Uint16Array( this.geomBuffer, offset, mesh.idxCount );
            }
        }
    },

    getNormalBuffer: function( index ) {

        if( ( this.header.vtFormat & 2 ) == 2 &&
            index >= 0 &&
            index < this.header.meshCount ) {

            var mesh = this.getMeshInfo( index );
            if( mesh === undefined ) {
                return undefined;
            }

            var offset = mesh.dataOffset;
            if( mesh.baseScale == 0.0 ) {
                offset += mesh.ptCount * 3 * 4;
            }
            else {
                offset += mesh.ptCount * 3 * 2;
                if( mesh.ptCount % 2 == 1 ) {
                    offset += 2;
                }
            }

            if( mesh.ptCount > 65535 ) {
                offset += mesh.idxCount * 4;
            }
            else {
                offset += mesh.idxCount * 2;
                if( mesh.idxCount % 2 == 1 ) {
                    offset += 2;
                }
            }

            return new Float32Array( this.geomBuffer, offset, mesh.ptCount * 3 );
        }
    },

    getUVBuffer: function( index ) {

        if( index >= 0 && index < this.header.meshCount ) {

            var mesh = this.getMeshInfo( index );
            if( mesh === undefined || (mesh.vertexFormat & 4) != 4 ) {
                return undefined;
            }

            var offset = mesh.dataOffset;
            if( mesh.baseScale == 0.0 ) {
                offset += mesh.ptCount * 3 * 4;
            }
            else {
                offset += mesh.ptCount * 3 * 2;
                if( mesh.ptCount % 2 == 1 ) {
                    offset += 2;
                }
            }

            if( mesh.ptCount > 65535 ) {
                offset += mesh.idxCount * 4;
            }
            else {
                offset += mesh.idxCount * 2;
                if( mesh.idxCount % 2 == 1 ) {
                    offset += 2;
                }
            }

            if( (this.header.vtFormat & 2) == 2 ) {
                offset += mesh.ptCount * 3 * 4;
            }

            return new Float32Array( this.geomBuffer, offset, mesh.ptCount * 2 );
        }
    }
};