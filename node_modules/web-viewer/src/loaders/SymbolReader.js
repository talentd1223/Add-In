/**
 * @author muwj 2016/12/29
 */

CLOUD.Loader.SymbolHeader = function ( buffer ) {

    var header = new Uint32Array( buffer, 0, 9 );

    this.blockId        = header[0];
    this.symbolCount    = header[1];
    this.itemCount      = header[2];
    this.matrixCount    = header[3];
    this.geomBuffSize   = header[4];
    this.symbolOffset   = header[5];
    this.itemOffset     = header[6];
    this.matrixOffset   = header[7];
    this.geomOffset     = header[8];

    var bbox = new Float32Array( buffer, 4 * 9, 6 );
    this.boundingBox = new THREE.Box3(
        new THREE.Vector3( bbox[0], bbox[1], bbox[2] ),
        new THREE.Vector3( bbox[3], bbox[4], bbox[5] ) );

    header = null;
    bbox = null;
};

CLOUD.Loader.Symbol = function ( buffer, offset ) {

    var item_i = new Int32Array( buffer, offset, 3 );

    this.symbolId  = item_i[0];
    this.itemIndex = item_i[1];
    this.itemCount = item_i[2];

    var bbox = new Float32Array( buffer, offset + 4 * 3, 6 );
    this.boundingBox = new THREE.Box3(
        new THREE.Vector3( bbox[0], bbox[1], bbox[2] ),
        new THREE.Vector3( bbox[3], bbox[4], bbox[5] ) );

    item_i = null;
    bbox = null;
};

CLOUD.Loader.SymbolReader = function ( buffer ) {

    this.header = new CLOUD.Loader.SymbolHeader( buffer );

    this.symbolSize   = 4 * 9;
    this.itemSize     = 4 * 13;
    this.matrixSize   = 4 * 16;
    this.geomSize     = 4 * 8;
    this.maxSize      = 4 * 64;
    this.boxUvSize  = 36;
    this.pipeUvSize = 18;

    this.symbolBuffer = buffer.slice( this.header.symbolOffset, this.header.symbolOffset + this.header.symbolCount * this.symbolSize );
    this.itemBuffer   = buffer.slice( this.header.itemOffset,   this.header.itemOffset   + this.header.itemCount   * this.itemSize );
    this.matrixBuffer = buffer.slice( this.header.matrixOffset, this.header.matrixOffset + this.header.matrixCount * this.matrixSize );
    this.geomBuffer   = buffer.slice( this.header.geomOffset,   this.header.geomOffset   + this.header.geomBuffSize );

    // for data reading
    this.matr_cur_id = -1;

    this.pt_symb_min = new THREE.Vector3( 0.0, 0.0, 0.0 );
    this.pt_symb_max = new THREE.Vector3( 0.0, 0.0, 0.0 );
    this.pt_item_min = new THREE.Vector3( 0.0, 0.0, 0.0 );
    this.pt_item_max = new THREE.Vector3( 0.0, 0.0, 0.0 );

    var tmp_buffer = new ArrayBuffer( this.maxSize );
    this.symb_cur = new CLOUD.Loader.Symbol( tmp_buffer, 0 );
    this.item_cur = new CLOUD.Loader.Item( tmp_buffer, 0 );
    this.matr_cur = new CLOUD.Loader.Matrix( tmp_buffer, 0 );
    this.pipe_cur = new CLOUD.Loader.GeomPipe( tmp_buffer, 0 );

    this.symb_cur.boundingBox.set( this.pt_symb_min, this.pt_symb_max );
    this.item_cur.boundingBox.set( this.pt_item_min, this.pt_item_max );
};

CLOUD.Loader.SymbolReader.prototype = {

    constructor: CLOUD.Loader.SymbolReader,

    getSymbol: function ( index ) {

        if ( index >= 0 && index < this.header.symbolCount ) {
            return new CLOUD.Loader.Symbol( this.symbolBuffer, index * this.symbolSize );
        }
    },

    getItem: function ( index ) {

        if ( index >= 0 && index < this.header.itemCount ) {
            return new CLOUD.Loader.Item( this.itemBuffer, index * this.itemSize );
        }
    },

    getMatrix: function ( index ) {

        if ( index >= 0 && index < this.header.matrixCount ) {
            return new CLOUD.Loader.Matrix( this.matrixBuffer, index * this.matrixSize );
        }
    },

    getGeomPipe: function ( offset ) {

        if ( offset >= 0 && index < this.header.geomBuffSize ) {
            return new CLOUD.Loader.GeomPipe( this.geomBuffer, offset );
        }
    },

    getSymbolInfo: function ( index ) {

        if ( index >= 0 && index < this.header.symbolCount ) {

            var item_i = new Int32Array( this.symbolBuffer, index * this.symbolSize, 3 );
            this.symb_cur.symbolId  = item_i[0];
            this.symb_cur.itemIndex = item_i[1];
            this.symb_cur.itemCount = item_i[2];

            var data_f = new Float32Array( this.symbolBuffer, index * this.symbolSize + 4 * 3, 6 );
            this.pt_symb_min.set( data_f[0], data_f[1], data_f[2] );
            this.pt_symb_max.set( data_f[3], data_f[4], data_f[5] );
            this.symb_cur.boundingBox.set( this.pt_symb_min, this.pt_symb_max );

            return this.symb_cur;
        }
    },

    getItemInfo: function ( index ) {

        if ( index >= 0 && index < this.header.itemCount ) {

            var data_i = new Int32Array( this.itemBuffer, index * this.itemSize, 7 );
            this.item_cur.ItemId     = data_i[0];
            this.item_cur.originalId = data_i[1];
            this.item_cur.materialId = data_i[2];
            this.item_cur.userDataId = data_i[3];
            this.item_cur.matrixId   = data_i[4];
            this.item_cur.type       = data_i[5];
            this.item_cur.toData     = data_i[6];

            var data_f = new Float32Array( this.itemBuffer, index * this.itemSize + 4 * 7, 6 );
            this.pt_item_min.set( data_f[0], data_f[1], data_f[2] );
            this.pt_item_max.set( data_f[3], data_f[4], data_f[5] );
            this.item_cur.boundingBox.set( this.pt_item_min, this.pt_item_max );

            return this.item_cur;
        }
    },

    getMatrixInfo: function ( index ) {

        if ( index == this.matr_cur_id ) {
            return this.matr_cur;
        }

        if ( index >= 0 && index < this.header.matrixCount ) {

            var data = new Float32Array( this.matrixBuffer, index * this.matrixSize, 4 * 4 );
            this.matr_cur.matrix.fromArray( data );

            this.matr_cur_id = index;
            return this.matr_cur;
        }
    },

    getGeomPipeInfo: function ( offset ) {

        if ( offset >= 0 && offset < this.header.geomBuffSize ) {

            var data = new Float32Array( this.geomBuffer, offset, 8 );

            this.pipe_cur.startPt.set( data[0], data[1], data[2] );
            this.pipe_cur.endPt.  set( data[3], data[4], data[5] );
            this.pipe_cur.radius    = data[6];
            this.pipe_cur.thickness = data[7];

            return this.pipe_cur;
        }
    },

    getGeomBoxUvInfo: function ( offset ) {

        if ( offset >= 0 && (offset + this.boxUvSize * 4) <= this.header.geomBuffSize ) {

            return new Float32Array( this.geomBuffer, offset, this.boxUvSize );
        }
    },

    getGeomPipeUvInfo: function ( offset ) {

        if ( offset >= 0 && (offset + this.pipeUvSize * 4) <= this.header.geomBuffSize ) {

            return new Float32Array( this.geomBuffer, offset, this.pipeUvSize );
        }
    },

    getMpkID: function ( mesh_id ) {

        return parseInt( mesh_id / 65536 );
    },

    getMeshIndex: function ( mesh_id ) {

        return parseInt( mesh_id % 65536 );
    }
};