// parameters = {serverUrl: xxx, databagId:xxx}
CLOUD.Loader.ModelLoader = function (model, parameters, debut) {

    THREE.LoadingManager.call(this);

    this.model = model;
    this.taskManager = new CLOUD.TaskManager(this);
    this.url = new CLOUD.Loader.Url(parameters.serverUrl, parameters.databagId);
    this.loader = new THREE.FileLoader(this);
    this.loadTaskCount = 0;
    this.maxLoadTaskCount = 0;   // TODO: change the way to flag resource loading finish flag.
    this.octreeRootNode = null;
    this.octreeRootNodeI = null;
    this.symbolReader = null;
    this.userIdReader = null;
    this.userDataReader = null;
    this.sceneReaderArray = null;
    this.layerReader = null;
    this.debut = debut;

    this.loadTextureCount = 0;
    this.maxLoadTextureCount = 0;
    this._textruesLoaded = false;
    this._dataLoaded = false;

};

CLOUD.Loader.ModelLoader.prototype = Object.create(THREE.LoadingManager.prototype);
CLOUD.Loader.ModelLoader.prototype.constructor = CLOUD.Loader.ModelLoader;

CLOUD.Loader.ModelLoader.prototype._onTaskFinished = function () {

    var model = this.model;
    this.loadTaskCount++;

    var loadCount = this.loadTaskCount;
    if (CLOUD.GlobalData.BatchMergeEnabled) {
        loadCount *= model.progressPercentage.load;
    }

    if (this.notifyProgress) {
        var progress = {
            total: this.maxLoadTaskCount,
            loaded: loadCount
        };
        model.dispatchEvent({type: CLOUD.EVENTS.ON_LOAD_PROGRESS, progress: progress});
    }

    if (this.loadTaskCount >= this.maxLoadTaskCount) {
        this._dataLoaded = true;
        if (this._textruesLoaded) {
            this._dataLoadFinished();
        }
    }
};

CLOUD.Loader.ModelLoader.prototype._onLoadTexture = function () {

    this.loadTextureCount++;

    if (this.loadTextureCount >= this.maxLoadTextureCount) {
        this._textruesLoaded = true;
        if (this._dataLoaded) {
            this._dataLoadFinished();
        }
    }
};

CLOUD.Loader.ModelLoader.prototype._dataLoadFinished = function () {
    var model = this.model;
    var scene = this.model.manager.scene;

    if (CLOUD.GlobalData.IBL && scene.iblProbe != null && scene.iblProbe.isComputed) {
        this.model.updateMaterials();
        var IBLcfg = scene.IBLcfg;
        var keys = Object.keys(IBLcfg);
        var uniforms = IBLcfg[keys[scene.IBLIndex]];

        for (var id in uniforms) {
            this.model.updateMaterialsValue(id, uniforms[id]);
        }
    }

    if (CLOUD.GlobalData.BatchMergeEnabled) {
        var scope = this;
        model._prepareData(function () {
            model.loaded = true;
            // Trigger off first frame render
            if (scope.debut !== undefined) {
                scope.debut();
            }
        });
    } else {
        model.loaded = true;
        model.dispatchEvent({type: CLOUD.EVENTS.ON_LOAD_COMPLETE});
        // Trigger off first frame render
        if (this.debut !== undefined) {
            this.debut();
        }
    }

}

CLOUD.Loader.ModelLoader.prototype._loadScene = function (loader, url, sceneId) {
    var scope = this;
    loader.setResponseType("arraybuffer");
    loader.load(url.sceneUrl(sceneId), function (data) {
        var sceneReader = new CLOUD.Loader.SceneReader(data);
        var blockId = sceneReader.header.blockId;
        if (blockId < scope.sceneCount) {
            scope.sceneReaderArray[blockId] = sceneReader;
        }
        sceneReader = null;
        // scope.model.dispatchEvent({type: CLOUD.EVENTS.ON_LOAD_START, sceneId: sceneId});
        scope._onTaskFinished();
    }, undefined, function (event) {
        scope.model.dispatchEvent({
            type: CLOUD.LOADERROREVENTS.LOAD_ERROR,
            errorType: CLOUD.LOADERROREVENTS.LOAD_SCENE_ERROR,
            event: event
        });
        scope._onTaskFinished();
    });
};

CLOUD.Loader.ModelLoader.prototype._loadMaterial = function (loader, url) {

    var scope = this;

    loader.setResponseType("arraybuffer");
    loader.load(url.materialUrl(), function (data) {

        scope._parseMaterial(data, url);
        scope._onTaskFinished();

    }, undefined, function (event) {

        scope.model.dispatchEvent({
            type: CLOUD.LOADERROREVENTS.LOAD_ERROR,
            errorType: CLOUD.LOADERROREVENTS.LOAD_MATERIAL_ERROR,
            event: event
        });
        scope._onTaskFinished();

    });

};

CLOUD.Loader.ModelLoader.prototype._loadMaterialJson = function (loader, url) {

    var scope = this;

    loader.setResponseType("");
    loader.load(url.materialUrl(), function (data) {

        scope._parseMaterialJson(data, url);
        scope._onTaskFinished();

    }, undefined, function (event) {

        scope.model.dispatchEvent({
            type: CLOUD.LOADERROREVENTS.LOAD_ERROR,
            errorType: CLOUD.LOADERROREVENTS.LOAD_MATERIAL_ERROR,
            event: event
        });
        scope._onTaskFinished();

    });
};

CLOUD.Loader.ModelLoader.prototype._loadSymbol = function (loader, url) {

    var scope = this;
    // TODO: maxLoadTaskCount should not be assigned with hard code at initialization (5).
    loader.setResponseType("arraybuffer");
    loader.load(url.symbolUrl(), function (data) {

        scope.symbolReader = new CLOUD.Loader.SymbolReader(data);
        scope._onTaskFinished();

    }, undefined, function (event) {

        scope.model.dispatchEvent({
            type: CLOUD.LOADERROREVENTS.LOAD_ERROR,
            errorType: CLOUD.LOADERROREVENTS.LOAD_SYMBOL_ERROR,
            event: event
        });
        scope._onTaskFinished();

    });

};

CLOUD.Loader.ModelLoader.prototype._loadOctreeInner = function (loader, url, matrixRoot) {

    var scope = this;

    // load spatial index
    loader.setResponseType("arraybuffer");
    loader.load(url.octreeUrl('i'), function (data) {

        scope._parseOctree(data, matrixRoot, true);
        scope._onTaskFinished();

    }, undefined, function (event) {

        scope.model.dispatchEvent({
            type: CLOUD.LOADERROREVENTS.LOAD_ERROR,
            errorType: CLOUD.LOADERROREVENTS.LOAD_OCTREEINNER_ERROR,
            event: event
        });
        scope._onTaskFinished();

    });

};

CLOUD.Loader.ModelLoader.prototype._loadOctreeOuter = function (loader, url, matrixInv) {

    var scope = this;

    // load spatial index
    loader.setResponseType("arraybuffer");
    loader.load(url.octreeUrl('o'), function (data) {

        scope._parseOctree(data, matrixInv, false);
        scope._onTaskFinished();

    }, undefined, function (event) {

        scope.model.dispatchEvent({
            type: CLOUD.LOADERROREVENTS.LOAD_ERROR,
            errorType: CLOUD.LOADERROREVENTS.LOAD_OCTREEOUTER_ERROR,
            event: event
        });
        scope._onTaskFinished();

    });

};

CLOUD.Loader.ModelLoader.prototype._loadUserId = function (loader, url) {

    var scope = this;

    loader.setResponseType("arraybuffer");
    loader.load(url.userIdUrl(), function (data) {

        scope.userIdReader = new CLOUD.Loader.IdReader(data);
        scope._onTaskFinished();

    }, undefined, function (event) {

        scope.model.dispatchEvent({
            type: CLOUD.LOADERROREVENTS.LOAD_ERROR,
            errorType: CLOUD.LOADERROREVENTS.LOAD_USERID_ERROR,
            event: event
        });
        scope._onTaskFinished();

    });

};

CLOUD.Loader.ModelLoader.prototype._loadUserData = function (loader, url) {

    var scope = this;

    loader.setResponseType("");
    loader.load(url.userDataUrl(), function (data) {

        scope.userDataReader = new CLOUD.Loader.UserDataReader(data);
        scope._onTaskFinished();

    }, undefined, function (event) {

        scope.model.dispatchEvent({
            type: CLOUD.LOADERROREVENTS.LOAD_ERROR,
            errorType: CLOUD.LOADERROREVENTS.LOAD_USERDATA_ERROR,
            event: event
        });
        scope._onTaskFinished();

    });

};

CLOUD.Loader.ModelLoader.prototype._loadLayer = function (loader, url, callback) {
    var scope = this;
    loader.setResponseType("arraybuffer");
    loader.load(url.layerUrl(), function (data) {
        var layerReader = scope.layerReader = new CLOUD.Loader.LayerReader(data);
        var count = layerReader.getLayerCount();
        var i, j, len;
        for (i = 0; i < count; ++i) {
            var mpkIdxs = [];
            var key = layerReader.getKeyString(i);
            var layerData = layerReader.getLayerData(key);
            var idxList = layerReader.getMpkList(key);
            for (j = 0, len = idxList.length; j < len; ++j) {
                mpkIdxs.push(idxList[j]);
            }
            scope.model._cacheLayerData(key,{boundingBox: layerData.boundingBox, mpkIdxs: mpkIdxs});
        }

        callback && callback();

    }, undefined, function (event) {

        scope.model.dispatchEvent({
            type: CLOUD.LOADERROREVENTS.LOAD_ERROR,
            errorType: CLOUD.LOADERROREVENTS.LOAD_MPK_ERROR,
            event: event
        });
        scope._onTaskFinished();

    });
};

CLOUD.Loader.ModelLoader.prototype._loadCamera = function (loader, url, matrixRoot) {

    var scope = this;

    loader.setResponseType("");
    loader.load(url.cameraUrl(), function (data) {

        var cameraReader = new CLOUD.Loader.CameraReader(data);
        cameraReader.parse(scope.model, matrixRoot);
        scope._onTaskFinished();

    }, undefined, function (event) {

        scope.model.dispatchEvent({
            type: CLOUD.LOADERROREVENTS.LOAD_ERROR,
            errorType: CLOUD.LOADERROREVENTS.LOAD_CAMERA_ERROR,
            event: event
        });
        scope._onTaskFinished();

    });

};

CLOUD.Loader.ModelLoader.prototype._loadTexture = function (url, onLoad, onProgress, onError) {

    var texture;
    var loader = THREE.Loader.Handlers.get(url);
    var manager = this;

    if (loader !== null) {

        texture = loader.load(url, onLoad);

    } else {

        texture = new THREE.Texture();

        loader = new THREE.ImageLoader(manager);
        loader.setCrossOrigin("anonymous");
        loader.load(url, function (image) {

            texture.image = CLOUD.MaterialUtil.ensurePowerOfTwo(image);
            texture.needsUpdate = true;

            if (onLoad) onLoad(texture);

        }, onProgress, function (event) {

            if (onError !== undefined) onError(event);
            manager.model.dispatchEvent({
                type: CLOUD.LOADERROREVENTS.LOAD_ERROR,
                errorType: CLOUD.LOADERROREVENTS.LOAD_TEXTURE_ERROR,
                event: event
            });

        });

    }

    return texture;
};

CLOUD.Loader.ModelLoader.prototype._loadMpks = function (loader, url, count) {

    // Add MPKs to task manager
    var taskManager = this.taskManager;

    for (var i = 0; i < count; ++i) {
        taskManager.addMpkTask(i);
    }

    taskManager.processMpkTasks();
};

CLOUD.Loader.ModelLoader.prototype._parseMpk = function (data) {

    var referencedMeshCache = this.model.getReferencedMeshCache();
    // BIMFACEDM-3650: 'MPK.MPKReader' is a copy from
    // 'CLOUD.Loader.MPKReader(data) for 'mpkWorker' only,
    // but 'mpkWorker' is not effective yet.
    // TODO: make 'CLOUD.Loader.MPKReader' and 'MPK.MPKReader' one copy.
    //var reader = new MPK.MPKReader(data);
    var reader = new CLOUD.Loader.MPKReader(data);
    var count = reader.header.meshCount;

    for (var i = 0; i < count; ++i) {

        var position = reader.getPtBuffer(i);
        var index = reader.getIdxBuffer(i);
        var normal = reader.getNormalBuffer(i);
        var mesh = reader.getMeshData(i);
        var uv = reader.getUVBuffer(i);

        if (position == undefined || index == undefined || normal == undefined) {
            CLOUD.Logger.log("Error Geometry!");
            continue;
        }

        var id = mesh.mesh_id;

        referencedMeshCache[id] = {
            P: position,  // position
            I: index,  // index
            N: normal,  // normal
            M: mesh,   // mesh info
            UV: uv
        };
    }
    reader = null; // 释放 MPKReader
};

CLOUD.Loader.ModelLoader.prototype._parseMaterial = function (data, url) {

    var materials = this.model.getMaterials();
    var textures = this.model.getTextures();
    var reader = new CLOUD.Loader.MaterialReader(data);
    var len = reader.materialCount;
    var scope = this;
    var i;
    var textureDataArray = [];

    if (len < 0) {
        return;
    }

    var scene = this.model.manager.scene;

    for (i = 0; i < len; ++i) {

        var materialParameters = {};
        var materialData = reader.getMaterial(i);

        if (materialData.color !== undefined) {
            materialParameters.color = materialData.color;
        }

        if (materialData.opacity !== undefined) {
            materialParameters.opacity = materialData.opacity;

            if (materialData.opacity < 1.0) {
                materialParameters.transparent = true;
            }
        }

        if (materialData.side !== undefined && materialData.side) {
            materialParameters.side = THREE.DoubleSide;
        }

        if (materialData.emissive !== undefined) {
            materialParameters.emissive = materialData.emissive;
        }

        if (materialData.environment !== undefined) {
            materialParameters.envMapIntensity = materialData.environment;
        }

        if (materialData.roughness !== undefined) {
            materialParameters.roughness = materialData.roughness;
            materialParameters.originRoughness = materialData.roughness;
        }

        if (materialData.metalness !== undefined) {
            materialParameters.metalness = materialData.metalness;
            materialParameters.originMetalness = materialData.metalness;
        }

        var material;
        if (CLOUD.GlobalData.IBL) {
            materialParameters.iblProbe = scene.iblProbe;
            material = new ImageBasedLighting.IBLMaterial(materialParameters);
            material.type = 'IBL';
        }
        else {
            material = CLOUD.MaterialUtil.createStandardMaterial(materialParameters);
        }

        CLOUD.IdTargetUtil.addIdBufferFlagToMaterial(material);

        material.name = i;
        materials[i] = material;
        materialParameters = null;

        if( CLOUD.GlobalData.EnableTextureLoading )
        {
            var textureCount = materialData.texture_n;
            var textureData = null; // remark: 这里定义textureData后，一定要赋null值，否则textureData会保留上一次的值。
    
            if (textureCount > 0) {
                textureData = reader.getTexture(materialData.texture_id[0]);
            }
    
            if (textureData) {
                textureDataArray.push({id: i, data: textureData});
            }

        }
    }

    if (textureDataArray.length > 0) {
        len = this.maxLoadTextureCount = textureDataArray.length;
        for (i = 0; i < len; i++) {
            var id = textureDataArray[i].id;
            var textureData = textureDataArray[i].data;
            var textureId = textureData.id + textureData.file_name_ext;
            var texture = this._loadTexture(url.textureUrl(textureId), function () {
                scope._onLoadTexture();
            }, undefined, function () {
                scope._onLoadTexture();
            });

            texture.repeat.fromArray([textureData.scale_u, textureData.scale_v]);
            texture.offset.fromArray([textureData.offset_u, textureData.offset_v]);

            if (texture.setRotateAngle) {
                texture.setRotateAngle(textureData.angle);
            }

            if (textureData.repeat_u) {
                texture.wrapS = THREE.RepeatWrapping;
            }

            if (textureData.repeat_v) {
                texture.wrapT = THREE.RepeatWrapping;
            }

            //materialParameters.map = texture;
            //在model.js的_updateTextureMapping函数中绑定到材质
            if (texture) {
                textures[id] = texture;
            }
        }

        textureDataArray = null;
    } else {
        scope._onLoadTexture();
    }

    reader = null; // 释放 MaterialReader
};

CLOUD.Loader.ModelLoader.prototype._parseMaterialJson = function (data, url) {

    var materials = this.model.getMaterials();
    var textures = this.model.getTextures();
    var reader = new CLOUD.Loader.MaterialReaderJson(data);
    var len = reader.count;
    var scope = this;
    var i;
    var textureDataArray = [];

    if (len < 0) {
        return;
    }

    var scene = this.model.manager.scene;

    for (i = 0; i < len; ++i) {

        var materialParameters = {};
        var wholeMaterial = reader.getMaterial(i);
        var materialData = wholeMaterial.parameters;

        if (materialData.color !== undefined) {
            materialParameters.color = materialData.color;
        }

        if (materialData.opacity !== undefined) {
            materialParameters.opacity = materialData.opacity;

            if (materialData.opacity < 1.0) {
                materialParameters.transparent = true;
            }
        }

        if (materialData.side !== undefined && materialData.side == "double") {
            materialParameters.side = THREE.DoubleSide;
        }

        if (materialData.emissive !== undefined) {
            materialParameters.emissive = materialData.emissive;
        }

        if (materialData.environment !== undefined) {
            materialParameters.envMapIntensity = materialData.environment;
        }

        if (materialData.roughness !== undefined) {
            materialParameters.roughness = materialData.roughness;
            materialParameters.originRoughness = materialData.roughness;
        }

        if (materialData.metalness !== undefined) {
            materialParameters.metalness = materialData.metalness;
            materialParameters.originMetalness = materialData.metalness;
        }
        if(materialData.refractionRatio !== undefined)
        {
            materialParameters.refractionRatio = materialData.refractionRatio;
        }

        var material;
        if (CLOUD.GlobalData.IBL) {
            materialParameters.iblProbe = scene.iblProbe;
            material = new ImageBasedLighting.IBLMaterial(materialParameters);
            material.type = 'IBL';
        }
        else {
            material = CLOUD.MaterialUtil.createStandardMaterial(materialParameters);
        }

        CLOUD.IdTargetUtil.addIdBufferFlagToMaterial(material);

        material.name = i;
        materials[i] = material;
        materialParameters = null;

        // -----------texture------------
        if( CLOUD.GlobalData.EnableTextureLoading )
        {
            var dataArray = [];
            var textureList = wholeMaterial.textures;
    
            for (var k in textureList) {
                var textureData = textureList[k];
                dataArray.push({type : k, data: textureData});
            }
    
            if (dataArray.length > 0) {
                textureDataArray.push({id: i, dataArray: dataArray});
            }
        }

    }
    
    if (textureDataArray.length > 0) {
        len = textureDataArray.length;
        for (i = 0; i < len; i++) {
            var dataArray = textureDataArray[i].dataArray;
            this.maxLoadTextureCount += dataArray.length;
        }

        for (i = 0; i < len; i++) {
            var id = textureDataArray[i].id;
            var dataArray = textureDataArray[i].dataArray;
            var textureArray = [];

            for (var j = 0, jLen = dataArray.length; j < jLen; j++) {
                var type = dataArray[j].type;
                var textureData = dataArray[j].data;
                var texture = this._loadTexture(url.textureUrl(textureData.sourceFile), function () {
                    scope._onLoadTexture();
                }, undefined, function () {
                    scope._onLoadTexture();
                });

                texture.repeat.fromArray([textureData.scale[0], textureData.scale[1]]);
                texture.offset.fromArray([textureData.offset[0], textureData.offset[1]]);
                //texture.repeat.fromArray([1, 1]);
                //texture.offset.fromArray([0, 0]);

                if (texture.setRotateAngle) {
                    texture.setRotateAngle(textureData.angle);
                }

                if (textureData.repeatU) {
                    texture.wrapS = THREE.RepeatWrapping;
                }

                if (textureData.repeatV) {
                    texture.wrapT = THREE.RepeatWrapping;
                }
                texture.texturetype = type;

                if (texture) {
                    textureArray.push(texture);
                }
            }

            if (textureArray.length > 0) {
                textures[id] = textureArray;
            }
        }

        textureDataArray = null;
    } else {
        scope._onLoadTexture();
    }
    
    reader = null;
};

CLOUD.Loader.ModelLoader.prototype._parseOctree = function (data, matrixInv, inner) {

    function setNodeByOctData(node, octData) {

        // 如果模型数据经过了变换，则变换包围盒
        if (matrixInv) {
            octData.boundingBox.applyMatrix4(matrixInv);
        }

        node.boundingBoxWorld = octData.boundingBox.clone(); //
        node.min = octData.boundingBox.min;
        node.max = octData.boundingBox.max;
        node.center = octData.boundingBox.getCenter();
        node.size = octData.boundingBox.getSize().lengthSq();
        node.childStart = octData.child_s;
        node.childEnd = octData.child_e;
    }

    function setNodeOctType(node, parent) {
        node.octType = 0;

        if (node.center.x < parent.center.x) {
            node.octType += 1;
        }
        if (node.center.y < parent.center.y) {
            node.octType += 2;
        }
        if (node.center.z < parent.center.z) {
            node.octType += 4;
        }
    }

    function traverse(parent, reader) {

        var childStart = parent.childStart;
        var childEnd = parent.childEnd;

        for (var i = childStart; i < childEnd; ++i) {

            var octData = reader.getNode(i);
            var octantId = octData.cell_id;
            var node = new CLOUD.Loader.OctreeNode(octantId, parent.depth);

            setNodeByOctData(node, octData);
            parent.add(node);
            setNodeOctType(node, parent);
            node.updateMaxDepth();
            traverse(node, reader);
        }
    }

    var rootNode = null;
    var reader = new CLOUD.Loader.OctreeReader(data);
    var count = reader.getCount();

    if (count > 0) {

        var octData = reader.getNode(0);
        var octantId = octData.cell_id;
        rootNode = new CLOUD.Loader.OctreeNode(octantId, 0);

        setNodeByOctData(rootNode, octData);
        traverse(rootNode, reader);
    }

    if (inner) {
        this.octreeRootNodeI = rootNode;
    } else {
        this.octreeRootNode = rootNode;
    }

    reader = null;

    CLOUD.Logger.log("Maximum Depth:", CLOUD.GlobalData.MaximumDepth);
};

CLOUD.Loader.ModelLoader.prototype.destroy = function () {

    this.taskManager = null;
    this.url = null;
    this.model = null;
    this.loader = null;
    this.octreeRootNode = null;
    this.octreeRootNodeI = null;
    this.userIdReader = null;
    this.userDataReader = null;
    this.symbolReader = null;
    this.sceneReaderArray = null;
    this.layerReader = null;

};

CLOUD.Loader.ModelLoader.prototype.destroyReader = function () {
    this.userIdReader = null;
    this.userDataReader = null;
    this.symbolReader = null;
    this.sceneReaderArray = null;
    // this.layerReader = null;
};

CLOUD.Loader.ModelLoader.prototype.getOctreeRootNodeInner = function () {
    return this.octreeRootNodeI;
};

CLOUD.Loader.ModelLoader.prototype.getOctreeRootNodeOuter = function () {
    return this.octreeRootNode;
};

CLOUD.Loader.ModelLoader.prototype.getSceneReaderArray = function () {
    return this.sceneReaderArray;
};

CLOUD.Loader.ModelLoader.prototype.getSymbolReader = function () {
    return this.symbolReader;
};

CLOUD.Loader.ModelLoader.prototype.getUserIdReader = function () {
    return this.userIdReader;
};

CLOUD.Loader.ModelLoader.prototype.getUserDataReader = function () {
    return this.userDataReader;
};

CLOUD.Loader.ModelLoader.prototype.getLayerReader = function () {
    return this.layerReader;
};

CLOUD.Loader.ModelLoader.prototype.setCrossOrigin = function (crossOrigin) {
    this.loader.setCrossOrigin(crossOrigin);
};

CLOUD.Loader.ModelLoader.prototype.load = function (notifyProgress) {

    var scope = this;
    var url = this.url;
    var loader = this.loader;
    var model = this.model;
    // var scene = model.manager.scene;

    this.notifyProgress = notifyProgress;

    model.dispatchEvent({type: CLOUD.EVENTS.ON_LOAD_START});

    loader.setResponseType("");
    loader.load(url.projectUrl(), function (text){

        var cfg;

        model.loaded = false;

        try{
            cfg = JSON.parse(text);
        } catch (err) {
            console.log("Config data exceptions!");
            model.dispatchEvent({type : CLOUD.EVENTS.ON_LOAD_INVALID_SCENE});
            return;
        }

        model.emptyScene = false;

        var metadata = cfg.metadata;
        var sceneCount = scope.sceneCount = metadata.scenes;
        // 空场景
        if(sceneCount === 0){
            model.emptyScene = true;
            model.dispatchEvent({type : CLOUD.EVENTS.ON_LOAD_EMPTY_SCENE});
            return;
        }

        // var mpkCount = metadata.mpks;
        var mpkCount = scope.mpkCount = metadata.mpks;
        var symbolCount = metadata.symbol;
        var octreeCount_o = metadata.octree_o;
        var octreeCount_i = metadata.octree_i;
        var materialCount = metadata.material || 0;
        var userDataCount = metadata.userdata || 0;// userdata
        var userIdCount = 1;// userId
        var hasCamera = metadata.camera || false;
        var layerData = metadata.layers || 0;
        var dataVersion = metadata.version;
        var materialVersion = metadata.material_json || 0;

        // var dataView = cfg.view;
        // var hasTransform = dataView.transform;

        if(!scope.checkVersionMatch(CLOUD.Version, dataVersion)){
            model.dispatchEvent({
                type : CLOUD.EVENTS.ON_VERSION_NO_MATCH,
                version : {engine : CLOUD.Version, data : dataVersion}
            });
            return;
        }

        scope.sceneReaderArray = new Array(sceneCount);

        // ------ 计算任务数 BEGIN ------ //
        scope.maxLoadTaskCount = 0;
        scope.maxLoadTaskCount += 1; //sceneCount;
        scope.maxLoadTaskCount += symbolCount;
        scope.maxLoadTaskCount += octreeCount_o;
        scope.maxLoadTaskCount += octreeCount_i;
        scope.maxLoadTaskCount += materialCount;
        scope.maxLoadTaskCount += userDataCount;
        scope.maxLoadTaskCount += userIdCount;

        if(layerData){
            scope.maxLoadTaskCount += 1;
        } else {
            scope.maxLoadTaskCount += mpkCount;
        }

        if(hasCamera){
            scope.maxLoadTaskCount++;
        }
        // ------ 计算任务数 END ------ //

        model.parse(cfg);

        var matrixInv = null;
        var matrixRoot = model.getTransformMatrix().clone();

        // 如果octree经过变换，则变换回世界系
        if(model.transformed){
            matrixInv = new THREE.Matrix4();
            matrixInv.getInverse(matrixRoot);
        }

        // ------ 加载模型前指定按需加载条件 BEGIN ------ //
        // 加载前指定加载条件感觉有些不合适!!!
        // if (layerData) {
        //     model.setLayerData(true);
        //     scope._loadLayer(loader, url, function () {
        //         var mpkIds = model.getLoadingMpkIdsOnDemand();
        //         scope.maxLoadTaskCount += mpkIds.length;
        //
        //         scope._loadScene(loader, url, 0);
        //         scope._loadMaterial(loader, url);
        //
        //         if (symbolCount > 0) {
        //             scope._loadSymbol(loader, url);
        //         }
        //
        //         if (octreeCount_o > 0) {
        //             scope._loadOctreeOuter(loader, url, matrixInv);
        //         }
        //
        //         if (octreeCount_i > 0) {
        //             scope._loadOctreeInner(loader, url, matrixInv);
        //         }
        //
        //         if (userIdCount > 0) {
        //             scope._loadUserId(loader, url);
        //         }
        //
        //         if (userDataCount > 0) {
        //             scope._loadUserData(loader, url);
        //         }
        //
        //         if (hasCamera) {
        //             scope._loadCamera(loader, url, matrixRoot);
        //         }
        //
        //         model.loadMpkByIds(mpkIds, function (doingCount, itemCount) {
        //             scope._onTaskFinished();
        //         });
        //     });
        //
        // } else {
        //
        //     model.setLayerData(false);
        //
        //     scope._loadScene(loader, url, 0);
        //     scope._loadMaterial(loader, url);
        //
        //     if (symbolCount > 0) {
        //         scope._loadSymbol(loader, url);
        //     }
        //
        //     if (octreeCount_o > 0) {
        //         scope._loadOctreeOuter(loader, url, matrixInv);
        //     }
        //
        //     if (octreeCount_i > 0) {
        //         scope._loadOctreeInner(loader, url, matrixInv);
        //     }
        //
        //     if (userIdCount > 0) {
        //         scope._loadUserId(loader, url);
        //     }
        //
        //     if (userDataCount > 0) {
        //         scope._loadUserData(loader, url);
        //     }
        //
        //     if (hasCamera) {
        //         scope._loadCamera(loader, url, matrixRoot);
        //     }
        //
        //     if (mpkCount > 0) {
        //         scope.maxLoadTaskCount += mpkCount;
        //     }
        //
        //     scope._loadMpks(loader, url, mpkCount);
        // }

        // ------ 加载模型前指定按需加载条件 END ------ //

        scope._loadScene(loader, url, 0);

        if (materialVersion == 0) {
            scope._loadMaterial(loader, url);
        } else {
            scope._loadMaterialJson(loader, url);
        }

        if (symbolCount > 0) {
            scope._loadSymbol(loader, url);
        }

        if (octreeCount_o > 0) {
            scope._loadOctreeOuter(loader, url, matrixInv);
        }

        if (octreeCount_i > 0) {
            scope._loadOctreeInner(loader, url, matrixInv);
        }

        if (userIdCount > 0) {
            scope._loadUserId(loader, url);
        }

        if (userDataCount > 0) {
            scope._loadUserData(loader, url);
        }

        if (hasCamera) {
            scope._loadCamera(loader, url, matrixRoot);
        }

        if (layerData) {
            model.setLayerData(true);
            scope._loadLayer(loader, url, function () {
                scope._onTaskFinished();
            });
        } else {
            model.setLayerData(false);
            scope._loadMpks(loader, url, mpkCount);
        }

    }, undefined, function () {

        console.log("config load error!");
        model.dispatchEvent({type: CLOUD.EVENTS.ON_LOAD_INVALID_SCENE});

    });
};

CLOUD.Loader.ModelLoader.prototype.loadMpkOnDemand = function (ids, progressCallback, finishCallback) {

    var taskManager = this.taskManager;

    for (var i = 0, len = ids.length; i < len; ++i) {
        taskManager.addMpkTask(ids[i]);
    }

    taskManager.processMpkTasks(progressCallback, finishCallback);

};

CLOUD.Loader.ModelLoader.prototype.loadMpk = function (mpkId, callback) {

    var scope = this;
    var referencedMeshCache = this.model.getReferencedMeshCache();
    var loader = this.loader;
    var url = this.url;
    var mpkWorkerUrl = CLOUD.GlobalData.MpkWorkerUrl;
    var userWorker = CLOUD.GlobalData.UseMpkWorker;

    if (userWorker) {

        loader.setResponseType("arraybuffer");
        loader.load(url.mpkUrl(mpkId), function (data) {

            var worker = new Worker(mpkWorkerUrl);
            worker.onmessage = function (event) {
                //var mpkReader = event.data[0];
                //if (mpkReader.header.blockId < mpkCount) {
                //    scope.mpkArray[mpkReader.header.blockId] = mpkReader;
                //}

                var result = event.data;

                for (var key in result) {
                    if (result.hasOwnProperty(key)) {
                        referencedMeshCache[key] = result[key];
                    }
                }

                callback();

                // TODO: Notify Progress
                scope._onTaskFinished();
            };

            //worker.postMessage( {"msg": data, result:scope.result});
            worker.postMessage({"msg": data});

        }, undefined, function (event) {

            scope.model.dispatchEvent({
                type: CLOUD.LOADERROREVENTS.LOAD_ERROR,
                errorType: CLOUD.LOADERROREVENTS.LOAD_MPK_ERROR,
                event: event
            });
            scope._onTaskFinished();

        });

    } else {

        loader.setResponseType("arraybuffer");
        loader.load(url.mpkUrl(mpkId), function (data) {

            scope._parseMpk(data);
            callback();
            scope._onTaskFinished();

        }, undefined, function (event) {

            scope.model.dispatchEvent({
                type: CLOUD.LOADERROREVENTS.LOAD_ERROR,
                errorType: CLOUD.LOADERROREVENTS.LOAD_MPK_ERROR,
                event: event
            });
            scope._onTaskFinished();

        });
    }

};

CLOUD.Loader.ModelLoader.prototype.checkVersionMatch = function (engineVersion, dataVersion) {

    //引擎版本号有四部分组成：<主版本号>.<子版本号>.<阶段版本号>.<日期版本号>：0.7.0.20171025。
    var engineNumbers = engineVersion.split(".");

    if (engineNumbers.length > 1) {

        var engineMajor = parseInt(engineNumbers[0]);// 主版本号
        var engineSubversion = parseInt(engineNumbers[1]); // 子版本号

        // 数据版本号
        var numberDataVersion = dataVersion.toLowerCase();
        numberDataVersion = parseFloat(numberDataVersion);

        // V2: engine version < 0.7, data version < 0.04
        // V3: engine version >= 0.7, data version >= 0.04
        // V4: ...

        // V2
        if (numberDataVersion < 0.04) {

            if (engineMajor === 0 && engineSubversion < 7) {
                return true;
            }

        }

        // V3
        if (numberDataVersion >= 0.04) {
            if (engineMajor > 0 || (engineMajor === 0 && engineSubversion >= 7)) {
                return true;
            }
        }

    }

    return false;

};
