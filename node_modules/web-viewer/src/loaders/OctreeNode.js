/**
 * @author xiaoj-a@glodon.com
 **/

// Spatial hierarchy representation
CLOUD.Loader.OctreeNode = function (oId, depth) {

    if (oId === undefined) {
        alert("Invalid Octant Id");
    }

    this.octantId = oId;
    this.childOctants = new Array();
    this.min = null;
    this.max = null;
    this.depth = depth || 0;
    this.center = null;
    this.size = -1;   // square length of octant size
    // used in generate priority factor F = size / (sqDistanceToCamera * cosTheta)
    this.priority = -1;
    // the child division below its parent
    // refer to OctantNeighborUtil.js OctType about the value definition
    this.octType = -1;
};

CLOUD.Loader.OctreeNode.prototype.isRoot = function () {
    return this.depth == 0;
};

// CLOUD.Loader.OctreeNode.prototype.constructor = CLOUD.Loader.OctreeNode;

CLOUD.Loader.OctreeNode.prototype.add = function (octant) {
    octant.depth = this.depth + 1;
    this.childOctants.push(octant);
};

/*
CLOUD.Loader.OctreeNode.prototype.findRadiusNeighborOctants = function (queryPoint, radius, squareRadius, depth, neighborOctants) {

    var node;
    var intersects = false;

    if (queryPoint && this.depth < depth) {
        // does inner box intersect with octant
        intersects = !(queryPoint.x + radius < this.min.x || queryPoint.x - radius > this.max.x ||
        queryPoint.y + radius < this.min.y || queryPoint.y - radius > this.max.y ||
        queryPoint.z + radius < this.min.z || queryPoint.z - radius > this.max.z);
    }

    if (intersects === true) {

        var queryPointToOctant = new THREE.Vector3(0.5 * (this.max.x + this.min.x) - queryPoint.x,
            0.5 * (this.max.y + this.min.y) - queryPoint.y, 0.5 * (this.max.z + this.min.z) - queryPoint.z);
        var distance = queryPointToOctant.lengthSq();
        if (distance < squareRadius) {
            // gather octants
            neighborOctants.push(this);
        }

        // search subtree
        for (var i = 0, length = this.childOctants.length; i < length; ++i) {

            node = this.childOctants[i];
            node.findRadiusNeighborOctants(queryPoint, radius, squareRadius, depth, neighborOctants);
        }
    }
    //else {
    //	CLOUD.Logger.log("Octant" + this.octantId + "culled!")
    //}
};

CLOUD.Loader.OctreeNode.prototype.intersectRayDistance = function (origin, direction) {
    var Tmin, Tmax, TYmin, TYmax;
    // X Axis
    var invDirectionX = 1 / direction.x;
    if (direction.x >= 0) {
        Tmin = (this.min.x - origin.x) * invDirectionX;
        Tmax = (this.max.x - origin.x) * invDirectionX;
    } else {
        Tmin = (this.max.x - origin.x) * invDirectionX;
        Tmax = (this.min.x - origin.x) * invDirectionX;
    }

    // Y Axis
    var invDirectionY = 1 / direction.y;
    if (direction.y >= 0) {
        TYmin = (this.min.y - origin.y) * invDirectionY;
        TYmax = (this.max.y - origin.y) * invDirectionY;
    } else {
        TYmin = (this.max.y - origin.y) * invDirectionY;
        TYmax = (this.min.y - origin.y) * invDirectionY;
    }

    if ((Tmin > TYmax) || (TYmin > Tmax)) {
        //no intersection
        return Infinity;
    }
    if (TYmin > Tmin) {
        Tmin = TYmin;
    }
    if (TYmax < Tmax) {
        Tmax = TYmax;
    }

    // Z Axis
    var TZmin, TZmax;
    var invDirectionZ = 1 / direction.z;
    if (direction.z >= 0) {
        TZmin = (this.min.z - origin.z) * invDirectionZ;
        TZmax = (this.max.z - origin.z) * invDirectionZ;
    } else {
        TZmin = (this.max.z - origin.z) * invDirectionZ;
        TZmaz = (this.min.z - origin.z) * invDirectionZ;
    }
    if ((Tmin > TZmax) || (TZmin > Tmax)) {
        // no intersection
        return Infinity;
    }
    if (TZmin > Tmin) {
        Tmin = TZmin;
    }
    if (TZmax < Tmax) {
        Tmax = TZmax;
    }
    // return nearest intersection distance
    return Tmin;
};
*/
CLOUD.Loader.OctreeNode.prototype.updateMaxDepth = function () {

    if (this.depth > CLOUD.GlobalData.MaximumDepth) {
        CLOUD.GlobalData.MaximumDepth = this.depth;
    }

};