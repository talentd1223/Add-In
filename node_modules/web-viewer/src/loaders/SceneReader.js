/**
 * @author muwj 2016/12/15
 */

CLOUD.Loader.SceneHeader = function ( buffer ) {

    var header = new Uint32Array( buffer, 0, 11 );

    this.blockId      = header[0];
    this.cellCount    = header[1];
    this.itemCount    = header[2];
    this.matrixCount  = header[3];
    this.geomBuffSize = header[4];
    this.layerBuffSize= header[5];
    this.cellOffset   = header[6];
    this.itemOffset   = header[7];
    this.matrixOffset = header[8];
    this.geomOffset   = header[9];
    this.layerOffset  = header[10];

    var bbox = new Float32Array( buffer, 4 * 11, 6 );
    this.boundingBox = new THREE.Box3(
        new THREE.Vector3( bbox[0], bbox[1], bbox[2] ),
        new THREE.Vector3( bbox[3], bbox[4], bbox[5] ) );

    header = null;
    bbox = null;
};

CLOUD.Loader.Cell = function ( buffer, offset ) {

    var cell_i = new Int32Array( buffer, offset, 5 );

    this.cellId    = cell_i[0];
    this.depth     = cell_i[1];
    this.itemIndex = cell_i[2];
    this.itemCount = cell_i[3];

    this.layerType = cell_i[4];
    this.layerSize = new Int32Array( buffer, offset + 5*4, 8 );
    this.layerOffset = new Int32Array( buffer, offset + (5+8)*4, 8 );

    var bbox = new Float32Array( buffer, offset + (5+8+8)*4, 6 );
    this.boundingBox = new THREE.Box3(
        new THREE.Vector3( bbox[0], bbox[1], bbox[2] ),
        new THREE.Vector3( bbox[3], bbox[4], bbox[5] ) );

    cell_i = null;
    bbox = null;
};

CLOUD.Loader.Item = function ( buffer, offset ) {

    var item_i = new Int32Array( buffer, offset, 7 );

    this.ItemId     = item_i[0];
    this.originalId = item_i[1];
    this.materialId = item_i[2];
    this.userDataId = item_i[3];
    this.matrixId   = item_i[4];
    this.type       = item_i[5];
    this.toData     = item_i[6];

    var bbox = new Float32Array( buffer, offset + 4 * 7, 6 );
    this.boundingBox = new THREE.Box3(
        new THREE.Vector3( bbox[0], bbox[1], bbox[2] ),
        new THREE.Vector3( bbox[3], bbox[4], bbox[5] ) );

    item_i = null;
    bbox = null;
};

CLOUD.Loader.Matrix = function ( buffer, offset ) {

    var matrixData = new Float32Array( buffer, offset, 4 * 4 );
    this.matrix = new THREE.Matrix4().fromArray( matrixData );
    matrixData = null;
};

CLOUD.Loader.GeomPipe = function ( buffer, offset ) {

    var geomData = new Float32Array( buffer, offset, 8 );

    this.startPt = new THREE.Vector3( geomData[0], geomData[1], geomData[2] );
    this.endPt   = new THREE.Vector3( geomData[3], geomData[4], geomData[5] );
    this.radius    = geomData[6];
    this.thickness = geomData[7];

    geomData = null;
};

CLOUD.Loader.SceneReader = function ( buffer ) {

    this.header = new CLOUD.Loader.SceneHeader( buffer );

    this.cellSize   = 4 * (5+8+8+6);
    this.itemSize   = 4 * 13;
    this.matrixSize = 4 * 16;
    this.maxSize    = 4 * 256;
    this.boxUvSize  = 36;
    this.pipeUvSize = 18;

    this.cellBuffer   = buffer.slice( this.header.cellOffset,   this.header.cellOffset   + this.header.cellCount   * this.cellSize );
    this.itemBuffer   = buffer.slice( this.header.itemOffset,   this.header.itemOffset   + this.header.itemCount   * this.itemSize );
    this.matrixBuffer = buffer.slice( this.header.matrixOffset, this.header.matrixOffset + this.header.matrixCount * this.matrixSize );
    this.geomBuffer   = buffer.slice( this.header.geomOffset,   this.header.geomOffset   + this.header.geomBuffSize );
    this.layerBuffer  = buffer.slice( this.header.layerOffset,  this.header.layerOffset  + this.header.layerBuffSize );

    // for data reading
    this.matr_cur_id = -1;
    this.pt_cell_min = new THREE.Vector3( 0.0, 0.0, 0.0 );
    this.pt_cell_max = new THREE.Vector3( 0.0, 0.0, 0.0 );
    this.pt_item_min = new THREE.Vector3( 0.0, 0.0, 0.0 );
    this.pt_item_max = new THREE.Vector3( 0.0, 0.0, 0.0 );

    var tmp_buffer = new ArrayBuffer( this.maxSize );
    this.cell_cur = new CLOUD.Loader.Cell( tmp_buffer, 0 );
    this.item_cur = new CLOUD.Loader.Item( tmp_buffer, 0 );
    this.matr_cur = new CLOUD.Loader.Matrix( tmp_buffer, 0 );
    this.pipe_cur = new CLOUD.Loader.GeomPipe( tmp_buffer, 0 );

    this.cell_cur.boundingBox.set( this.pt_cell_min, this.pt_cell_max );
    this.item_cur.boundingBox.set( this.pt_item_min, this.pt_item_max );
};

CLOUD.Loader.SceneReader.prototype = {

    constructor: CLOUD.Loader.SceneReader,

    getCellMpks: function( index ) {

        if ( index >= 0 && index < this.header.cellCount ) {
            var src = [];
            var cell = this.getCellInfo( index );
            for ( var i = cell.itemIndex; i < cell.itemCount; ++i ) {
                var item = this.getItemInfo( i );
                if( item.type === 1 ) { // mesh

                    var blockId = this.getMpkID( item.toData );
                    src.push( blockId );
                }
            }

            var key = {};
            var dist = [];
            for ( var j = 0; j < src.length; ++j ) {
                if ( ! key[src[j]] ) {
                    key[src[j]] = true;
                    dist.push( src[j] );
                }
            }
            return dist;
        }
    },

    getCell: function ( index ) {

        if ( index >= 0 && index < this.header.cellCount ) {
            return new CLOUD.Loader.Cell( this.cellBuffer, index * this.cellSize );
        }
    },

    getItem: function ( index ) {

        if ( index >= 0 && index < this.header.itemCount ) {
            return new CLOUD.Loader.Item( this.itemBuffer, index * this.itemSize );
        }
    },

    getMatrix: function ( index ) {

        if ( index >= 0 && index < this.header.matrixCount ) {
            return new CLOUD.Loader.Matrix( this.matrixBuffer, index * this.matrixSize );
        }
    },

    getGeomPipe: function ( offset ) {

        if ( offset >= 0 && offset < this.header.geomBuffSize ) {
            return new CLOUD.Loader.GeomPipe( this.geomBuffer, offset );
        }
    },

    getCellInfo: function ( index ) {

        if ( index >= 0 && index < this.header.cellCount ) {

            var data_i = new Int32Array( this.cellBuffer, index * this.cellSize, 5 );
            this.cell_cur.cellId    = data_i[0];
            this.cell_cur.depth     = data_i[1];
            this.cell_cur.itemIndex = data_i[2];
            this.cell_cur.itemCount = data_i[3];

            this.cell_cur.layerType = data_i[4];
            this.cell_cur.layerSize = new Int32Array( this.cellBuffer, index * this.cellSize + 5*4, 8 );
            this.cell_cur.layerOffset = new Int32Array( this.cellBuffer, index * this.cellSize + (5+8)*4, 8 );

            var data_f = new Float32Array( this.cellBuffer, index * this.cellSize + (5+8+8)*4, 6 );
            this.pt_cell_min.set( data_f[0], data_f[1], data_f[2] );
            this.pt_cell_max.set( data_f[3], data_f[4], data_f[5] );
            this.cell_cur.boundingBox.set( this.pt_cell_min, this.pt_cell_max );

            return this.cell_cur;
        }
    },

    getItemInfo: function ( index ) {

        if ( index >= 0 && index < this.header.itemCount ) {

            var data_i = new Int32Array( this.itemBuffer, index * this.itemSize, 7 );
            this.item_cur.ItemId     = data_i[0];
            this.item_cur.originalId = data_i[1];
            this.item_cur.materialId = data_i[2];
            this.item_cur.userDataId = data_i[3];
            this.item_cur.matrixId   = data_i[4];
            this.item_cur.type       = data_i[5];
            this.item_cur.toData     = data_i[6];

            var data_f = new Float32Array( this.itemBuffer, index * this.itemSize + 4 * 7, 6 );
            this.pt_item_min.set( data_f[0], data_f[1], data_f[2] );
            this.pt_item_max.set( data_f[3], data_f[4], data_f[5] );
            this.item_cur.boundingBox.set( this.pt_item_min, this.pt_item_max );

            return this.item_cur;
        }
    },

    getMatrixInfo: function ( index ) {

        if ( index == this.matr_cur_id ) {
            return this.matr_cur;
        }

        if ( index >= 0 && index < this.header.matrixCount ) {

            var data = new Float32Array( this.matrixBuffer, index * this.matrixSize, 4 * 4 );
            this.matr_cur.matrix.fromArray( data );

            this.matr_cur_id = index;
            return this.matr_cur;
        }
    },

    getGeomPipeInfo: function ( offset ) {

        if ( offset >= 0 && offset < this.header.geomBuffSize ) {

            var data = new Float32Array( this.geomBuffer, offset, 8 );
            this.pipe_cur.startPt.set( data[0], data[1], data[2] );
            this.pipe_cur.endPt.set  ( data[3], data[4], data[5] );
            this.pipe_cur.radius    = data[6];
            this.pipe_cur.thickness = data[7];

            return this.pipe_cur;
        }
    },

    getGeomBoxUvInfo: function ( offset ) {

        if ( offset >= 0 && (offset + this.boxUvSize * 4) <= this.header.geomBuffSize ) {

            return new Float32Array( this.geomBuffer, offset, this.boxUvSize );
        }
    },

    getGeomPipeUvInfo: function ( offset ) {

        if ( offset >= 0 && (offset + this.pipeUvSize * 4) <= this.header.geomBuffSize ) {

            return new Float32Array( this.geomBuffer, offset, this.pipeUvSize );
        }
    },

    getLayerInfo: function ( offset, size ) {

        if ( offset >= 0 && ( offset + size ) <= this.header.layerBuffSize ) {

            var data = new Uint32Array( this.layerBuffer, offset, size );
            return this.data;
        }
    },

    getMpkID: function ( mesh_id ) {

        return parseInt( mesh_id / 65536 );
    },

    getMeshIndex: function ( mesh_id ) {

        return parseInt( mesh_id % 65536 );
    }
};