/**
 *
 *
 * @param {CLOUD.ModelManager} manager - The place where models are aggregated and managed.
 * @param {Array}              parameters - {serverUrl: xxx, databagId:xxx}
 * @param {Function}           debut - callback function to render the scene when model finish loading model.
 * @constructor
 */
CLOUD.Model = function (manager, parameters, index, parseCfgFinish, debut) {

    this.manager = manager;
    this.databagId = parameters.databagId;
    this.loader = new CLOUD.Loader.ModelLoader(this, parameters, debut);
    this.pool = manager.getObjectPool();

    this.renderableCount = 0;
    this.renderableTotal = CLOUD.GlobalData.maxObjectNumInPool;
    //statics data
    this.numOfElements = 0;
    this.numOfTriangles = 0;

    this.boundingBoxWorld = null;
    this.rotation = new THREE.Quaternion();
    this.position = new THREE.Vector3();
    this.scale = new THREE.Vector3(1, 1, 1);
    this.transformMatrix = new THREE.Matrix4(); // 用于保存变换后的矩阵 - 兼容处理，以后要删除
    this.transformed = false;
    this.firstOctreeTransform = true;

    this.selectedMaterial =  this.manager.sceneState.selectionMaterial;

    this.cache = {
        cells: {},
        mpkIdxs: [],
        items: [],
        geometries: {},
        wireframeGeometries: {},
        materials: {},
        textures: {},
        instance: {
            geometries: {},
            wireframeGeometries: {},
            mapPackIdToIndices: {}, // packId: userId-geometryId-materialId
            vState: {},
            vColor: {},
            mcol0: {},
            mcol1: {},
            mcol2: {},
            mcol3: {},
            muvCol0: {},
            muvCol1: {},
            muvCol2: {},
            materials: {}
        }
    };

    this.layerDataCache = {};
    this.conditionsChanged = true;
    this.currentLayerData = null;

    this.wireframeMaterial = new THREE.MeshBasicMaterial({color: 0x000000, opacity: 0.4});
    this.wireframeMaterial.transparent = this.wireframeMaterial.opacity == 1.0 ? false : true;

    var materialParameters = CLOUD.MaterialUtil.getMaterialParameters(this.wireframeMaterial);
    this.instanceWireframeMaterial = CLOUD.MaterialUtil.createInstanceMaterial(materialParameters);

    this.instanceNode = {};
    this.instanceWireframeNode = {};

    this.instanceUpdateMap = {};

    this.visibleOctant = [];

    this.occlusionVisibleOctant = [];

    this.containsCamera = false;
    this.loaded = false;
    this.visible = true;
    this.emptyScene = false;

    // cache overall referenced unique meshes
    this.referencedMeshCache = {};

    this.nodePriority = {
        high: [],
        medium: [],
        low: []
    };

    this.cameraList = [];

    // unique index in all models
    // used to generate unique originalId for meshes
    this.index = index;

    this.mapUserIdToNodeInfos = {};
    this.mapMaterialIdToMeshNodes = {};
    this.mapMaterialIdToMergedNode = {};

    this.filterState = {
        HIDDEN: -1,
        NONE: 0,
        SELECTED: 1,
        HOVER: 2,
        OVERRIDED: 3
    };

    this._materialList = [];

    this.parseCfgFinish = parseCfgFinish;

    this._bridgeMatrix = new THREE.Matrix4(); //

    this.progressPercentage = {load: 0.4, collect: 0.5, merge: 0.1};

    this.progressFrequency = 10;

    this._dataMergeFinished = false;

};

CLOUD.Model.prototype.destroy = function () {

    if (this.loader) {
        this.loader.destroy();
        this.loader = null;
    }

    this.loaded = false;

    this.manager.scene.removeObjectGroupByName(this._getWireframeGroupName());

    this._clearNodePriority(true);
    this.nodePriority = null;

    this._clearCache();
    this.cache = null;

    this.pool = null;
    this.manager = null;

    this.visibleOctant = null;
    this.occlusionVisibleOctant = null;

    if (this.occlusionCamera) {
        this.occlusionCamera = null;
    }

    this.cameraList = null;

    this.renderableTotal = CLOUD.GlobalData.maxObjectNumInPool;
    this.numOfElements = 0;
    this.numOfTriangles = 0;

    this.layerDataCache = {};
    this.currentLayerData = null;

    this.mapUserIdToNodeInfos = {};
    this.mapMaterialIdToMeshNodes = {};
    this.mapMaterialIdToMergedNode = {};

    this._bridgeMatrix = null;
};

CLOUD.Model.prototype._clearCache = function () {

    var cache = this.cache;
    var geometries = cache.geometries;
    var materials = cache.materials;
    var instanceMaterials = cache.instance.materials;

    var geometry, material;

    for (var id in geometries) {
        geometry = geometries[id];
        if (geometry instanceof Array){
            for (var i = 0, len = geometry.length; i < len; i++) {
                geometry[i].dispose();
            }
        } else {
            geometry.dispose();
        }
    }


    for (id in materials) {
        material = materials[id];
        material.dispose();
    }

    for (id in instanceMaterials) {
        material = instanceMaterials[id];
        if (material instanceof Array) {
            for (var i = 0, len = material.length; i < len; i++) {
                material[i].dispose();
            }
        }else {
            material.dispose();
        }
    }

    cache.cells = {};
    cache.geometries = {};
    cache.materials = {};
    cache.textures = {};
    cache.mpkIdxs = [];
    cache.items = [];
};

// 支持动态控制纹理贴图
CLOUD.Model.prototype._updateTextureMapping = function () {

    var textureEnabled = CLOUD.GlobalData.EnableTextureMapping;

    function _updateMaterialTexture(material, map)
    {
        // 材质贴图存在, 则更新材质贴图
        if (map)
        {
            if(map.length === undefined){
                material.map = map;
            }
            else{
                for (var i=0;i<map.length;i++)
                {
                    if( map[i].texturetype == "map")
                    {
                        material.map = map[i];
                    }
                    else if( map[i].texturetype == "bumpMap")
                    {
                        //material.bumpMap = map[i];
                    }
                    else if( map[i].texturetype == "specularMap")
                    {
                        material.specularMap = map[i];
                    }
                    else if( map[i].texturetype == "alphaMap")
                    {
                        material.alphaMap = map[i];
                    }
                    else if( map[i].texturetype == "emissiveMap")
                    {
                        material.emissiveMap = map[i];
                    }
                    else if( map[i].texturetype == "environmentMap")
                    {
                        material.envMap = map[i];
                    }
                    else
                    {
                        console.warn("This map type is not supported yet:",map[i].texturetype)
                    }
                }
            }

            if (CLOUD.GlobalData.IBL)
            {
                material.refreshUniforms();
            }
            material.needsUpdate = true;// 更新材质
        }

    }

    if (this.lastTextureEnabled !== textureEnabled) {

        var textures = this.cache.textures;
        var materials = this.cache.materials;

        var instanceMaterials = this.cache.instance.materials;

        // 会影响效率
        var id;
        var material;
        if (textureEnabled) {

            for (id in materials) {
                

                material = materials[id];
                if (material) {
                    var map = textures[id];
                    _updateMaterialTexture(material, map);

                }
                material = instanceMaterials[id]; 
                if(material)
                {
                    if (material instanceof Array) {
                        for (var i = 0, len = material.length; i < len; i++) {
                            _updateMaterialTexture(material[i], map);
                        }

                    } else {
                        _updateMaterialTexture(material, map);
                    }


                }

            }
        } else {

            for (id in materials) {

                material = materials[id];
                if (material) {
                    material.map = null;
                    material.needsUpdate = true;// 更新材质
                }
                material = instanceMaterials[id]; 
                if(material)
                {
                    if (material instanceof Array) {
                        for (var i = 0, len = material.length; i < len; i++) {
                            material[i].map = null;
                            material[i].needsUpdate = true;
                        }
                    } else {
                        material.map = null;
                        material.needsUpdate = true;
                    }

                }

            }
        }

        this.lastTextureEnabled = textureEnabled;
    }

};

CLOUD.Model.prototype.getOctreeRoots = function (roots) {
    var loader = this.loader;
    var octreeRootNode = loader.getOctreeRootNodeOuter();

    if (octreeRootNode) {
        roots.push(octreeRootNode);
    }

    var octreeRootNodeI = loader.getOctreeRootNodeInner();
    if (octreeRootNodeI) {
        roots.push(octreeRootNodeI);
    }
};

CLOUD.Model.prototype._clearNodePriority = function (clearLow) {
    var nodePriority = this.nodePriority;
    nodePriority.high = [];
    nodePriority.medium = [];
    if (clearLow) {
        nodePriority.low = [];
    }
};

/**
 * 读取数据，构造mesh node
 *
 * @param {Object} reader - sceneReader or symbolReader ： 如果 itemParent === null或undefined 为sceneReader， 否则为 symbolReader
 * @param {number} cellId - 八叉树单元ID
 * @param {Object} item - 数据项
 * @param {Object} itemParent - 父节点参数项 {matrix : xxx, ItemId : xxx, originalId: xxx}
 * @param {string} categoryId - 分类编码 id
 * @param {number} cellDepth - 网格深度
 */
CLOUD.Model.prototype._readMeshInfo = function (reader, cellId, item, itemParent, categoryId, cellDepth) {
    var loader = this.loader;
    var userDataId;
    var originalId;
    var mtlId;
    if (itemParent === null) {
        userDataId = item.userDataId;
        originalId = item.originalId;
        mtlId = item.materialId;
    } else {// itemParent存在, 表示读取symbol数据
        userDataId = itemParent.userDataId;
        originalId = itemParent.originalId;
        // BIMFACEDM-2599
        // symbol instance's material id: exist(>=0) or non-exist(-1)
        // if symbol instance get own material, all child element of symbol use instance'
        // material, else use child's own material
        mtlId = (itemParent.materialId > -1) ? itemParent.materialId : item.materialId;
    }
    // originalId is identical in one model, convert the originalId to identical in all models
    originalId += this.index * 100000000; // one model can not have more than 100000000 meshes in predictable future

    var userIdReader = loader.getUserIdReader();
    var userId = userIdReader ? userIdReader.getString(originalId) : originalId;
    var nodeInfo = null;
    var nodeItemType = CLOUD.Model.NodeItemType;
    switch (item.type) {
        case nodeItemType.MESH:
            nodeInfo = this._getMeshNodeAttr(reader, item, itemParent);
            break;
        case nodeItemType.TUBE:
            nodeInfo = this._getMeshNodeAttrOfTube(reader, item, itemParent);
            break;
        case nodeItemType.PIPE:
            nodeInfo = this._getMeshNodeAttrOfPipe(reader, item, itemParent);
            break;
        case nodeItemType.BOX:
            nodeInfo = this._getMeshNodeAttrOfBox(reader, item, itemParent);
            break;
        case nodeItemType.BOX_M:
           nodeInfo = this._getMeshNodeAttrOfBoxM(reader, item, itemParent);
            break;
        case nodeItemType.PIPE_M:
            nodeInfo = this._getMeshNodeAttrOfPipeM(reader, item, itemParent);
            break;
        case nodeItemType.MESH_REF:
            nodeInfo = this._getMeshNodeAttrOfMeshRef(reader, item, itemParent);
            break;
        default:
            break;
    }

    if (!nodeInfo) {
        return;
    }

    if (this.isLayerData()) {
        if (this.cache.items.indexOf(nodeInfo.nodeId) !== -1) {
            return;
        }
        this.cache.items.push(nodeInfo.nodeId);
    }

    var userDataReader = loader.getUserDataReader();
    var userData = userDataReader ? userDataReader.getUserData(userDataId) : null;

    nodeInfo.type = item.type;
    nodeInfo.name = userId ? userId : nodeInfo.nodeId;
    nodeInfo.originalId = originalId;
    nodeInfo.materialId = mtlId;
    nodeInfo.userData = userData;
    nodeInfo.categoryId = categoryId;
    nodeInfo.cellId = cellId;
    nodeInfo.cellDepth = cellDepth;

    var batchMergeEnabled = CLOUD.GlobalData.BatchMergeEnabled;
    var instanceEnabled = CLOUD.GlobalData.Instance;
    var basicShape = this.isRegularGeometry(nodeInfo.geometryId);

    if (instanceEnabled && basicShape) {
        nodeInfo.instanceOrNot = true;
    } else {
        nodeInfo.instanceOrNot = false;
    }

    // 按 cellId 缓存 node info
    this._cacheNodeInfoByCellId(cellId, nodeInfo);
    // 按 userId 缓存 node info
    this._cacheNodeInfoByUserId(nodeInfo.name, nodeInfo);

    if (!batchMergeEnabled) {
        // 创建 geometry
        this._createGeometry(nodeInfo, batchMergeEnabled);
    }

    nodeInfo = null;
};

CLOUD.Model.prototype._readSymbolInfo = function (sceneReader, cellId, item, categoryId, cellDepth) {
    var symbolReader = this.loader.getSymbolReader();
    if (!symbolReader) {
        return;
    }
    var symbolCount = symbolReader.header.symbolCount;
    var id = item.toData;
    var matrixParent = sceneReader.getMatrixInfo(item.matrixId).matrix.clone();
    var itemParent = {
        matrix: matrixParent,
        ItemId: item.ItemId,
        originalId: item.originalId,
        userDataId: item.userDataId,
        materialId: item.materialId
    };
    if (id >= 0 && id < symbolCount) {
        var symbolCurrent = symbolReader.getSymbolInfo(id);
        for (var i = symbolCurrent.itemIndex; i < symbolCurrent.itemCount; ++i) {
            var symbolItem = symbolReader.getItemInfo(i);
            if (symbolItem.type === CLOUD.Model.NodeItemType.SYMBOL) {
                continue;
            }
            this._readMeshInfo(symbolReader, cellId, symbolItem, itemParent, categoryId, cellDepth);
        }
    }
    matrixParent = null;
    itemParent = null;
    symbolReader = null;
};

CLOUD.Model.prototype._createBufferGeometry = function (nodeInfo, batchMergeEnabled) {

    var itemType = CLOUD.Model.NodeItemType;
    var geometry = null;
    var positions, index, normal, uv;

    nodeInfo.uv = false;

    switch (nodeInfo.type) {
        case itemType.MESH:
        case itemType.MESH_REF:
            var geometryId = nodeInfo.geometryId;
            if (nodeInfo.type === itemType.MESH_REF) {
                geometryId = geometryId.split("_")[1];
            }
            // var refMeshInfo = this.referencedMeshCache[nodeInfo.geometryId];
            var refMeshInfo = this.referencedMeshCache[geometryId];
            positions = refMeshInfo.P;
            index = refMeshInfo.I;
            normal = refMeshInfo.N;
            uv = refMeshInfo.UV;
            if (batchMergeEnabled) {
                // if (positions instanceof Uint16Array) {
                //     positions = Float32Array.from(positions);
                // }
                // if (index instanceof Uint16Array) {
                //     index = Uint32Array.from(index);
                // }
                positions = Float32Array.from(positions);
                index = Uint32Array.from(index);
                if (normal) {
                    normal = Float32Array.from(normal);
                }
            }
            geometry = new THREE.BufferGeometry();
            geometry.setIndex(new THREE.BufferAttribute(index, 1));
            geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
            if (normal) {
                geometry.addAttribute('normal', new THREE.BufferAttribute(normal, 3));
            } else {
                geometry.computeVertexNormals(); // 计算法线，影响光照
            }
            if (uv) {
                geometry.addAttribute('uv', new THREE.BufferAttribute(uv, 2));
                nodeInfo.uv = true;
            }
            if (batchMergeEnabled) {
                geometry.applyMatrix(nodeInfo.matrix);
                geometry.normalizeNormals(); // 强制 normalize
            }
            break;
        case itemType.TUBE:
        case itemType.PIPE:
            if (batchMergeEnabled) {
                geometry = CLOUD.GeomUtil.UnitCylinderInstance.clone();
                geometry.setIndex(new THREE.BufferAttribute(Uint32Array.from(geometry.getIndex().array), 1));
                geometry.applyMatrix(nodeInfo.matrix);
                geometry.normalizeNormals(); // 强制 normalize
                nodeInfo.uv = true;
            } else {
                geometry = CLOUD.GeomUtil.UnitCylinderInstance;
            }
            break;
        case itemType.BOX:
            if (batchMergeEnabled) {
                geometry = CLOUD.GeomUtil.UnitBoxInstance.clone();
                // index 使用 Uint32Array
                geometry.setIndex(new THREE.BufferAttribute(Uint32Array.from(geometry.getIndex().array), 1));
                geometry.applyMatrix(nodeInfo.matrix);
                geometry.normalizeNormals(); // 强制 normalize
                nodeInfo.uv = true;
            } else {
                geometry = CLOUD.GeomUtil.UnitBoxInstance;
            }
            break;
        case itemType.BOX_M:
            if (batchMergeEnabled) {
                geometry = CLOUD.GeomUtil.getBoxBufferGeometryWithUvMatrices(nodeInfo.uvArrayBuffer);
                geometry.applyMatrix(nodeInfo.matrix);
                geometry.normalizeNormals(); // 强制 normalize
                if (nodeInfo.uvArrayBuffer) {
                    nodeInfo.uv = true;
                }
            } else {
                geometry = CLOUD.GeomUtil.getUnitTextureBox();
            }
            break;
        case itemType.PIPE_M:
            if (batchMergeEnabled) {
                geometry = CLOUD.GeomUtil.getPipeBufferGeometryWithUvMatrices(nodeInfo.uvArrayBuffer);
                geometry.applyMatrix(nodeInfo.matrix);
                geometry.normalizeNormals(); // 强制 normalize
                if (nodeInfo.uvArrayBuffer && nodeInfo.uvArrayBuffer.length === 18) {
                    nodeInfo.uv = true;
                }
            } else {
                geometry = CLOUD.GeomUtil.getUnitTextureCylinder();
            }
            break;
        default:
            break;
    }

    return geometry;
};

CLOUD.Model.prototype._createInstanceGeometry = function (nodeInfo) {

    var geometryId = nodeInfo.geometryId;
    var materialId = nodeInfo.materialId;
    var userId = nodeInfo.name;
    var matrix = nodeInfo.matrix;
    var uvArrayBuffer = nodeInfo.uvArrayBuffer;
    var cache = this.cache;
    var geometry = cache.geometries[geometryId];
    var material = cache.materials[materialId];
    var cachedInstance = cache.instance;

    if (!cachedInstance.geometries[geometryId]) {
        cachedInstance.geometries[geometryId] = {};
        cachedInstance.vState[geometryId] = {};
        cachedInstance.vColor[geometryId] = {};
        cachedInstance.mcol0[geometryId] = {};
        cachedInstance.mcol1[geometryId] = {};
        cachedInstance.mcol2[geometryId] = {};
        cachedInstance.mcol3[geometryId] = {};
        if (geometryId == "boxM") {
            cachedInstance.muvCol0[geometryId] = {};
            cachedInstance.muvCol1[geometryId] = {};
            cachedInstance.muvCol2[geometryId] = {};
        }
    }

    if (!cachedInstance.geometries[geometryId][materialId]) {
        cachedInstance.geometries[geometryId][materialId] = [];
        cachedInstance.vState[geometryId][materialId] = [];
        cachedInstance.vColor[geometryId][materialId] = [];
        cachedInstance.mcol0[geometryId][materialId] = [];
        cachedInstance.mcol1[geometryId][materialId] = [];
        cachedInstance.mcol2[geometryId][materialId] = [];
        cachedInstance.mcol3[geometryId][materialId] = [];

        if (geometryId === "boxM") {
            cachedInstance.muvCol0[geometryId][materialId] = [];
            cachedInstance.muvCol1[geometryId][materialId] = [];
            cachedInstance.muvCol2[geometryId][materialId] = [];
            for (var i = 0; i < 6; ++i) {
                cachedInstance.muvCol0[geometryId][materialId][i] = [];
                cachedInstance.muvCol1[geometryId][materialId][i] = [];
                cachedInstance.muvCol2[geometryId][materialId][i] = [];
            }
        }
    }

    var instanceGeometries = cachedInstance.geometries[geometryId][materialId];
    var instanceGeometry;

    // 生成两个 instanceGeometry
    if (instanceGeometries.length === 0) {
        for (var j = 0; j < 2; j++) {

            if (geometryId === "boxM") {
                instanceGeometry = new Array(6);
                for (var i = 0; i < 6; ++i) {
                    var data = CLOUD.GeomUtil.getBoxData(i);
                    instanceGeometry[i] = new THREE.InstancedBufferGeometry();
                    instanceGeometry[i].setIndex(data.index);
                    instanceGeometry[i].addAttribute('position', new THREE.Float32BufferAttribute(data.vertex, 3));
                    instanceGeometry[i].addAttribute('normal', new THREE.Float32BufferAttribute(data.normal, 3));
                    instanceGeometry[i].addAttribute('uv', new THREE.Float32BufferAttribute(data.uv, 2));
                }
            }else {
                instanceGeometry = new THREE.InstancedBufferGeometry();
                instanceGeometry.setIndex(geometry.index);
                instanceGeometry.addAttribute('position', geometry.attributes.position);
                var normal = geometry.attributes.normal;
                if (normal) {
                    instanceGeometry.addAttribute('normal', normal);
                }
                var uv = geometry.attributes.uv;
                if (uv) {
                    instanceGeometry.addAttribute('uv', geometry.attributes.uv);
                }
            }

            instanceGeometries.push(instanceGeometry);
        }
    }

    cachedInstance.vColor[geometryId][materialId].push(material.color.r, material.color.g, material.color.b, material.opacity);
    cachedInstance.vState[geometryId][materialId].push(0.0);

    var elements = matrix.elements;
    cachedInstance.mcol0[geometryId][materialId].push(elements[0], elements[1], elements[2]);
    cachedInstance.mcol1[geometryId][materialId].push(elements[4], elements[5], elements[6]);
    cachedInstance.mcol2[geometryId][materialId].push(elements[8], elements[9], elements[10]);
    cachedInstance.mcol3[geometryId][materialId].push(elements[12], elements[13], elements[14]);

    if (geometryId == "boxM" && uvArrayBuffer) {
        for (var i = 0; i < 6; ++i) {
            cachedInstance.muvCol0[geometryId][materialId][i].push(uvArrayBuffer[i * 6], uvArrayBuffer[i * 6 + 1]);
            cachedInstance.muvCol1[geometryId][materialId][i].push(uvArrayBuffer[i * 6 + 2], uvArrayBuffer[i * 6 + 3]);
            cachedInstance.muvCol2[geometryId][materialId][i].push(uvArrayBuffer[i * 6 + 4], uvArrayBuffer[i * 6 + 5]);
        }
    }

    var map = cachedInstance.mapPackIdToIndices;

    if (!map[userId]) {
        map[userId] = {};
    }
    if (!map[userId][geometryId]) {
        map[userId][geometryId] = {};
    }
    if (!map[userId][geometryId][materialId]) {
        map[userId][geometryId][materialId] = [];
    }

    var index = cachedInstance.vState[geometryId][materialId].length;
    map[userId][geometryId][materialId].push(index - 1);

    if (!this.instanceUpdateMap.hasOwnProperty(geometryId)) {
        this.instanceUpdateMap[geometryId] = true;
    }
};

CLOUD.Model.prototype.isRegularGeometry = function (geometryId) {
    return geometryId == "box" || geometryId == "pipe" || geometryId == "tube" ||
        geometryId == "boxM" || geometryId == "pipeM" || geometryId == "tubeM" ||
        (geometryId.split && geometryId.split('_')[0] == "refMesh");
};

CLOUD.Model.prototype._initWireframeData = function (geometry, geometryId) {
    var wireframeGeometry, wireframeIndex;
    if (geometry instanceof Array) {
        wireframeGeometry = new Array(geometry.length);
        for (var i = 0, len = geometry.length; i < len; i++) {
            wireframeIndex = CLOUD.BuildEdge(geometry[i].attributes.position.array, geometry[i].index.array);
            wireframeGeometry[i] = new THREE.BufferGeometry();
            wireframeGeometry[i].setIndex(new THREE.Uint32BufferAttribute(wireframeIndex, 1));
            wireframeGeometry[i].addAttribute('position', geometry[i].attributes.position, 3);
        }
    } else {
        wireframeIndex = CLOUD.BuildEdge(geometry.attributes.position.array, geometry.index.array);
        wireframeGeometry = new THREE.BufferGeometry();
        wireframeGeometry.setIndex(new THREE.Uint32BufferAttribute(wireframeIndex, 1));
        wireframeGeometry.addAttribute('position', geometry.attributes.position, 3);
    }
    this.cache.wireframeGeometries[geometryId] = wireframeGeometry;
};

CLOUD.Model.prototype._getMeshNodeAttr = function (sceneOrSymbolReader, item, itemParent) {

    var matrix;
    var transformed = false;

    if (item.matrixId !== -1) {
        matrix = sceneOrSymbolReader.getMatrixInfo(item.matrixId).matrix.clone();
    } else {
        matrix = new THREE.Matrix4();
        transformed = true;
    }
    //var matrix = sceneOrSymbolReader.getMatrixInfo(item.matrixId).matrix.clone();
    this._bridgeMatrix.copy(matrix);
    var nodeId = itemParent ? itemParent.ItemId + "_" + item.ItemId : item.ItemId;
    var geometryId = item.toData;
    var refMeshCache = this.referencedMeshCache;
    if (!refMeshCache[geometryId]) {
        return;
    }
    var meshData = refMeshCache[geometryId].M;
    if (meshData === void 0) {
        CLOUD.Logger.log("No mesh information.");
        return null;
    }

    var matrixTmp = new THREE.Matrix4();
    matrixTmp.setPosition(new THREE.Vector3(meshData.baseX, meshData.baseY, meshData.baseZ));
    matrixTmp.scale(new THREE.Vector3(meshData.baseScale, meshData.baseScale, meshData.baseScale));
    if (meshData.baseScale !== 0.0) {
        matrix.multiply(matrixTmp);
    }
    meshData = null;

    if (!transformed && itemParent) {
        matrix.multiplyMatrices(itemParent.matrix, matrix);
        this._bridgeMatrix.multiplyMatrices(itemParent.matrix, this._bridgeMatrix);
    }

    var boundingBox = item.boundingBox.clone();
    boundingBox.applyMatrix4(this._bridgeMatrix);

    return {nodeId: nodeId, geometryId: geometryId, matrix: matrix, boundingBox: boundingBox};
};

CLOUD.Model.prototype._getMeshNodeAttrOfPipe = function (sceneOrSymbolReader, item, itemParent) {
    var geomAttr = sceneOrSymbolReader.getGeomPipeInfo(item.toData);
    var matrix = sceneOrSymbolReader.getMatrixInfo(item.matrixId).matrix.clone();
    this._bridgeMatrix.copy(matrix);
    var nodeId = itemParent ? itemParent.ItemId + "_" + item.ItemId : item.ItemId;
    nodeId += "_pipe";
    var geometryId = "pipe";
    var startPt = geomAttr.startPt;
    var endPt = geomAttr.endPt;
    var dir = new THREE.Vector3();
    dir.subVectors(endPt, startPt);
    var len = dir.length();
    dir.normalize();
    var radius = geomAttr.radius;
    if (radius <= 1) {
        radius = 100;
    }
    var unitY = new THREE.Vector3(0, 1, 0);
    var scale = new THREE.Vector3(radius, len, radius);
    var quaternion = new THREE.Quaternion().setFromUnitVectors(unitY, dir);
    var position = startPt.clone().addScaledVector(dir, len * 0.5);
    var matrixTmp = new THREE.Matrix4().compose(position, quaternion, scale);
    matrix.multiply(matrixTmp);

    if (itemParent) {
        matrix.multiplyMatrices(itemParent.matrix, matrix);
        this._bridgeMatrix.multiplyMatrices(itemParent.matrix, this._bridgeMatrix);
    }

    var boundingBox = item.boundingBox.clone();
    boundingBox.applyMatrix4(this._bridgeMatrix);

    geomAttr = null;
    return {nodeId: nodeId, geometryId: geometryId, matrix: matrix, boundingBox: boundingBox};
};

CLOUD.Model.prototype._getMeshNodeAttrOfTube = function (sceneOrSymbolReader, item, itemParent) {
    var nodeInfo = this._getMeshNodeAttrOfPipe(sceneOrSymbolReader, item, itemParent);
    nodeInfo.nodeId += "_tube";
    nodeInfo.geometryId = "tube";
    return nodeInfo;
};

CLOUD.Model.prototype._getMeshNodeAttrOfBox = function (sceneOrSymbolReader, item, itemParent) {
    var matrix = sceneOrSymbolReader.getMatrixInfo(item.matrixId).matrix.clone();
    this._bridgeMatrix.copy(matrix);
    var bBox = item.boundingBox;
    var boxSize = bBox.getSize();
    var boxCenter = bBox.getCenter();
    var nodeId = itemParent ? itemParent.ItemId + "_" + item.ItemId : item.ItemId;
    nodeId += "_box";
    var geometryId = "box";
    var matrixTmp = new THREE.Matrix4().scale(new THREE.Vector3(boxSize.x, boxSize.y, boxSize.z));
    matrixTmp.setPosition(boxCenter);
    matrix.multiply(matrixTmp);
    if (itemParent) {
        matrix.multiplyMatrices(itemParent.matrix, matrix);
        this._bridgeMatrix.multiplyMatrices(itemParent.matrix, this._bridgeMatrix);
    }
    var boundingBox = item.boundingBox.clone();
    boundingBox.applyMatrix4(this._bridgeMatrix);
    return {nodeId: nodeId, geometryId: geometryId, matrix: matrix, boundingBox: boundingBox};
};

CLOUD.Model.prototype._getMeshNodeAttrOfBoxM = function (sceneOrSymbolReader, item, itemParent) {
    var uvArray = sceneOrSymbolReader.getGeomBoxUvInfo(item.toData);
    var matrix = sceneOrSymbolReader.getMatrixInfo(item.matrixId).matrix.clone();
    // this._bridgeMatrix.copy(matrix);
    var nodeId = itemParent ? itemParent.ItemId + "_" + item.ItemId : item.ItemId;
    nodeId += "_boxM";
    var geometryId = "boxM";
    if (itemParent) {
        matrix.multiplyMatrices(itemParent.matrix, matrix);
        // this._bridgeMatrix.multiplyMatrices(itemParent.matrix, this._bridgeMatrix);
    }
    var boundingBox = item.boundingBox.clone();
    boundingBox.applyMatrix4(matrix);
    return {nodeId: nodeId, geometryId: geometryId, matrix: matrix, boundingBox: boundingBox, uvArrayBuffer: uvArray};
};

CLOUD.Model.prototype._getMeshNodeAttrOfPipeM = function (sceneOrSymbolReader, item, itemParent) {
    var uvArray = sceneOrSymbolReader.getGeomPipeUvInfo(item.toData);
    var matrix = sceneOrSymbolReader.getMatrixInfo(item.matrixId).matrix.clone();
    // this._bridgeMatrix.copy(matrix);
    var nodeId = itemParent ? itemParent.ItemId + "_" + item.ItemId : item.ItemId;
    nodeId += "_pipeM";
    var geometryId = "pipeM";
    if (itemParent) {
        matrix.multiplyMatrices(itemParent.matrix, matrix);
        // this._bridgeMatrix.multiplyMatrices(itemParent.matrix, this._bridgeMatrix);
    }

    var boundingBox = item.boundingBox.clone();
    boundingBox.applyMatrix4(matrix);
    return {nodeId: nodeId, geometryId: geometryId, matrix: matrix, boundingBox: boundingBox, uvArrayBuffer: uvArray};
};

CLOUD.Model.prototype._getMeshNodeAttrOfMeshRef = function (sceneOrSymbolReader, item, itemParent) {
    var matrix = sceneOrSymbolReader.getMatrixInfo(item.matrixId).matrix.clone();
    this._bridgeMatrix.copy(matrix);
    var nodeId = itemParent ? itemParent.ItemId + "_" + item.ItemId : item.ItemId;
    var geometryId = item.toData;
    var refMeshCache = this.referencedMeshCache;
    if (!refMeshCache[geometryId]) {
        return;
    }
    var meshData = refMeshCache[geometryId].M;
    if (meshData === void 0) {
        CLOUD.Logger.log("No mesh information.");
        return null;
    }

    var matrixTmp = new THREE.Matrix4();
    matrixTmp.setPosition(new THREE.Vector3(meshData.baseX, meshData.baseY, meshData.baseZ));
    matrixTmp.scale(new THREE.Vector3(meshData.baseScale, meshData.baseScale, meshData.baseScale));
    if (meshData.baseScale !== 0.0) {
        matrix.multiply(matrixTmp);
    }
    if (itemParent) {
        matrix.multiplyMatrices(itemParent.matrix, matrix);
        this._bridgeMatrix.multiplyMatrices(itemParent.matrix, this._bridgeMatrix);
    }

    var boundingBox = item.boundingBox.clone();
    boundingBox.applyMatrix4(this._bridgeMatrix);
    meshData = null;
    return {nodeId: nodeId, geometryId: "refMesh_" + geometryId, matrix: matrix, boundingBox: boundingBox};
};

CLOUD.Model.prototype._overrideOcclusionMaterial = function (meshNode) {

    var material = meshNode.material;

    if (material) {

        // 只处理不透明的构件
        if (material.transparent === false) {

            var materialEx = this.manager.acquireMaterial();
            var newMaterial = materialEx.material;

            if (material.color) {
                newMaterial.color.copy(material.color);
            } else {
                materialEx.resetColor();
            }

            newMaterial.opacity = CLOUD.GlobalData.OcclusionOpacity;
            meshNode.material = newMaterial;
            meshNode.material.needsUpdate = true;
        }

    }

};

/**
 * 遮挡测试
 *
 */
CLOUD.Model.prototype._occlusionTest = function () {

    if (CLOUD.GlobalData.OcclusionTranslucentEnabled) {

        var meshes = this.pool.getObjects();
        var objectMap = this.manager.octantToObjectMap;
        var octantLen = this.occlusionVisibleOctant.length;

        if (octantLen > 0) {

            var frustum = this.manager.getFrustumFromOcclusionCamera();

            for (var i = 0; i < octantLen; ++i) {

                var cellId = this.occlusionVisibleOctant[i].octantId;
                var indexes = objectMap[cellId];

                if (indexes && indexes.length > 0) {

                    for (var j = 0, len = indexes.length; j < len; j += 2) {
                        for (var k = indexes[j]; k <= indexes[j + 1]; k++) {

                            var meshNode = meshes[k];

                            if (CLOUD.CameraUtil.intersectObjectWithFrustum(meshNode, frustum)) {

                                this._overrideOcclusionMaterial(meshNode);
                            }

                        }
                    }
                }
            }

        }
    }
};

CLOUD.Model.prototype._sortVisibleOctant = function (camera) {

    var scope = this;

    var ancestorAndNeighbors = null;
    if (scope.containsCamera && scope.loader.octreeRootNodeI != null) {
        var octUtil = new CLOUD.OctantNeighborUtil(camera, scope.loader.octreeRootNodeI);
        ancestorAndNeighbors = octUtil.getAncestorAndNeighbors();
    }

    this.visibleOctant.sort(function (a, b) {
        if (ancestorAndNeighbors != null) {
            if (ancestorAndNeighbors[a.octantId] != undefined) {
                return -1;
            }

            if (ancestorAndNeighbors[b.octantId] != undefined) {
                return 1;
            }
        }
        if (a.priority > b.priority) {
            //  sort a to a lower index than b, i.e. a comes first.
            return -1;
        } else if (a.priority < b.priority) {
            return 1;
        }
        // same priority
        return 0;
    });
};

CLOUD.Model.prototype._readItemData = function (sceneReader, idx, cellId, categoryId, cellDepth) {
    var item = sceneReader.getItemInfo(idx);

    if (item === void 0) {
        return;
    }

    if (item.type === CLOUD.Model.NodeItemType.SYMBOL) {
        this._readSymbolInfo(sceneReader, cellId, item, categoryId, cellDepth);
    } else {
        this._readMeshInfo(sceneReader, cellId, item, null, categoryId, cellDepth);
    }
};

CLOUD.Model.prototype._getWireframeGroupName = function () {
    return CLOUD.ObjectGroupType.WIREFRAME + "_" + this.databagId;
};

CLOUD.Model.prototype._updateMeshNodes = function (totalNodeCount) {

    var pool = this.pool;
    var manager = this.manager;
    var sceneState = manager.sceneState;
    var filter = manager.filter;
    var bagId = this.databagId;

    var cache = this.cache;
    var cacheGeometries = cache.geometries;
    var cacheMaterials = cache.materials;

    var cachewireframeGeometries = cache.wireframeGeometries;

    var nodePriority = this.nodePriority;
    var priorityNodesSet = [nodePriority.high, nodePriority.medium, nodePriority.low];

    var selectionMaterial = null;
    if (nodePriority.high.length > 0) {
        selectionMaterial = this.selectedMaterial;
    }
    var matrix = new THREE.Matrix4();

    var hasLowPriorityOverride = filter._hasOverrideMaterialFilter();
    var hasRenderWithBoardlineFilter = filter._hasRenderWithBoardlineFilter();

    var counter = 0;

    var octantStartIndex = -1;
    var curOctantId = -1;

    if (CLOUD.GlobalData.DrawingStyle != CLOUD.DrawingStyle.BOARDLINE) {

        for (var j = 0, count = priorityNodesSet.length; j < count; ++j) {

            var priorityNodes = priorityNodesSet[j];

            for (var i = 0, len = priorityNodes.length; i < len; ++i) {

                ++counter;

                if (counter > totalNodeCount) {
                    break;
                }

                var cacheNode = priorityNodes[i];
                var nodeId = cacheNode.nodeId;
                var userId = cacheNode.name;
                var userData = cacheNode.userData;
                var geometryId = cacheNode.geometryId;
                var originalId = cacheNode.originalId;
                matrix = cacheNode.matrix;

                var visible = true;

                if (CLOUD.GlobalData.Instance && this.isRegularGeometry(geometryId))
                    visible = false;
                // continue;


                var geometry = cacheGeometries[geometryId];
                var materialId = cacheNode.materialId;

                // 材质过滤
                // Material override sequence:
                // 1, High priority material override: translucent or transparent
                // 2, selected object;
                // 3, low priority material override;
                // 4, hovered object by highlighting material
                var material = null;
                var selected = sceneState.isSelected(userId);
                if(selected==true && !filter._isSelectable(cacheNode)){
                    selected=false;
                }
                if (j === 0) {
                    material = filter._getOverrideMaterial(cacheNode);
                    if (!material || selected) {
                        material = selectionMaterial;
                    }
                }
                else if (hasLowPriorityOverride) {
                    material = filter._getOverrideMaterial(cacheNode);
                }
                
                //if material==null , set default material instead
                material = material || cacheMaterials[materialId];
                if (CLOUD.GlobalData.Hover && !CLOUD.GlobalData.EnableRenderPass) {
                    if (sceneState.hoverId === userId && selected === false) {
                        material = sceneState.getHoverMaterial(material);
                    }
                }

                var index = 0;
                if (geometry instanceof Array) {
                    for (var k = 0, kLen = geometry.length; k < kLen; k++) {
                        var parameters = {
                            databagId: bagId,
                            nodeId: nodeId,
                            userId: userId,
                            originalId: originalId,
                            userData: userData,
                            geometry: geometry[k],
                            matrix: matrix,
                            material: material,
                            renderOrder: material.transparent ? 0 : CLOUD.GlobalData.MaximumDepth - cacheNode.cellDepth,
                            visible: visible
                        };
                        index = pool.get(parameters);
                        parameters = null;
                    }
                } else {
                    var parameters = {
                        databagId: bagId,
                        nodeId: nodeId,
                        userId: userId,
                        originalId: originalId,
                        userData: userData,
                        geometry: geometry,
                        matrix: matrix,
                        material: material,
                        renderOrder: material.transparent ? 0 : CLOUD.GlobalData.MaximumDepth - cacheNode.cellDepth,
                        visible: visible
                    };
                    index = pool.get(parameters);
                    parameters = null;
                }
                material = null;
                if (index >= 0) {
                    if (curOctantId !== cacheNode.octantId) {
                        if (index > 0) {
                            manager.addObjectRangeToOctantMap(curOctantId, octantStartIndex, index - 1);
                        }
                        octantStartIndex = index;
                        curOctantId = cacheNode.octantId;
                    }
                }
            }
        }
    }
    selectionMaterial = null;

    if (CLOUD.GlobalData.DrawingStyle != CLOUD.DrawingStyle.SHADING) {

        var wireframeGroupNode = this.manager.scene.getOrCreateObjectGroup(this._getWireframeGroupName(), {globalSpace: true});
        // TODO: like the object pool, not clear the group every time. allocate the memory and wireframe mesh once
        //
        wireframeGroupNode.clear();

        counter = 0;

        for (var j = 0, count = priorityNodesSet.length; j < count; ++j) {

            var priorityNodes = priorityNodesSet[j];

            for (var i = 0, len = priorityNodes.length; i < len; ++i) {

                ++counter;

                if (counter > totalNodeCount) {
                    break;
                }

                var cacheNode = priorityNodes[i];
                var geometryId = cacheNode.geometryId;
                matrix = cacheNode.matrix;

                if (CLOUD.GlobalData.Instance && (geometryId == "box" || geometryId == "boxM"))
                    continue;

                if (hasRenderWithBoardlineFilter && !filter._isRenderWithBoardline(cacheNode)) {
                    // There is no boardline setting in filter, do not draw it.
                    continue;
                }

                if (!cachewireframeGeometries.hasOwnProperty(geometryId)) {
                    this._initWireframeData(cacheGeometries[geometryId], geometryId);
                }

                var lineMesh;
                var wireframeGeometry = cachewireframeGeometries[geometryId];
                if (wireframeGeometry instanceof Array) {
                    for (var k = 0, kLen = wireframeGeometry.length; k < kLen; k++) {
                        lineMesh = new THREE.LineSegments(wireframeGeometry[k], this.wireframeMaterial);
                        lineMesh.name = "Wireframes";
                        lineMesh.applyMatrix(matrix.clone());
                        wireframeGroupNode.add(lineMesh);
                    }
                } else {
                    lineMesh = new THREE.LineSegments(wireframeGeometry, this.wireframeMaterial);
                    lineMesh.name = "Wireframes";
                    lineMesh.applyMatrix(matrix.clone());
                    wireframeGroupNode.add(lineMesh);
                }
            }

        } //for (var j = 0, count = priorityNodesSet.length; j < count; ++j) {
    }

    // add map for the last octant
    if (octantStartIndex !== -1) {
        manager.addObjectRangeToOctantMap(curOctantId, octantStartIndex, pool.counter - 1);
    }

    priorityNodesSet = null;
};

CLOUD.Model.prototype.load = function (notifyProgress) {
    this.loader.load(notifyProgress);
};

CLOUD.Model.prototype.setCrossOrigin = function (crossOrigin) {
    this.loader.setCrossOrigin(crossOrigin);
};

CLOUD.Model.prototype.setupWireframe = function () {

    var wireframeGroupName = this._getWireframeGroupName();

    if (CLOUD.GlobalData.DrawingStyle != CLOUD.DrawingStyle.SHADING) {
        var wireframeGroupNode = this.manager.scene.getOrCreateObjectGroup(wireframeGroupName, {globalSpace: true});
        wireframeGroupNode.updateMatrixWorld(true);
    } else {
        this.manager.scene.removeObjectGroupByName(wireframeGroupName);
    }
};

CLOUD.Model.prototype.setupInstanceWireframe = function () {

    var instanceWireframeGeometry = this.manager.scene.getOrCreateObjectGroup(CLOUD.ObjectGroupType.INSTANCEWIREFRAMEGEOMETRY, {globalSpace: true});

    if (CLOUD.GlobalData.DrawingStyle != CLOUD.DrawingStyle.SHADING) {
        instanceWireframeGeometry.visible = CLOUD.GlobalData.Instance ? true : false;
    } else {
        instanceWireframeGeometry.visible = false;
    }
};

CLOUD.Model.prototype._frustumCull = function (camera, rootOctant) {
    var manager = this.manager;
    // 'getFrustum' will updateMVP by default, here we do not update again.
    // MVP was already update in 'CameraControl::update'
    var frustum = camera.getFrustum();
    var depth = CLOUD.GlobalData.OctantDepth; // traverse till depth arrived.
    var viewProjectionMatrix = camera.projScreenMatrix;
    var octantBox = new THREE.Box3();
    var visibleOctant = [];
    var occlusionVisibleOctant = [];
    var matrixRoot = this.manager.getScene().getMatrixGlobal();
    var layerData = this.isLayerData();
    var boundingBoxesOnDemand;

    // OctantBox 与 Frustum 相交
    function intersectFrustum(root, frustum, depth, withPriority, visibleOctant) {
        var intersected;
        var node;
        if (frustum && root.depth < depth) {
            octantBox.set(root.min, root.max);
            intersected = frustum.intersectsBox(octantBox);
        }
        if (intersected) {
            if (withPriority) {
                var screenBound = octantBox.applyMatrix4(viewProjectionMatrix);
                var screenSize = screenBound.getSize().length();
                // depth could less than 0, that's invalid. So we give an epsilon (0.000001).
                var nearDepth = screenBound.getCenter().z;
                nearDepth = (nearDepth > 0.000001) ? nearDepth : 0.000001;
                root.priority = screenSize / nearDepth;
                // gather visible objects
                visibleOctant.push(root);
            } else {
                // gather occlusion objects
                visibleOctant.push(root);
            }
            // search subtree
            for (var i = 0, length = root.childOctants.length; i < length; ++i) {
                node = root.childOctants[i];
                intersectFrustum(node, frustum, depth, withPriority, visibleOctant);
            }
        }
    }

    // OctantBox 与 condition BoundingBox 相交
    function getActualVisibleOctant(grossVisibleOctant, boundingBoxes, matrix, actualVisibleOctant) {
        var intersected;
        var box;
        var boxOctant = new THREE.Box3();
        actualVisibleOctant = actualVisibleOctant || [];
        for (var i = 0, len = grossVisibleOctant.length; i < len; ++i) {
            var octantNode = grossVisibleOctant[i];
            boxOctant.set(octantNode.min, octantNode.max);
            for (var j = 0, len2 = boundingBoxes.length; j < len2; ++j) {
                box = boundingBoxes[j].clone();
                box.applyMatrix4(matrix);
                intersected = box.intersectsBox(boxOctant);
                if (intersected) {
                    actualVisibleOctant.push(octantNode);
                    break;
                }
            }
        }
    }

    if (CLOUD.GlobalData.DEBUG) {
        manager.showOctreeBox(rootOctant);
    }

    if (layerData) {
        boundingBoxesOnDemand = this.getBoundingBoxesOnDemand();
        intersectFrustum(rootOctant, frustum, depth, true, visibleOctant);
        getActualVisibleOctant(visibleOctant, boundingBoxesOnDemand, matrixRoot, this.visibleOctant);
    } else {
        intersectFrustum(rootOctant, frustum, depth, true, this.visibleOctant);
    }

    // TODO: 澄清该功能
    // -------------------- 遮挡视锥 -------------------- //
    var occlusionTranslucentEnabled = CLOUD.GlobalData.OcclusionTranslucentEnabled;
    if (occlusionTranslucentEnabled) {
        var occlusionFrustum = this.manager.getFrustumFromOcclusionCamera();
        if (layerData) {
            intersectFrustum(rootOctant, occlusionFrustum, depth, false, occlusionVisibleOctant);
            getActualVisibleOctant(occlusionVisibleOctant, boundingBoxesOnDemand, this.occlusionVisibleOctant);
        } else {
            intersectFrustum(rootOctant, occlusionFrustum, depth, false, this.occlusionVisibleOctant);
        }
    }
    // ---------------------------------------------------- //

    return true;
};

CLOUD.Model.prototype._logicCull = function (sceneReader, indoor, curLowNodeCount, cellCount) {
    var manager = this.manager;
    var filter = manager.filter;
    var hasHiddenFileIdFilter = filter._hasHiddenFileIdFilter();
    var hasVisibleFilter = filter._hasVisibleFilter();
    var hasOverrideFilter = filter._hasOverrideMaterialFilter();
    var selectionSet = manager.sceneState.selectionSet;
    var hasPromotionFilter = filter._hasRenderPromotionFilter();
    var cacheCells = this.cache.cells;
    var nodePriorityHigh = this.nodePriority.high;
    var nodePriorityMedium = this.nodePriority.medium;
    var nodePriorityLow = this.nodePriority.low;
    var maxLowNodeCount = this.nodePriority.low.length;
    var layerData = this.isLayerData();
    var conditionsOnDemandLoad = this.getConditionsOnDemandLoad();

    function collectNodeInfo(nodeInfo, priorityCategories) {
        var userData = nodeInfo.userData;
        var categoryId = userData ? userData.categoryId : undefined;
        var mediumPriority = false;
        // 文件过滤
        if (hasHiddenFileIdFilter && filter._isHiddenFileId(nodeInfo)) {
            return;
        }
        // 分层数据
        if (layerData) {
            // 根据楼层专业过滤
            if (conditionsOnDemandLoad && userData && userData.levelName && userData.specialty) {
                var key = userData.levelName + "" + userData.specialty;
                if (conditionsOnDemandLoad[key] === undefined) {
                    return;
                }
            }
        }
        // 可见性过滤
        if (filter._isVisible(nodeInfo) === false) {
            return;
        }
        // 材质过滤
        var isHighlight = selectionSet.hasOwnProperty(nodeInfo.name) ||
            ( hasOverrideFilter && filter._hasHighPriorityOverrideMaterial(nodeInfo));
        if (priorityCategories && categoryId && priorityCategories[categoryId]) {
            mediumPriority = true;
        }
        // priority promotion
        if (hasPromotionFilter && (filter._isRenderPromotion(nodeInfo))) {
            mediumPriority = true;
        }
        if (isHighlight) {
            nodePriorityHigh.push(nodeInfo);
        } else if (mediumPriority) {
            nodePriorityMedium.push(nodeInfo);
        } else if (curLowNodeCount < maxLowNodeCount) {
            nodePriorityLow[curLowNodeCount] = nodeInfo;
            curLowNodeCount++;
        }
    }

    // CLOUD.Logger.time("collectNodeInfo");
    var priorityCategories = manager.getCategoriesFromHighPriority("outer");
    if (indoor === true) {
        priorityCategories = manager.getCategoriesFromHighPriority("inner");
    }

    var enableOctant = CLOUD.GlobalData.EnableOctant;
    var j, len = 0;
    for (var i = 0; i < cellCount; ++i) {
        var cellId, cellDepth = 0;
        if (enableOctant) {
            cellId = this.visibleOctant[i].octantId;
            cellDepth = this.visibleOctant[i].depth;
        } else {
            cellId = i;
        }
        var cacheCell = cacheCells[cellId];
        if (layerData) {
            if (cacheCell === undefined) {
                // 缓存node数据
                cacheCell = cacheCells[cellId] = [];
            }
            var cell = sceneReader.getCellInfo(cellId);
            for (j = cell.itemIndex; j < cell.itemCount; ++j) {
                this._readItemData(sceneReader, j, cellId, undefined, cellDepth);
            }
            for (j = 0, len = cacheCell.length; j < len; ++j) {
                cacheCell[j].octantId = cellId;
            }
        } else {
            if (cacheCell === undefined) {
                // 缓存node数据
                cacheCell = cacheCells[cellId] = [];
                var cell = sceneReader.getCellInfo(cellId);
                for (j = cell.itemIndex; j < cell.itemCount; ++j) {
                    this._readItemData(sceneReader, j, cellId, undefined, cellDepth);
                }
                for (j = 0, len = cacheCell.length; j < len; ++j) {
                    cacheCell[j].octantId = cellId;
                }
            }
        }
        for (j = 0, len = cacheCell.length; j < len; ++j) {
            collectNodeInfo(cacheCell[j], priorityCategories);
        }
    }

    CLOUD.Logger.timeEnd("collectNodeInfo");
    return curLowNodeCount;
};

CLOUD.Model.prototype.prepare = function (camera) {

    if (CLOUD.GlobalData.BatchMergeEnabled) {
        this._prepareByBatchMerge(camera);
    } else {
        this._prepareByOctree(camera);
    }
};

CLOUD.Model.prototype._prepareByOctree = function (camera) {

    // benchmark @ 20180314
    //console.time("model.prepare");

    if (!this.visible) {

        this.manager.scene.removeObjectGroupByName(this._getWireframeGroupName());
        return;

    }

    var sceneReaderArray = this.loader.getSceneReaderArray();
    var sceneCount = sceneReaderArray ? sceneReaderArray.length : 0;

    if (sceneCount < 1) {
        CLOUD.Logger.log("model load not started!");
        return;
    }

    // // VAAS-100: Mesh and Other resource loading does not sync with reading process,
    // // here do scene prepare after all of them loaded.
    // // TODO: on-demand loading resource like mesh package, scene and material etc.
    // if (!this.loaded) {
    //     console.log("model is not loaded!");
    //     return;
    // }

    var layerData = this.isLayerData();
    if (layerData) {
        if (!this.mpkLoaded) {
            return;
        }
    }

    var sceneReader = sceneReaderArray[0];

    if (!sceneReader) {
        CLOUD.Logger.log("Empty scene");
        return;
    }

    // 先这样调用，采用世界系中的相机视锥，可以避免每次调用.
    this.updateOctreeNode();

    CLOUD.Logger.time("prepareScene");
    // 清除优先级集合
    this._clearNodePriority(false);
    if (this.nodePriority.low.length === 0) {
        this.nodePriority.low.length = this.renderableCount;
    }
    var prioritizedNodeCount = 0;
    var currentLowNodeCount = 0;
    var cellCount = 0;
    var enableOctant = CLOUD.GlobalData.EnableOctant;
    if (enableOctant) {

        var indoor = this.containsCamera;
        if (indoor) {
            //reset octant array before next culling
            this.visibleOctant.length = 0;

            //indoor: spatial first [ keep legacy way: (1) frustum culling on indoor and outdoor (2) logic culling]
            var octreeRootI = this.loader.getOctreeRootNodeInner();
            if (octreeRootI) {

                this._frustumCull(camera, octreeRootI);
            }

            var octreeRootNodeO = this.loader.getOctreeRootNodeOuter();
            if (octreeRootNodeO) {

                this._frustumCull(camera, octreeRootNodeO);
            }
            cellCount = this.visibleOctant.length;
            if (cellCount > 0) {

                this._sortVisibleOctant(camera);
                currentLowNodeCount = this._logicCull(sceneReader, indoor, currentLowNodeCount, cellCount);
            }

        } else {

            // outdoor first [ (1) frustum culling  followed by logic culling on outdoor (2) same way on indoor]
            var octreeRootNodeO = this.loader.getOctreeRootNodeOuter();
            if (octreeRootNodeO) {

                //reset octant array before next culling
                this.visibleOctant.length = 0;
                this._frustumCull(camera, octreeRootNodeO);
                cellCount = this.visibleOctant.length;
                if (cellCount > 0) {

                    this._sortVisibleOctant(camera);
                    currentLowNodeCount = this._logicCull(sceneReader, indoor, currentLowNodeCount, cellCount);
                }
            }
            prioritizedNodeCount = currentLowNodeCount + this.nodePriority.high.length + this.nodePriority.medium.length;

            // then indoor
            CLOUD.Logger.log("mesh count outdoor:", prioritizedNodeCount);
            //BIMFACEDM-3857 prioritizedNodeCount contains lowpriority node, but there exist
            // case that inner node should be render such as transparent outdoor nodes.
            // So, if user promote node's pool priority, we'd traverse them.
            var filter = this.manager.filter;
            if (prioritizedNodeCount < this.renderableCount || filter._hasRenderPromotionFilter()) {

                var octreeRootI = this.loader.getOctreeRootNodeInner();
                if (octreeRootI) {
                    //reset octant array before next culling
                    this.visibleOctant.length = 0;
                    this._frustumCull(camera, octreeRootI);
                    cellCount = this.visibleOctant.length;
                    if (cellCount > 0) {

                        this._sortVisibleOctant(camera);
                        currentLowNodeCount = this._logicCull(sceneReader, indoor, currentLowNodeCount, cellCount);
                    }
                }
            }
        }
    } else {
        // read scene without space partition
        cellCount = sceneReader.header.cellCount;
        if (cellCount === 0) {
            return;
        }
        currentLowNodeCount = this._logicCull(sceneReader, true, currentLowNodeCount, cellCount);
    }
    prioritizedNodeCount = currentLowNodeCount + this.nodePriority.high.length + this.nodePriority.medium.length;

    this._updateTextureMapping();

    CLOUD.Logger.time("updateMeshNodes");
    if (prioritizedNodeCount > this.renderableCount) {
        prioritizedNodeCount = this.renderableCount;
    }
    this._updateMeshNodes(prioritizedNodeCount);
    CLOUD.Logger.timeEnd("updateMeshNodes");

    this.setupWireframe();

    if (CLOUD.GlobalData.Instance) {
        this.setupInstanceWireframe();
        for (var key in this.instanceUpdateMap) {
            this._setupInstanceNodes(key);
            this._setupInstanceWireframeNodes(key);
        }

        this.instanceUpdateMap = {};

    }

    this._occlusionTest();

    CLOUD.Logger.log("mesh count:", this.pool.counter, prioritizedNodeCount);
    CLOUD.Logger.timeEnd("prepareScene");

    // benchmark @ 20180314
    //console.timeEnd("model.prepare");
};

CLOUD.Model.prototype.clearCells = function () {
    this.cache.cells = {};
};

CLOUD.Model.prototype.dispatchEvent = function (event) {
    this.manager.dispatchEvent(event);
};

CLOUD.Model.prototype.parse = function (json) {

    var dataView = json.view;

    //没有重转过得默认可加载贴图
    if(json.count.texture_pixels && json.count.texture_pixels > CLOUD.GlobalData.MaxTexturePixels)
        CLOUD.GlobalData.EnableTextureLoading = false;
        
    //
    if (json.count !== undefined) {

        if (json.count.mesh_face !== undefined) {
            this.numOfTriangles += json.count.mesh_face;
        }

        this.renderableTotal = 0;
        if ((json.count.geom_box !== undefined)
            && (json.count.geom_pipe !== undefined)
            && (json.count.geom_tube !== undefined)
            && (json.count.mesh !== undefined)) {

            this.renderableTotal += json.count.geom_box;
            this.renderableTotal += json.count.geom_pipe;
            this.renderableTotal += json.count.geom_tube;
            this.renderableTotal += json.count.mesh;

            this.numOfTriangles += json.count.geom_box * 12;  // BoxBufferGeometry
            this.numOfTriangles += json.count.geom_pipe * 32; // CylinderBufferGeometry
            this.numOfTriangles += json.count.geom_tube * 32; // CylinderBufferGeometry

        } else if ((json.count.geom !== undefined)
            && (json.count.mesh !== undefined)) {

            this.renderableTotal += json.count.geom;
            this.renderableTotal += json.count.mesh;

            // Pipe and box is not notified in legacy data, so we use box as a estimated statics which is less than
            // real number of triangles..
            this.numOfTriangles += json.count.geom * 12;  // BoxBufferGeometry

            // Legacy data does not contain the number of elements, we use the data of render primitives.
            this.numOfElements = this.renderableTotal;
        }

        if (json.count.item !== undefined) {
            this.numOfElements = json.count.item;
        }

        // console.log("numOfTriangles", this.numOfTriangles);
    }

    if (this.parseCfgFinish !== undefined) {
        this.parseCfgFinish();
    }

    // 未定义或者1，表示Octree数据是经过变换的, 否则，没有变换
    // 如果octree没有经过变换，则进行变换
    if (dataView.transform !== 0) {
        this.transformed = true;
    } else {
        this.transformed = false;
    }

    this.boundingBoxWorld = CLOUD.Utils.box3FromArray(dataView.bbox);

    if (dataView.rotation) {

        var euler = new THREE.Euler();
        euler.fromArray(dataView.rotation);
        this.rotation.setFromEuler(euler, false);

    }

    if (dataView.position) {
        this.position.fromArray(dataView.position);
    }

    if (dataView.scale) {
        this.scale.fromArray(dataView.scale);
    }

    this.transformMatrix.compose(this.position, this.rotation, this.scale);

    this.manager.updateScene();
};

CLOUD.Model.prototype.getTextures = function () {
    return this.cache.textures;
};

CLOUD.Model.prototype.getMaterials = function () {
    return this.cache.materials;
};

CLOUD.Model.prototype.updateMaterials = function () {

    var materials = this.cache.materials;
    for (var id in materials) {
        if (materials.hasOwnProperty(id)) {
            var material = materials[id];
            material.IBLMaps = this.manager.scene.IBLMaps;
            material.refreshUniforms();
        }
    }

};

CLOUD.Model.prototype.updateMaterialsValue = function (type, value) {

    var materials = this.cache.materials;
    var instanceMaterials = this.cache.instance.materials;
    var material ;
    for (var id in materials) {
        material = materials[id];
        if (material) {
            if (material[type]) {
                material[type] = value;
                if (material.refreshUniforms !== undefined) {
                    material.refreshUniforms();
                }
                material.needsUpdate = true;
            }
        }

        material = instanceMaterials[id];

        if (material) {
            if (material instanceof Array) {
                for (var i = 0, len = material.length; i < len; i++) {
                    if (material[i][type]) {
                        material[i][type] = value;
                        if (material[i].refreshUniforms !== undefined) {
                            material[i].refreshUniforms();
                        }
                        material[i].needsUpdate = true;
                    }
                }

            } else {
                if (material[type]) {
                    material[type] = value;
                    if (material.refreshUniforms !== undefined) {
                        material.refreshUniforms();
                    }
                    material.needsUpdate = true;
                }
            }
        }

    }
    
};

CLOUD.Model.prototype.switchNewStyleMaterial = function (newStyle) {

    var materials = this.cache.materials;
    for (var id in materials) {
        if (materials.hasOwnProperty(id)) {
            var material = materials[id];
            var materialParameters = CLOUD.MaterialUtil.getMaterialParameters(material);
            var newMaterials;
            if (newStyle) {
                newMaterials = CLOUD.MaterialUtil.createNewStyleMaterial(materialParameters);
            }
            else {
                newMaterials = CLOUD.MaterialUtil.createStandardMaterial(materialParameters);
            }

            newMaterials.name = id;
            materials[id] = newMaterials;
            materialParameters = null;

        }
    }

};

CLOUD.Model.prototype.changeAllMaterials = function (isIBL) {

    var materials = this.cache.materials;
    for (var id in materials) {
        if (materials.hasOwnProperty(id)) {
            var material = materials[id];
            var materialParameters = CLOUD.MaterialUtil.getMaterialParameters(material);
            var newMaterials;
            if (isIBL) {
                newMaterials = new ImageBasedLighting.IBLMaterial(materialParameters);
                newMaterials.type = 'IBL';
                newMaterials.refreshUniforms();
            }
            else {
                delete materialParameters.iblProbe;
                newMaterials = CLOUD.MaterialUtil.createStandardMaterial(materialParameters);
                newMaterials.roughness = materialParameters.originRoughness;
                newMaterials.metalness = materialParameters.originMetalness;
                newMaterials.refreshUniforms();
            }

            newMaterials.name = id;
            materials[id] = newMaterials;
            materialParameters = null;

        }
    }

};

CLOUD.Model.prototype.getReferencedMeshCache = function () {
    return this.referencedMeshCache;
};

CLOUD.Model.prototype.isLoaded = function () {
    return this.loaded;
};

CLOUD.Model.prototype.isVisible = function () {
    return this.visible;
};

CLOUD.Model.prototype.setVisible = function (visible) {
    this.visible = visible;
};

CLOUD.Model.prototype.calculateCameraModelRelation = function (cameraPos) {

    // BIMFACEDM-2821, let's detect inner bound, then outer bound.
    // In some small scale model, inner root does not exist.
    var modelBound = this.loader.getOctreeRootNodeInner();
    if (!modelBound) {
        modelBound = this.loader.getOctreeRootNodeOuter();
    }

    if (cameraPos.x < modelBound.min.x || cameraPos.x > modelBound.max.x ||
        cameraPos.y < modelBound.min.y || cameraPos.y > modelBound.max.y ||
        cameraPos.z < modelBound.min.z || cameraPos.z > modelBound.max.z) {
        // camera is outside of model's bound box
        this.containsCamera = false;
    } else {
        this.containsCamera = true;
    }
};

CLOUD.Model.prototype.getBoundingBoxWorld = function () {

    return this.boundingBoxWorld;
};

CLOUD.Model.prototype.getRenderableTotal = function () {

    return this.renderableTotal;
};

CLOUD.Model.prototype.setRenderableCount = function (count) {

    this.renderableCount = count;
    this._clearNodePriority(true);
};

CLOUD.Model.prototype.addCamera = function (camera) {
    this.cameraList.push(camera);
};

CLOUD.Model.prototype.getCameraNameList = function () {
    var names = [];
    for (var i = this.cameraList.length - 1; i >= 0; i--) {
        names.push(this.cameraList[i].name);
    }

    return names;
};

CLOUD.Model.prototype.getCamera = function (name) {
    for (var i = this.cameraList.length - 1; i >= 0; i--) {
        if (this.cameraList[i].name === name) {
            return this.cameraList[i];
        }
    }

    return null;
};

/**
 * 获得默认场景变换矩阵 - 兼容处理，以后要删除
 *
 */
CLOUD.Model.prototype.getTransformMatrix = function () {
    return this.transformMatrix;
};

CLOUD.Model.prototype.isEmptyScene = function () {
    return this.emptyScene;
};

/**
 * 更新 coctree 数据
 *
 */
CLOUD.Model.prototype.updateOctreeNode = (function () {

    var boundingBox = new THREE.Box3();

    function updateNode(node, matrix) {

        //boundingBox.set(node.min, node.max);
        boundingBox.copy(node.boundingBoxWorld);
        boundingBox.applyMatrix4(matrix);

        node.min.copy(boundingBox.min);
        node.max.copy(boundingBox.max);

        node.center = boundingBox.getCenter();
        node.size = boundingBox.getSize().lengthSq();
    }

    function traverse(parent, matrix) {

        for (var i = 0, len = parent.childOctants.length; i < len; ++i) {

            var child = parent.childOctants[i];
            updateNode(child, matrix);
            traverse(child, matrix);
        }
    }

    return function (force) {

        var scope = this;
        var matrixRoot = scope.manager.scene.getMatrixGlobal();

        if (force || this.firstOctreeTransform) {

            if (this.firstOctreeTransform) {
                this.firstOctreeTransform = false;
            }

            var octRootNodeOuter = scope.loader.getOctreeRootNodeOuter();

            if (octRootNodeOuter) {

                updateNode(octRootNodeOuter, matrixRoot);
                traverse(octRootNodeOuter, matrixRoot);
            }

            var octRootNodeInner = scope.loader.getOctreeRootNodeInner();

            if (octRootNodeInner) {

                updateNode(octRootNodeInner, matrixRoot);
                traverse(octRootNodeInner, matrixRoot);
            }
        }

    }
})();

CLOUD.Model.prototype.setLayerData = function (layer) {
    this.layerData = layer;
};

CLOUD.Model.prototype.isLayerData = function () {
    return this.layerData;
};

CLOUD.Model.prototype.isDataReady = function () {

    if (CLOUD.GlobalData.BatchMergeEnabled) {
        //return this.dataReady;
        return this._dataMergeFinished;
    }

    return this.loaded && !this.emptyScene;
};

/**
 * 加载模型
 *
 * @param {Function} progressCallback(doingCount, itemCount) - 数据加载过程中的回调
 * @param {Function} finishCallback() - 数据加载完成后的回调
 */
CLOUD.Model.prototype.loadMpkOnDemand = function (progressCallback, finishCallback) {
    var scope = this;
    if (this.isLayerData()) {
        var idx = this.getNeedLoadedMpkIdxs();
        if (idx.length > 0) {
            this.mpkLoaded = false;
            this.loader.loadMpkOnDemand(idx, progressCallback, function () {
                scope.mpkLoaded = true;
                finishCallback && finishCallback();
            });
        } else {
            scope.mpkLoaded = true;
            finishCallback && finishCallback();
        }
    }
};

/**
 * 获得需要加载的mpk索引集合
 *
 */
CLOUD.Model.prototype.getNeedLoadedMpkIdxs = function () {
    var layerData = this.getLayerDataOnDemand();
    var mpkIdxs = [];
    for (var i = 0, len = layerData.mpkIdxs.length; i < len; ++i) {
        var idx = layerData.mpkIdxs[i];
        if (this.cache.mpkIdxs.indexOf(idx) === -1) {
            this.cache.mpkIdxs.push(idx);
            mpkIdxs.push(idx);
        }
    }
    return mpkIdxs;
};

/**
 * 获得按需加载数据的包围盒集合
 *
 */
CLOUD.Model.prototype.getBoundingBoxesOnDemand = function () {
    return this.getLayerDataOnDemand().boundingBoxes;
};

/**
 * 获得按需加载数据的包围盒
 *
 */
CLOUD.Model.prototype.getUnionBoundingBoxesOnDemand = function () {
    var boundingBoxes = this.getBoundingBoxesOnDemand();
    var boundingBox = new THREE.Box3();
    for (var i = 0, len = boundingBoxes.length; i < len; ++i) {
        boundingBox.union(boundingBoxes[i]);
    }
    return boundingBox;
};

/**
 * 获得按需加载条件
 *
 */
CLOUD.Model.prototype.getConditionsOnDemandLoad = function () {
    return this.manager.getConditionsOnDemandLoad();
};

/**
 * 按需加载条件是否发生变化
 *
 */
CLOUD.Model.prototype.isConditionsChanged = function () {
    return this.conditionsChanged;
};

/**
 * 按需加载条件变化状态
 *
 */
CLOUD.Model.prototype.setConditionsChanged = function (change) {
    this.conditionsChanged = change;
};

/**
 * 获得按需加载数据的
 *
 */
CLOUD.Model.prototype.getLayerDataOnDemand = function () {
    if (this.isConditionsChanged() || (!this.currentLayerData)) {
        var conditionsOnDemandLoad = this.getConditionsOnDemandLoad();
        var mpkIdxs = [], boundingBoxes = [];
        var box, idxs, i, len;
        var traverseLayerData;
        if (conditionsOnDemandLoad) {
            traverseLayerData = conditionsOnDemandLoad;
        } else {
            traverseLayerData = this.layerDataCache;
        }
        for (var key in traverseLayerData) {
            if (traverseLayerData.hasOwnProperty(key)) {
                if (this.layerDataCache[key]) {
                    box = this.layerDataCache[key].boundingBox;
                    idxs = this.layerDataCache[key].mpkIdxs;
                    for (i = 0, len = idxs.length; i < len; ++i) {
                        mpkIdxs.push(idxs[i]);
                    }
                    boundingBoxes.push(box);
                }
            }
        }
        this.currentLayerData = {boundingBoxes: boundingBoxes, mpkIdxs: mpkIdxs};
        this.setConditionsChanged(false);
    }
    return this.currentLayerData;
};

/**
 * 缓存按需加载数据的包围盒和mpk索引集合
 *
 */
CLOUD.Model.prototype._cacheLayerData = function (key, mpkInfo) {
    this.layerDataCache[key] = mpkInfo;
};

CLOUD.Model.prototype.isUserIdExist = function (userId) {

    // 'this.userIds' is used to check if 'userId' offered by client is valid or not.
    // for example: viewer.setSelection

    if (this.mapUserIdToNodeInfos[userId] === void 0) {
        return false;
    }
    return true;
};

// 按 cellId 缓存 node info
CLOUD.Model.prototype._cacheNodeInfoByCellId = function (cellId, nodeInfo) {
    if (this.cache.cells[cellId] === void 0) {
        this.cache.cells[cellId] = [];
    }
    this.cache.cells[cellId].push(nodeInfo);

    this.manager.addNodeInfoToCellMap(cellId, nodeInfo); ///
};

// 按 userId 缓存 node info
CLOUD.Model.prototype._cacheNodeInfoByUserId = function (userId, nodeInfo) {
    if (this.mapUserIdToNodeInfos[userId] === void 0) {
        this.mapUserIdToNodeInfos[userId] = [];
    }
    this.mapUserIdToNodeInfos[userId].push(nodeInfo);
};

CLOUD.Model.prototype._cacheMeshNodesByMaterialId = function (materialId, mesh, withUv) {

    if (this.mapMaterialIdToMeshNodes[materialId] === void 0) {
        this.mapMaterialIdToMeshNodes[materialId] = {};
    }

    var uvProp = withUv ? '1' : '0';
    if (this.mapMaterialIdToMeshNodes[materialId][uvProp] === void 0) {
        this.mapMaterialIdToMeshNodes[materialId][uvProp] = [];
    }
    this.mapMaterialIdToMeshNodes[materialId][uvProp].push(mesh);
};

CLOUD.Model.prototype._cacheGeometry = function (geometryId, geometry) {
    if (this.cache.geometries[geometryId] === void 0) {
        this.cache.geometries[geometryId] = geometry;
        if (CLOUD.GlobalData.InitWireframeData) {
            this._initWireframeData(geometryId, geometryId);
        }
    }
};

CLOUD.Model.prototype._createGeometry = function (nodeInfo, batchMergeEnabled) {

    var geometry = null;

    if (nodeInfo.instanceOrNot) {
        geometry = this._createBufferGeometry(nodeInfo, false);
        if (geometry) {
            this._cacheGeometry(nodeInfo.geometryId, geometry);
            if (batchMergeEnabled) {
                if (geometry instanceof Array) {
                    for (var i = 0, len = geometry.length; i < len; i++) {
                        var mesh = new CLOUD.MeshEx(geometry[i]);
                        var sceneMatrix = this.manager.getScene().getMatrixGlobal();
                        var parameters;
                        parameters = {
                            userId: nodeInfo.name,
                            matrix: sceneMatrix.multiply(nodeInfo.matrix),
                            databagId: this.databagId,
                            userData: nodeInfo.userData
                        };
                        mesh.spawn(parameters);
                        mesh.nodeId = nodeInfo.nodeId;
                        // 用于pick
                        this.manager.addNodeInfoToCellMap(nodeInfo.cellId, mesh);
                    }
                } else {
                    var mesh = new CLOUD.MeshEx(geometry);
                    var sceneMatrix = this.manager.getScene().getMatrixGlobal();
                    var parameters;
                    parameters = {
                        userId: nodeInfo.name,
                        matrix: sceneMatrix.multiply(nodeInfo.matrix),
                        databagId: this.databagId,
                        userData: nodeInfo.userData
                    };
                    mesh.spawn(parameters);
                    mesh.nodeId = nodeInfo.nodeId;
                    // 用于pick
                    this.manager.addNodeInfoToCellMap(nodeInfo.cellId, mesh);
                }
            }
        }
        this._createInstanceGeometry(nodeInfo);
    } else {
        geometry = this._createBufferGeometry(nodeInfo, batchMergeEnabled);
        if (geometry) {
            if (batchMergeEnabled) {
                this._cacheGeometry(nodeInfo.nodeId, geometry);
                var mesh = new CLOUD.MeshEx(geometry);
                var sceneMatrix = this.manager.getScene().getMatrixGlobal();
                var parameters;
                parameters = {
                    userId: nodeInfo.name,
                    matrix: sceneMatrix,
                    databagId: this.databagId,
                    userData: nodeInfo.userData
                };
                mesh.spawn(parameters);
                mesh.nodeId = nodeInfo.nodeId;
                // 用于pick
                this.manager.addNodeInfoToCellMap(nodeInfo.cellId, mesh);
                this._cacheMeshNodesByMaterialId(nodeInfo.materialId, mesh, nodeInfo.uv);
            } else {
                this._cacheGeometry(nodeInfo.geometryId, geometry);
            }
        }
    }
};

CLOUD.Model.prototype._setupInstanceWireframeNodes = function (geometryId) {

    var instanceWireframeGeometryGroup = this.manager.scene.getOrCreateObjectGroup(CLOUD.ObjectGroupType.INSTANCEWIREFRAMEGEOMETRY, {globalSpace: true});
    var cachedInstance = this.cache.instance;
    var mapState = cachedInstance.vState[geometryId];

    for (var mId in mapState) {
        var instanceWireframeNode;
        var wireframeGeometries = cachedInstance.wireframeGeometries;

        // 可能被过滤器过滤
        if (!wireframeGeometries[geometryId] || !wireframeGeometries[geometryId][mId]) {
            continue;
        }

        var instanceWireframeGeometry = wireframeGeometries[geometryId][mId];

        if (instanceWireframeGeometry instanceof Array) {
            // geometryId === 'boxM'
            var instanceWireframeNode = new Array(instanceWireframeGeometry.length);
            for (var i = 0, iLen = instanceWireframeGeometry.length; i < iLen; i++) {
                instanceWireframeGeometry[i].addAttribute('vState', new THREE.InstancedBufferAttribute(
                    new Float32Array(cachedInstance.vState[geometryId][mId]), 1, 1
                ));
                instanceWireframeGeometry[i].addAttribute('mcol0', new THREE.InstancedBufferAttribute(
                    new Float32Array(cachedInstance.mcol0[geometryId][mId]), 3, 1
                ));
                instanceWireframeGeometry[i].addAttribute('mcol1', new THREE.InstancedBufferAttribute(
                    new Float32Array(cachedInstance.mcol1[geometryId][mId]), 3, 1
                ));
                instanceWireframeGeometry[i].addAttribute('mcol2', new THREE.InstancedBufferAttribute(
                    new Float32Array(cachedInstance.mcol2[geometryId][mId]), 3, 1
                ));
                instanceWireframeGeometry[i].addAttribute('mcol3', new THREE.InstancedBufferAttribute(
                    new Float32Array(cachedInstance.mcol3[geometryId][mId]), 3, 1
                ));
                instanceWireframeNode[i] = new THREE.LineSegments(instanceWireframeGeometry[i], this.instanceWireframeMaterial);
                instanceWireframeNode[i].frustumCulled = false;
            }
        } else {
            instanceWireframeGeometry.addAttribute('vState', new THREE.InstancedBufferAttribute(
                new Float32Array(cachedInstance.vState[geometryId][mId]), 1, 1
            ));
            instanceWireframeGeometry.addAttribute('mcol0', new THREE.InstancedBufferAttribute(
                new Float32Array(cachedInstance.mcol0[geometryId][mId]), 3, 1
            ));
            instanceWireframeGeometry.addAttribute('mcol1', new THREE.InstancedBufferAttribute(
                new Float32Array(cachedInstance.mcol1[geometryId][mId]), 3, 1
            ));
            instanceWireframeGeometry.addAttribute('mcol2', new THREE.InstancedBufferAttribute(
                new Float32Array(cachedInstance.mcol2[geometryId][mId]), 3, 1
            ));
            instanceWireframeGeometry.addAttribute('mcol3', new THREE.InstancedBufferAttribute(
                new Float32Array(cachedInstance.mcol3[geometryId][mId]), 3, 1
            ));
            instanceWireframeNode = new THREE.LineSegments(instanceWireframeGeometry, this.instanceWireframeMaterial);
            instanceWireframeNode.frustumCulled = false;
        }

        if (!this.instanceWireframeNode[geometryId]) {
            this.instanceWireframeNode[geometryId] = {};
        }
        this.instanceWireframeNode[geometryId][mId] = instanceWireframeNode;
    }

    var mapInstanceWireframeNodes = this.instanceWireframeNode[geometryId];

    for (var mId in mapInstanceWireframeNodes) {
        var instanceWireframeNode = mapInstanceWireframeNodes[mId];
        if (instanceWireframeNode instanceof Array) {
            for (var i = 0, iLen = instanceWireframeNode.length; i < iLen; i++) {
                instanceWireframeGeometryGroup.add(instanceWireframeNode[i]);
                instanceWireframeNode[i].updateMatrixWorld();
            }
        } else {
            instanceWireframeGeometryGroup.add(instanceWireframeNode);
            instanceWireframeNode.updateMatrixWorld();
        }
    }
};

CLOUD.Model.prototype._setupInstanceNodes = function (geometryId) {

    var instanceGeometryGroup = this.manager.scene.getOrCreateObjectGroup(CLOUD.ObjectGroupType.INSTANCEGEOMETRY, {globalSpace: true});
    var cache = this.cache;
    var cachedInstance = cache.instance;
    var mapState = cachedInstance.vState[geometryId];
    var i, j, k;
    var iLen, jLen, kLen;

    for (var mId in mapState) {
        var instanceMaterials = cachedInstance.materials[mId];
        if (!instanceMaterials) {
            instanceMaterials = [];
            var materialParameters = CLOUD.MaterialUtil.getMaterialParameters(cache.materials[mId]);
            var oriTransparent = materialParameters.transparent;
            var opaqueMaterial = CLOUD.MaterialUtil.createInstanceMaterial(materialParameters, true);
            opaqueMaterial.transparent = false;

            var transparentMaterial = CLOUD.MaterialUtil.createInstanceMaterial(materialParameters, true);
            transparentMaterial.transparent = true;
            transparentMaterial.depthWrite = false;

            if (oriTransparent === opaqueMaterial.transparent){
                opaqueMaterial._primary = true;
                transparentMaterial._primary = false;
            } else {
                opaqueMaterial._primary = false;
                transparentMaterial._primary = true;
            }

            instanceMaterials.push(opaqueMaterial);
            instanceMaterials.push(transparentMaterial);
            cachedInstance.materials[mId] = instanceMaterials;
        }

        var instanceGeometries = cachedInstance.geometries[geometryId][mId];
        if (!instanceGeometries) {
            continue;
        }

        var instanceNodeArray = [];
        var instanceNode;

        var attributeMcol0 = new THREE.InstancedBufferAttribute(
            new Float32Array(cachedInstance.mcol0[geometryId][mId]), 3, 1
        );
        var attributeMcol1 = new THREE.InstancedBufferAttribute(
            new Float32Array(cachedInstance.mcol1[geometryId][mId]), 3, 1
        );
        var attributeMcol2 = new THREE.InstancedBufferAttribute(
            new Float32Array(cachedInstance.mcol2[geometryId][mId]), 3, 1
        );
        var attributeMcol3 = new THREE.InstancedBufferAttribute(
            new Float32Array(cachedInstance.mcol3[geometryId][mId]), 3, 1
        );

        var attributeMuvCol0Array = [];
        var attributeMuvCol1Array = [];
        var attributeMuvCol2Array = [];

        if (cachedInstance.muvCol0[geometryId]) {
            for (i = 0, iLen = cachedInstance.muvCol0[geometryId][mId].length; i < iLen; i++ ) {
                attributeMuvCol0Array.push(new THREE.InstancedBufferAttribute(
                    new Float32Array(cachedInstance.muvCol0[geometryId][mId][i]), 2, 1
                ));
                attributeMuvCol1Array.push(new THREE.InstancedBufferAttribute(
                    new Float32Array(cachedInstance.muvCol1[geometryId][mId][i]), 2, 1
                ));
                attributeMuvCol2Array.push(new THREE.InstancedBufferAttribute(
                    new Float32Array(cachedInstance.muvCol2[geometryId][mId][i]), 2, 1
                ));
            }
        }

        for (j = 0,jLen = instanceMaterials.length; j < jLen; j++ ){

            var instanceGeometry = instanceGeometries[j];
            var instanceMaterial = instanceMaterials[j];

            if (instanceGeometry instanceof Array) {
                instanceMaterial.defines["USE_INSTANCE_MUVCOL"] = "";
                instanceNode = new Array(instanceGeometry.length);

                for (i = 0, iLen = instanceGeometry.length; i < iLen; i++) {
                    instanceGeometry[i].addAttribute('mcol0', attributeMcol0);
                    instanceGeometry[i].addAttribute('mcol1', attributeMcol1);
                    instanceGeometry[i].addAttribute('mcol2', attributeMcol2);
                    instanceGeometry[i].addAttribute('mcol3', attributeMcol3);

                    instanceGeometry[i].addAttribute('muvCol0', attributeMuvCol0Array[i]);
                    instanceGeometry[i].addAttribute('muvCol1', attributeMuvCol1Array[i]);
                    instanceGeometry[i].addAttribute('muvCol2',attributeMuvCol2Array[i]);

                    instanceGeometry[i].addAttribute('aColor', new THREE.InstancedBufferAttribute(
                        new Float32Array(cachedInstance.vColor[geometryId][mId]), 4, 1
                    ));
                    instanceGeometry[i].addAttribute('vState', new THREE.InstancedBufferAttribute(
                        new Float32Array(cachedInstance.vState[geometryId][mId]), 1, 1
                    ));

                    if (!instanceMaterial._primary) {
                        var vState = instanceGeometry[i].getAttribute("vState").array;
                        for (k = 0, kLen = vState.length; k < kLen; k++) {
                            vState[k] = CLOUD.EnumInstanceState.HIDDEN;
                        }
                    }

                    var instanceNodeBoxM = new THREE.Mesh(instanceGeometry[i], instanceMaterial);
                    instanceNodeBoxM.frustumCulled = false;
                    instanceNode[i] = instanceNodeBoxM;
                }

            } else {

                instanceGeometry.addAttribute('mcol0', attributeMcol0);
                instanceGeometry.addAttribute('mcol1', attributeMcol1);
                instanceGeometry.addAttribute('mcol2', attributeMcol2);
                instanceGeometry.addAttribute('mcol3', attributeMcol3);

                instanceGeometry.addAttribute('aColor', new THREE.InstancedBufferAttribute(
                    new Float32Array(cachedInstance.vColor[geometryId][mId]), 4, 1
                ));
                instanceGeometry.addAttribute('vState', new THREE.InstancedBufferAttribute(
                    new Float32Array(cachedInstance.vState[geometryId][mId]), 1, 1
                ));

                if (!instanceMaterial._primary) {
                    var vState = instanceGeometry.getAttribute("vState").array;
                    for (k = 0, kLen = vState.length; k < kLen; k++) {
                        vState[k] = CLOUD.EnumInstanceState.HIDDEN;
                    }
                }

                instanceNode = new THREE.Mesh(instanceGeometry, instanceMaterial);
                instanceNode.frustumCulled = false;
            }

            instanceNodeArray.push(instanceNode);
        }

        if (!this.instanceNode.hasOwnProperty(geometryId)) {
            this.instanceNode[geometryId] = {};
        }
        this.instanceNode[geometryId][mId] = instanceNodeArray;
    }

    var instanceNodes = this.instanceNode[geometryId];

    for (var key in instanceNodes) {
        var instanceNodeArray = instanceNodes[key];

        for (var j = 0, jLen = instanceNodeArray.length; j < jLen; j++) {
            instanceNode = instanceNodeArray[j];
            if (instanceNode instanceof Array) {
                for (var i = 0, iLen = instanceNode.length; i < iLen; ++i) {
                    instanceGeometryGroup.add(instanceNode[i]);
                    instanceNode[i].updateMatrixWorld();
                }
            } else {
                instanceGeometryGroup.add(instanceNode);
                instanceNode.updateMatrixWorld();
            }
        }
    }
};

CLOUD.Model.prototype.getNodeInfosByUserId = function (uid) {
    if (this.mapUserIdToNodeInfos) {
        return this.mapUserIdToNodeInfos[uid];
    }
    return null;
};

CLOUD.Model.prototype.getNodeInfos = function () {
    var retNodeInfos = {};
    for(var id in this.mapUserIdToNodeInfos){
        retNodeInfos[id]={
            userData : this.mapUserIdToNodeInfos[id][0].userData,
            state : CLOUD.EnumObjectState.Visible,
            material : null
        };
    }
    return retNodeInfos;
};

CLOUD.Model.prototype.isHiddenUserId = function (uid) {
    if (this.hiddenUserIdSetObject && this.hiddenUserIdSetObject[uid]) {
        return true;
    }
    return false;
};

CLOUD.Model.prototype.getInstancedHiddenIds = function () {
    var ids = [];
    if (this.hiddenUserIdSetObject) {
        for (var id in this.hiddenUserIdSetObject) {
            if (this.hiddenUserIdSetObject.hasOwnProperty(id)) {
                ids.push(id);
            }
        }
    }
    return ids;
};

CLOUD.Model.prototype.getInstancedOverrideSetObject = function () {
    return this.overrideUserIdSetObject;
};

CLOUD.Model.prototype.getInstancedSelections = function () {
    return this.instancedUserIdSetForSelection;
};

CLOUD.Model.prototype.getInstancedHoverId = function () {
    return this.instancedUserIdForHover;
};

CLOUD.Model.prototype._collectFilteredUserIds = function () {
    var manager = this.manager;
    var filter = manager.filter;
    var hasHiddenFileIdFilter = filter._hasHiddenFileIdFilter();
    var hasVisibleFilter = filter._hasVisibleFilter();
    var hasOverrideFilter = filter._hasOverrideMaterialFilter();
    var hasTransparentFilter = filter._hasTransparentFilter();
    var objNodes = this.mapUserIdToNodeInfos;
    var i, len;
    var mapUserIds = this.mapMaterialIdToUserIdsForFilter = {};
    this.hiddenUserIdSetObject = {};
    this.overrideUserIdSetObject = {};
    this.transparentUserIdSetObject = {};

    if (hasHiddenFileIdFilter || hasVisibleFilter || hasOverrideFilter || hasTransparentFilter) {
        for (var uid in objNodes) {
            if (objNodes.hasOwnProperty(uid)) {
                var nodeInfos = objNodes[uid];
                if (!nodeInfos) {
                    continue;
                }
                for (i = 0, len = nodeInfos.length; i < len; i++) {
                    var nodeInfo = nodeInfos[i];
                    // 文件过滤,可见性过滤
                    if ((hasHiddenFileIdFilter && filter._isHiddenFileId(nodeInfo)) ||
                        (hasVisibleFilter && (filter._isVisible(nodeInfo) === false))) {
                        if (mapUserIds[nodeInfo.materialId] === void 0) {
                            mapUserIds[nodeInfo.materialId] = {};
                        }
                        if (mapUserIds[nodeInfo.materialId][CLOUD.Model.EnumFilterState.HIDDEN] === void 0) {
                            mapUserIds[nodeInfo.materialId][CLOUD.Model.EnumFilterState.HIDDEN] = {};
                        }
                        mapUserIds[nodeInfo.materialId][CLOUD.Model.EnumFilterState.HIDDEN][uid] = true;
                        this.hiddenUserIdSetObject[uid] = true;//
                        continue;
                    }
                    // 半透明
                    if (hasTransparentFilter && filter._isTransparent(nodeInfo)) {
                        if (mapUserIds[nodeInfo.materialId] === void 0) {
                            mapUserIds[nodeInfo.materialId] = {};
                        }
                        if (mapUserIds[nodeInfo.materialId][CLOUD.Model.EnumFilterState.TRANSPARENT] === void 0) {
                            mapUserIds[nodeInfo.materialId][CLOUD.Model.EnumFilterState.TRANSPARENT] = {};
                        }
                        mapUserIds[nodeInfo.materialId][CLOUD.Model.EnumFilterState.TRANSPARENT][uid] = true;
                        this.transparentUserIdSetObject[uid] = true;
                        continue;
                    }
                    // 材质过滤
                    if (hasOverrideFilter && filter._hasOverrideMaterial(nodeInfo)) {
                        var material = filter._getOverrideMaterial(nodeInfo);
                        var materialName = (material!=null)?material.name:"";
                        if (materialName !== "") {
                            if (mapUserIds[nodeInfo.materialId] === void 0) {
                                mapUserIds[nodeInfo.materialId] = {};
                            }
                            if (mapUserIds[nodeInfo.materialId][CLOUD.Model.EnumFilterState.OVERRIDED] === void 0) {
                                mapUserIds[nodeInfo.materialId][CLOUD.Model.EnumFilterState.OVERRIDED] = {};
                            }
                            mapUserIds[nodeInfo.materialId][CLOUD.Model.EnumFilterState.OVERRIDED][uid] = materialName;
                            this.overrideUserIdSetObject[uid] = materialName;//
                        }
                        continue;
                    }
                }
            }
        }
    }
};

CLOUD.Model.prototype._collectSelectedUserIds = function () {

    var manager = this.manager;
    var selectionSet = manager.sceneState.selectionSet;
    var objNodes = this.mapUserIdToNodeInfos;
    var mapUserIds = this.mapMaterialIdToUserIdsForSelection = {};
    var i, len;
    this.instancedUserIdSetForSelection = [];

    // 选择集
    for (var uid in selectionSet) {
        if (selectionSet.hasOwnProperty(uid)) {
            var nodeInfos = objNodes[uid]; // 外部传入的uid可能不存在
            if (!nodeInfos) {
                continue;
            }
            for (i = 0, len = nodeInfos.length; i < len; i++) {
                var nodeInfo = nodeInfos[i];
                if (nodeInfo.instanceOrNot) {
                    if (this.instancedUserIdSetForSelection.indexOf(uid) === -1) {
                        this.instancedUserIdSetForSelection.push(uid);
                    }
                } else {
                    if (mapUserIds[nodeInfo.materialId] === void 0) {
                        mapUserIds[nodeInfo.materialId] = {};
                    }
                    if (mapUserIds[nodeInfo.materialId][uid] === void 0) {
                        mapUserIds[nodeInfo.materialId][uid] = true;
                    }
                }
            }
        }
    }
};

CLOUD.Model.prototype._collectHoveredUserIds = function () {

    var i, len;
    var sceneState = this.manager.sceneState;
    var uid = sceneState.hoverId;
    var objNodes = this.mapUserIdToNodeInfos;
    var mapUserIds = this.mapMaterialIdToUserIdsForHover = {};

    this.instancedUserIdForHover = undefined;

    if (uid) {
        var nodeInfos = objNodes[uid];
        if (nodeInfos) {
            for (i = 0, len = nodeInfos.length; i < len; i++) {
                var nodeInfo = nodeInfos[i];
                if (nodeInfo.instanceOrNot) {
                    this.instancedUserIdForHover = uid;
                } else {
                    if (mapUserIds[nodeInfo.materialId] === void 0) {
                        mapUserIds[nodeInfo.materialId] = {};
                    }
                    if (mapUserIds[nodeInfo.materialId][uid] === void 0) {
                        mapUserIds[nodeInfo.materialId][uid] = true;
                    }
                }
            }
        }
    }
};

CLOUD.Model.prototype._clearSelections = function () {
    if (this.mapMaterialIdToUserIdsForSelection) {
        this.mapMaterialIdToUserIdsForSelection = null;
    }
    this.instancedUserIdSetForSelection = [];
};

CLOUD.Model.prototype._clearHover = function () {
    if (this.mapMaterialIdToUserIdsForHover) {
        this.mapMaterialIdToUserIdsForHover = null;
    }
    if (this.instancedUserIdForHover) {
        this.instancedUserIdForHover = undefined;
    }
};

// // 设置是否构件选择优先处理
// CLOUD.Model.prototype._setSelectPriority = function (bPriority) {
//     this._selectPriority = bPriority;
// };

// 根据过滤器状态重建mesh索引
CLOUD.Model.prototype._rebuildIndices = function () {

    this._materialList.length = 0;

    for (var mId in this.mapMaterialIdToMergedNode) {

        var mapHidden = null;
        var mapOverrided = null;
        var mapTransparent = null;
        var mapSelected = null;
        var mapHovered = null;
        var i, iLen;

        if (this.mapMaterialIdToUserIdsForSelection && this.mapMaterialIdToUserIdsForSelection[mId]) {
            mapSelected = this.mapMaterialIdToUserIdsForSelection[mId];
        }

        if (this.mapMaterialIdToUserIdsForHover && this.mapMaterialIdToUserIdsForHover[mId]) {
            mapHovered = this.mapMaterialIdToUserIdsForHover[mId];
        }

        if (this.mapMaterialIdToUserIdsForFilter && this.mapMaterialIdToUserIdsForFilter[mId]) {
            mapHidden = this.mapMaterialIdToUserIdsForFilter[mId][CLOUD.Model.EnumFilterState.HIDDEN];
            mapOverrided = this.mapMaterialIdToUserIdsForFilter[mId][CLOUD.Model.EnumFilterState.OVERRIDED];
            mapTransparent = this.mapMaterialIdToUserIdsForFilter[mId][CLOUD.Model.EnumFilterState.TRANSPARENT];
        }

        for (var uvProp in this.mapMaterialIdToMergedNode[mId]) {
            var mergedNode = this.mapMaterialIdToMergedNode[mId][uvProp];
            var indicesGroup = mergedNode['indices'];
            var geometry = mergedNode['geometry'];
            geometry.clearGroups();
            geometry._visible = true; // 置入一个状态

            if (!mapSelected && !mapHidden && !mapOverrided && !mapHovered && !mapTransparent) {
                continue;
            }

            var group = [];

            for (var uid in indicesGroup) {

                if (indicesGroup.hasOwnProperty(uid)) {
                    if ((mapHidden && mapHidden[uid])) {
                        continue;
                    }

                    var nodes = indicesGroup[uid];

                    if (nodes && nodes.length > 0) {

                        // 半透明
                        if (mapTransparent && mapTransparent[uid]) {
                            for (i = 0, iLen = nodes.length; i < iLen; i++) {
                                group.push({
                                    indexStart: nodes[i].indexStart,
                                    indexCount: nodes[i].indexCount,
                                    state: CLOUD.Model.EnumFilterState.TRANSPARENT
                                });
                            }
                            continue;
                        }

                        // 选择
                        if (mapSelected && mapSelected[uid]) {
                            for (i = 0, iLen = nodes.length; i < iLen; i++) {
                                group.push({
                                    indexStart: nodes[i].indexStart,
                                    indexCount: nodes[i].indexCount,
                                    state: CLOUD.Model.EnumFilterState.SELECTED
                                });
                            }
                            continue;
                        }

                        // hover
                        if (mapHovered && mapHovered[uid]) {

                            // 如果存在override，则用override的颜色
                            if (mapOverrided && mapOverrided[uid]) {
                                var matrialName = "hover|" + mapOverrided[uid];
                                var idx = this._materialList.indexOf(matrialName);
                                if (idx === -1) {
                                    this._materialList.push(matrialName);
                                    idx = this._materialList.length - 1;
                                }

                                for (i = 0, iLen = nodes.length; i < iLen; i++) {
                                    group.push({
                                        indexStart: nodes[i].indexStart,
                                        indexCount: nodes[i].indexCount,
                                        state: CLOUD.Model.EnumFilterState.OVERRIDED + idx,
                                    });
                                }
                                continue;
                            } else {
                                for (i = 0, iLen = nodes.length; i < iLen; i++) {
                                    group.push({
                                        indexStart: nodes[i].indexStart,
                                        indexCount: nodes[i].indexCount,
                                        state: CLOUD.Model.EnumFilterState.HOVER
                                    });
                                }
                                continue;
                            }
                        }

                        // override
                        if (mapOverrided && mapOverrided[uid]) {
                            var matrialName = mapOverrided[uid];
                            var idx = this._materialList.indexOf(matrialName);
                            if (idx === -1) {
                                this._materialList.push(matrialName);
                                idx = this._materialList.length - 1;
                            }

                            for (i = 0, iLen = nodes.length; i < iLen; i++) {
                                group.push({
                                    indexStart: nodes[i].indexStart,
                                    indexCount: nodes[i].indexCount,
                                    state: CLOUD.Model.EnumFilterState.OVERRIDED + idx,
                                });
                            }
                            continue;
                        }

                        for (i = 0, iLen = nodes.length; i < iLen; i++) {
                            group.push({indexStart: nodes[i].indexStart, indexCount: nodes[i].indexCount, state: 0});
                        }
                    }
                }
            }

            if (group.length > 0) {
                group.sort(function (a, b) {
                    if (a.state === b.state) {
                        return (a.indexStart - b.indexStart);
                    }
                    return (a.state - b.state);
                });

                for (i = 0, iLen = group.length; i < iLen; i++) {
                    var indexStart = group[i].indexStart;
                    var indexCount = group[i].indexCount;
                    var state = group[i].state;
                    if (i === 0) {
                        geometry.addGroup(indexStart, indexCount, state);
                    } else {
                        var indexStartPre = group[i - 1].indexStart;
                        var indexCountPre = group[i - 1].indexCount;
                        var statePre = group[i - 1].state;
                        var indexStartNext = indexStartPre + indexCountPre;
                        if (state === statePre && indexStart === indexStartNext) {
                            geometry.groups[geometry.groups.length - 1].count += indexCount;
                        } else {
                            geometry.addGroup(indexStart, indexCount, state);
                        }
                    }
                }
            } else {
                geometry._visible = false;
            }
        }
    }
};

// 根据所有的mesh node
CLOUD.Model.prototype._updateMergedMeshNodes = function () {

    var filter = this.manager.filter;
    var cacheMaterials = this.cache.materials;
    var i, iLen;

    if (CLOUD.GlobalData.DrawingStyle != CLOUD.DrawingStyle.BOARDLINE) {

        var selectedMaterial = this.selectedMaterial;
        if (selectedMaterial.transparent) {
            selectedMaterial.depthWrite = false;
        } else {
            selectedMaterial.depthWrite = true;
        }

        var transparentMaterial = filter._getMaterialByName('scene');
        transparentMaterial.depthWrite = false;

        var materialList = [];
        for (i = 0, iLen = this._materialList.length; i < iLen; i++ ) {
            var tmpMaterial;
            var materialName = this._materialList[i];
            var splitName = materialName.split('|');
            if (splitName[0] === 'hover') {
                tmpMaterial = filter._getMaterialByName(splitName[1]);
                tmpMaterial = this.manager.sceneState.getHoverMaterial(tmpMaterial);
            }else {
                tmpMaterial = filter._getMaterialByName(materialName);
            }

            if (tmpMaterial.transparent) {
                tmpMaterial.depthWrite = false;
            } else {
                tmpMaterial.depthWrite = true;
            }
            materialList.push(tmpMaterial);
            // materialList.push(filter._getMaterialByName(this._materialList[i]));
        }

        for (var mId in this.mapMaterialIdToMergedNode) {
            var material = cacheMaterials[mId];
            if (material.transparent) {
                material.depthWrite = false;
            } else {
                material.depthWrite = true;
            }
            var hoveredMaterial = this.manager.sceneState.getHoverMaterial(cacheMaterials[mId]);
            if (hoveredMaterial.transparent) {
                hoveredMaterial.depthWrite = false;
            } else {
                hoveredMaterial.depthWrite = true;
            }
            for (var uvProp in this.mapMaterialIdToMergedNode[mId]) {
                var geometry = this.mapMaterialIdToMergedNode[mId][uvProp]['geometry'];
                if (geometry === null) {
                    continue;
                }
                var mesh = this.mapMaterialIdToMergedNode[mId][uvProp]['mesh'];
                if (geometry._visible) {
                    if (geometry.groups.length > 0) {
                        var usedMaterialList = [material, selectedMaterial, hoveredMaterial, transparentMaterial];
                        for (i = 0, iLen = materialList.length; i < iLen; i++) {
                            usedMaterialList.push(materialList[i]);
                        }
                        mesh.material = usedMaterialList;
                    } else {
                        mesh.material = material;
                    }
                    mesh.visible = true;
                } else {
                    mesh.visible = false;
                }
            }
            material = null;
        }
    }
//instance wireframe
    if (CLOUD.GlobalData.Instance) {
        this.setupInstanceWireframe();
    }
//not instance wireframe
    var wireframeGroupName = this._getWireframeGroupName();
    if (CLOUD.GlobalData.DrawingStyle != CLOUD.DrawingStyle.SHADING) {
        this._generateWireframe();
        this._updateWireframe();

    } else {
        this.manager.scene.removeObjectGroupByName(wireframeGroupName);
    }

};

// 根据过滤器状态重建mesh索引
CLOUD.Model.prototype._rebuildIndicesForWireframe = function () {

    if (!this.mergedLineSegment) {
        return;
    }

    this.mergedLineSegment.visible = true;

    if (this.hiddenUserIdSetObject) {
        var newIndices = [];
        for (var uid in this.mapUserIdToWireframeIndices) {
            if (this.hiddenUserIdSetObject[uid]) {
                continue;
            }
            var nodes = this.mapUserIdToWireframeIndices[uid];
            if (nodes && nodes.length > 0) {
                for (var i = 0, iLen = nodes.length; i < iLen; i++) {
                    var indexStart = nodes[i].indexStart;
                    var indexCount = nodes[i].indexCount;
                    for (var j = indexStart, jLen = indexStart + indexCount; j < jLen; j++) {
                        newIndices.push(this.mergedGeometryIndex.array[j]);
                    }
                }
            }
        }

        if (newIndices.length > 0) {
            this.mergedLineSegment.geometry.setIndex(newIndices);
        } else {
            this.mergedLineSegment.visible = false;
        }
    } else {
        this.mergedLineSegment.geometry.setIndex(this.mergedGeometryIndex);
    }
};

CLOUD.Model.prototype._prepareByBatchMerge = function () {

    if (!this.visible) {
        this.manager.scene.removeObjectGroupByName(this._getWireframeGroupName());
        return;
    }

    this._updateTextureMapping();

};

CLOUD.Model.prototype._prepareData = function (callback) {

    if (this.dataReady === void 0) {

        console.time("deal-data");

        var ok = this._parseItemData();
        if (!ok) {
            return false;
        }

        this.dataReady = true;

        // 释放reader buffer数据
        this.loader.destroyReader();

        this._mergeData(callback);
    }
};

CLOUD.Model.prototype._parseItemData = function () {

    var sceneReaderArray = this.loader.getSceneReaderArray();
    var sceneCount = sceneReaderArray ? sceneReaderArray.length : 0;

    if (sceneCount < 1) {
        CLOUD.Logger.log("model load not started!");
        return false;
    }

    var sceneReader = sceneReaderArray[0];

    if (!sceneReader) {
        CLOUD.Logger.log("Empty scene");
        return false;
    }

    var cellCount = sceneReader.header.cellCount;
    if (cellCount === 0) {
        return false;
    }

    var i, j;
    for (i = 0; i < cellCount; ++i) {
        var cell = sceneReader.getCellInfo(i);
        for (j = cell.itemIndex; j < cell.itemCount; ++j) {
            this._readItemData(sceneReader, j, i, undefined, 0);
        }
    }

    sceneReader = null;
    sceneReaderArray = null;

    return true;
};

CLOUD.Model.prototype._mergeData = function (callback) {

    var mapNodeInfos = {};
    var ids = [];

    for (var uid in this.mapUserIdToNodeInfos) {
        ids.push(uid);
    }

    var scope = this;
    var maxLoadTaskCount = scope.loader.maxLoadTaskCount;
    var loadPercentage = scope.progressPercentage.load;
    var collectPercentage = scope.progressPercentage.collect;
    var idsLength = ids.length;
    var step = Math.ceil(idsLength / scope.progressFrequency);

    function collectNodeInfoBaseOnMaterial(idx) {

        var currIdx = idx;

        return function () {

            var i, j, len, jLen;
            if (currIdx + step > idsLength) {
                jLen = idsLength
            } else {
                jLen = currIdx + step;
            }

            for (j = currIdx; j < jLen; j++) {
                var uid = ids[j];
                var nodeInfos = scope.mapUserIdToNodeInfos[uid];
                for (i = 0, len = nodeInfos.length; i < len; i++) {
                    var nodeInfo = nodeInfos[i];
                    if (nodeInfo.instanceOrNot) {
                        scope._prepareInstanceGeometry(nodeInfo);
                        continue;
                    }
                    scope._createNodeBuffer(nodeInfo);
                    var materialId = nodeInfo.materialId;
                    var uvProp = nodeInfo.uv ? '1' : '0';
                    if (mapNodeInfos[materialId] === void 0) {
                        mapNodeInfos[materialId] = {};
                    }
                    if (mapNodeInfos[materialId][uvProp] === void 0) {
                        mapNodeInfos[materialId][uvProp] = [];
                    }
                    mapNodeInfos[materialId][uvProp].push(nodeInfo);
                }

                if (j === jLen - 1) {
                    if (jLen !== idsLength) {
                        var progress = {
                            total: maxLoadTaskCount,
                            loaded: (j / idsLength * collectPercentage + loadPercentage) * maxLoadTaskCount
                        };
                        scope.dispatchEvent({type: CLOUD.EVENTS.ON_LOAD_PROGRESS, progress: progress});
                        requestAnimationFrame(collectNodeInfoBaseOnMaterial(j + 1));
                    } else {
                        var progress = {
                            total: maxLoadTaskCount,
                            loaded: (collectPercentage + loadPercentage) * maxLoadTaskCount
                        };
                        scope.dispatchEvent({type: CLOUD.EVENTS.ON_LOAD_PROGRESS, progress: progress});
                        scope._mergeGeometry(mapNodeInfos , callback);
                    }
                }
            }
        }
    }

    requestAnimationFrame(collectNodeInfoBaseOnMaterial(0));

};

CLOUD.Model.prototype._mergeGeometry = function (mapNodeInfos, callback) {

    var ids = [];
    for (var mId in mapNodeInfos) {
        ids.push(mId);
    }

    if (ids.length === 0) {
        this._mergeDataFinish(mapNodeInfos, callback);
        return;
    }

    var scope = this;
    var maxLoadTaskCount = this.loader.maxLoadTaskCount;
    var loadPercentage = this.progressPercentage.load;
    var collectPercentage = this.progressPercentage.collect;
    var mergePercentage = this.progressPercentage.merge;
    var idsLength = ids.length;
    var step = Math.ceil(idsLength / this.progressFrequency);

    function doMerge(idx) {

        var tIdx = idx;

        return function () {

            var position, index, normal, uv;
            var i, j, k;
            var len, jLen, kLen;

            if (tIdx + step > idsLength) {
                jLen = idsLength
            } else {
                jLen = tIdx + step;
            }

            for (j = tIdx; j < jLen; j++) {
                var mId = ids[j];

                for (var uvProp in mapNodeInfos[mId]) {
                    var nodeInfos = mapNodeInfos[mId][uvProp];
                    var arrayPositionLength = 0;
                    var arrayIndexLength = 0;
                    var arrayNormalLength = 0;
                    var arrayUVLength = 0;
                    var nodeBuffer = null;

                    if (scope.mapMaterialIdToMergedNode[mId] === void 0) {
                        scope.mapMaterialIdToMergedNode[mId] = {};
                    }
                    if (scope.mapMaterialIdToMergedNode[mId][uvProp] === void 0) {
                        scope.mapMaterialIdToMergedNode[mId][uvProp] = {};
                    }
                    var mergedGeometry = scope.mapMaterialIdToMergedNode[mId][uvProp]['geometry'] = new THREE.BufferGeometry();
                    var indicesGroup = scope.mapMaterialIdToMergedNode[mId][uvProp]['indices'] = {};

                    for (i = 0, len = nodeInfos.length; i < len; i++) {
                        var nodeInfo = nodeInfos[i];
                        nodeBuffer = scope.cachedNodeBuffer[nodeInfo.nodeId];
                        arrayIndexLength += nodeBuffer.index.length;
                        arrayPositionLength += nodeBuffer.position.length;
                        arrayNormalLength += nodeBuffer.normal.length;
                        if (nodeBuffer.uv) {
                            arrayUVLength += nodeBuffer.uv.length;
                        }
                        nodeBuffer = null;
                    }

                    var arrayPosition = new Float32Array( arrayPositionLength );
                    var arrayIndex = new Uint32Array( arrayIndexLength );
                    var arrayNormal = new Float32Array( arrayNormalLength );
                    var arrayUV = new Float32Array( arrayUVLength );
                    var offsetPosition = 0;
                    var offsetIndex = 0;
                    var offsetNormal = 0;
                    var offsetUV = 0;

                    for (i = 0, len = nodeInfos.length; i < len; i++) {
                        var nodeInfo = nodeInfos[i];
                        nodeBuffer = scope.cachedNodeBuffer[nodeInfo.nodeId];
                        index = nodeBuffer.index;
                        position = nodeBuffer.position;
                        normal = nodeBuffer.normal;
                        uv = nodeBuffer.uv;
                        arrayPosition.set( position, offsetPosition );
                        var indexTmp = Uint32Array.from(index);
                        for (k = 0, kLen = indexTmp.length; k < kLen; k++) {
                            indexTmp[k] += offsetPosition / 3;
                        }
                        arrayIndex.set(indexTmp, offsetIndex);

                        // 建立索引表
                        if (indicesGroup[nodeInfo.name] === void 0) {
                            indicesGroup[nodeInfo.name] = [];
                        }
                        indicesGroup[nodeInfo.name].push({
                            userId: nodeInfo.name,
                            nodeId: nodeInfo.nodeId,
                            positionStart:offsetPosition,
                            positionCount:position.length,
                            indexStart: offsetIndex,
                            indexCount: index.length
                        });

                        offsetIndex += index.length;
                        offsetPosition += position.length;

                        arrayNormal.set( normal, offsetNormal );
                        offsetNormal += normal.length;

                        if (uv) {
                            arrayUV.set( uv, offsetUV );
                            offsetUV += uv.length;
                        }

                        index = null;
                        position = null;
                        normal = null;
                        uv = null;
                        nodeBuffer = null;
                    }

                    mergedGeometry._visible = true;
                    mergedGeometry.setIndex(new THREE.BufferAttribute(arrayIndex, 1));
                    mergedGeometry.addAttribute('position', new THREE.BufferAttribute(arrayPosition, 3));
                    mergedGeometry.addAttribute('normal', new THREE.BufferAttribute(arrayNormal, 3));

                    if (offsetUV > 0) {
                        mergedGeometry.addAttribute('uv', new THREE.BufferAttribute(arrayUV, 2));
                    }
                }

                if (j === jLen - 1) {
                    if (jLen !== ids.length) {
                        var progress = {
                            total: maxLoadTaskCount,
                            loaded: (j / idsLength * mergePercentage +  loadPercentage + collectPercentage) * maxLoadTaskCount
                        };
                        scope.dispatchEvent({type: CLOUD.EVENTS.ON_LOAD_PROGRESS, progress: progress});
                        requestAnimationFrame(doMerge(j + 1));
                    } else {
                        scope._mergeDataFinish(mapNodeInfos, callback);
                    }
                }
            }
        }
    }

    requestAnimationFrame(doMerge(0));
};

CLOUD.Model.prototype._mergeDataFinish = function (mapNodeInfos, callback) {

    // clear
    for (var mId in mapNodeInfos) {
        for (var uvProp in mapNodeInfos[mId]) {
            mapNodeInfos[mId][uvProp] = null;
            delete mapNodeInfos[mId][uvProp];
        }
        delete mapNodeInfos[mId];
    }
    mapNodeInfos = null;

    this._clearReferencedMeshCache();
    this._calcRenderingObjectCount();
    this._makeMesh();
    this._updateTextureMapping();

    if (CLOUD.GlobalData.Instance) {
        for (var key in this.instanceUpdateMap) {
            this._setupInstanceNodes(key);
            //this._setupInstanceWireframeNodes(key);
        }
        //this.instanceUpdateMap = {};
    }

    this._dataMergeFinished = true; //

    this.dispatchEvent({type: CLOUD.EVENTS.ON_LOAD_COMPLETE});

    if (callback) {
        callback();
    }

    console.timeEnd("deal-data");
};

CLOUD.Model.prototype._calcRenderingObjectCount = function () {
    var vertexArrayCount = 0;
    var indexArrayCount = 0;
    var materialCount = 0;
    var objectCount = 0;
    for (var mId in this.mapMaterialIdToMergedNode) {
        materialCount++;
        for (var uvProp in this.mapMaterialIdToMergedNode[mId]) {
            var geometry = this.mapMaterialIdToMergedNode[mId][uvProp]['geometry'];
            vertexArrayCount += geometry.attributes.position.array.length;
            indexArrayCount += geometry.index.array.length;
            objectCount++;
        }
    }

    console.log("------------------------------------");
    console.log("materialCount:",materialCount);
    console.log("vertexCount:",vertexArrayCount/3);
    console.log("indexCount:",indexArrayCount);
    console.log("rendering object count:", objectCount);
    console.log("------------------------------------");
};

CLOUD.Model.prototype._makeMesh = function () {

    // var sceneMatrix = this.manager.getScene().getMatrixGlobal();

    var geometryGroup = this.manager.scene.geometryGroup;

    for (var mId in this.mapMaterialIdToMergedNode) {
        for (var uvProp in this.mapMaterialIdToMergedNode[mId]) {
            var geometry = this.mapMaterialIdToMergedNode[mId][uvProp]['geometry'];
            var indices = this.mapMaterialIdToMergedNode[mId][uvProp]['indices'];
            var mesh = new CLOUD.MeshEx(geometry);
            mesh._indicesGroup = indices;

            var parameters;
            parameters = {
                // matrix: sceneMatrix,
                databagId: this.databagId
            };
            mesh.spawn(parameters);

            geometryGroup.add(mesh);

            this.mapMaterialIdToMergedNode[mId][uvProp]['mesh'] = mesh;
            this.manager.addMeshToCellMap(mesh, mId, uvProp);//
            indices = null;
            mesh = null;
        }
    }

};

CLOUD.Model.prototype._destroyAllNodeBuffer = function () {
    for(var nodeId in this.cachedNodeBuffer){
        for (var prop in this.cachedNodeBuffer[nodeId]) {
            this.cachedNodeBuffer[nodeId][prop] = null;
        }
        delete this.cachedNodeBuffer[nodeId];
    }
    this.cachedNodeBuffer = null;
};

CLOUD.Model.prototype._createNodeBuffer = function (nodeInfo) {

    if (!this.cachedNodeBuffer) {
        this.cachedNodeBuffer = {};
    }

    if (this.cachedNodeBuffer[nodeInfo.nodeId]) {
        return;
    }

    var normalMatrix = new THREE.Matrix3();
    var position, index, normal, uv;
    var matrix = nodeInfo.matrix;
    normalMatrix.getNormalMatrix( matrix );
    var nodeItemType = CLOUD.Model.NodeItemType;
    var refMeshCache = this.referencedMeshCache;
    var geometry, dataM;

    switch (nodeInfo.type) {
        case nodeItemType.MESH:
        case nodeItemType.MESH_REF:
            var geometryId = nodeInfo.geometryId;
            if (nodeInfo.type === nodeItemType.MESH_REF) {
                geometryId = geometryId.split("_")[1];
            }
            var geometryInfo = refMeshCache[geometryId];
            index = Uint32Array.from(geometryInfo.I);
            position = Float32Array.from(geometryInfo.P);
            normal = Float32Array.from(geometryInfo.N);
            if (geometryInfo.UV) {
                uv = Float32Array.from(geometryInfo.UV);
            }else {
                uv = null;
            }
            geometryInfo = null;
            break;
        case nodeItemType.BOX:
        case nodeItemType.PIPE:
        case nodeItemType.TUBE:
            if (nodeInfo.type === nodeItemType.BOX) {
                geometry = CLOUD.GeomUtil.UnitBoxInstance;
            } else {
                geometry = CLOUD.GeomUtil.UnitCylinderInstance;
            }
            index = Uint32Array.from(geometry.getIndex().array);
            position = Float32Array.from(geometry.attributes.position.array);
            normal = Float32Array.from(geometry.attributes.normal.array);
            uv = Float32Array.from(geometry.attributes.uv.array);
            geometry = null;
            break;
        case nodeItemType.BOX_M:
        case nodeItemType.PIPE_M:
            if (nodeInfo.type === nodeItemType.BOX_M) {
                dataM = CLOUD.GeomUtil.getBoxMBuffer(nodeInfo.uvArrayBuffer);
            } else {
                dataM = CLOUD.GeomUtil.getPipeMBuffer(nodeInfo.uvArrayBuffer);
            }
            index = Uint32Array.from(dataM.index);
            position = Float32Array.from(dataM.vertex);
            normal = Float32Array.from(dataM.normal);
            if (dataM.uv) {
                uv = Float32Array.from(dataM.uv);
                delete dataM.uv;
            }
            dataM = null;
            break;
        default:
            console.log("error data!");
            break;
    }

    CLOUD.GeomUtil.applyMatrix4ToBuffer(matrix, position);
    CLOUD.GeomUtil.applyMatrix3ToBuffer(normalMatrix, normal);
    CLOUD.GeomUtil.normalizeBuffer(normal);

    if (uv) {
        nodeInfo.uv = true;
    } else {
        nodeInfo.uv = false;
    }

    this.cachedNodeBuffer[nodeInfo.nodeId] = {
        index: index,
        position: position,
        normal: normal,
        uv: uv
    };
};

CLOUD.Model.prototype._initBaseWireframe = function (nodeId) {

    if (this.cache.wireframeGeometries[nodeId]) {
        return;
    }

    var nodeBuffer = this.cachedNodeBuffer[nodeId];
    if (!nodeBuffer) {
        return;
    }

    var wireframeIndex = CLOUD.BuildEdge(nodeBuffer.position, nodeBuffer.index);
    var wireframeGeometry = new THREE.BufferGeometry();
    wireframeGeometry.setIndex(new THREE.Uint32BufferAttribute(wireframeIndex, 1));
    wireframeGeometry.addAttribute('position', new THREE.BufferAttribute(Float32Array.from(nodeBuffer.position), 3));

    nodeBuffer.position = null;
    nodeBuffer.index = null;
    nodeBuffer = null;

    this.cache.wireframeGeometries[nodeId] = wireframeGeometry;
};

CLOUD.Model.prototype._generateInstanceWireframe = function (nodeInfos) {

    var cache = this.cache;
    var cachedInstance = cache.instance;

    for (var i = 0, len = nodeInfos.length; i < len; i++) {

        var nodeInfo = nodeInfos[i];
        var materialId = nodeInfo.materialId;
        var geometryId = nodeInfo.geometryId;
        var geometry = cache.geometries[geometryId];

        if (!cache.wireframeGeometries[geometryId]) {
            this._initWireframeData(geometry, geometryId);
        }

        if (!cachedInstance.wireframeGeometries[geometryId]) {
            cachedInstance.wireframeGeometries[geometryId] = {};
        }

        var instanceWireframeGeometry = cachedInstance.wireframeGeometries[geometryId][materialId];

        if (!instanceWireframeGeometry) {
            var cachewireframeGeometry = cache.wireframeGeometries[geometryId];
            if (cachewireframeGeometry instanceof Array) {
                // geometryId == "boxM"
                instanceWireframeGeometry = new Array(cachewireframeGeometry.length);
                for (var i = 0, iLen = cachewireframeGeometry.length; i < iLen; i++) {
                    instanceWireframeGeometry[i] = new THREE.InstancedBufferGeometry();
                    instanceWireframeGeometry[i].setIndex(cachewireframeGeometry[i].index);
                    instanceWireframeGeometry[i].addAttribute('position', cachewireframeGeometry[i].attributes.position);
                }
            } else {
                instanceWireframeGeometry = new THREE.InstancedBufferGeometry();
                instanceWireframeGeometry.setIndex(cachewireframeGeometry.index);
                instanceWireframeGeometry.addAttribute('position', cachewireframeGeometry.attributes.position);
            }
            cachedInstance.wireframeGeometries[geometryId][materialId] = instanceWireframeGeometry;
        }

    }

    if (CLOUD.GlobalData.Instance) {
        for (var mId in this.instanceUpdateMap) {
            this._setupInstanceWireframeNodes(mId);
        }
        this.instanceUpdateMap = {};
    }
};

CLOUD.Model.prototype._generateBatchWireframe = function (nodeInfos) {

    var mapUserIdToWireframes = {};

    for (var i = 0, len = nodeInfos.length; i < len; i++) {
        var nodeInfo = nodeInfos[i];
        var uid = nodeInfo.name;
        var nodeId = nodeInfo.nodeId;
        this._initBaseWireframe(nodeId);

        var wireframeGeometry = this.cache.wireframeGeometries[nodeId];
        var lineMesh = new THREE.LineSegments(wireframeGeometry, this.wireframeMaterial);
        lineMesh.name = uid;
        lineMesh.nodeId = uid;

        if (!mapUserIdToWireframes[uid]) {
            mapUserIdToWireframes[uid] = [];
        }
        mapUserIdToWireframes[uid].push(lineMesh);
        lineMesh = null;
    }

    var lineSegments = [];
    for (var uid in mapUserIdToWireframes) {
        var wireframes = mapUserIdToWireframes[uid];
        for (var i = 0, len = wireframes.length; i < len; i++) {
            lineSegments.push(wireframes[i]);
        }
    }

    this.mapUserIdToWireframeIndices = {};

    // mergeLineSegments
    if (lineSegments.length > 0) {
        var mergedGeometry = CLOUD.GeomUtil.mergeBufferGeometries(lineSegments, this.mapUserIdToWireframeIndices);
        if(mergedGeometry){
            this.mergedGeometryIndex = mergedGeometry.getIndex();
            this.mergedLineSegment = new THREE.LineSegments(mergedGeometry, this.wireframeMaterial);
        }
    }
    lineSegments = null;

    for (var uid in mapUserIdToWireframes) {
        delete mapUserIdToWireframes[uid];
    }
    mapUserIdToWireframes = null;

};

CLOUD.Model.prototype._generateWireframe = function () {
    if (this.wireframeReady === void 0) {
        var filter = this.manager.filter;
        var objNodes = this.mapUserIdToNodeInfos;

        if (!objNodes) {
            return;
        }

        this.wireframeReady = true;

        console.time("generate wireframe");

        var batchNodes = [];
        var instanceNodes = [];

        for (var uid in objNodes) {
            var nodes = objNodes[uid];
            if(filter._hasRenderWithBoardlineFilter() &&
                !filter._isRenderWithBoardline(nodes[0])) {
                // There is no boardline setting in filter, do not draw it.
                continue;
            }

            for (var i = 0, len = nodes.length; i < len; i++) {
                var nodeInfo = nodes[i];
                if(nodeInfo.instanceOrNot) {
                    instanceNodes.push(nodeInfo);
                } else {
                    batchNodes.push(nodeInfo);
                }
            }
        }

        if (batchNodes.length > 0) {
            this._generateBatchWireframe(batchNodes);
        }

        if (instanceNodes.length > 0) {
            this._generateInstanceWireframe(instanceNodes);
        }

        this._destroyAllNodeBuffer();

        console.timeEnd("generate wireframe");
    }
};

CLOUD.Model.prototype._updateWireframe = function () {
    if (this.mergedLineSegment) {
        var wireframeGroupNode = this.manager.scene.getOrCreateObjectGroup(this._getWireframeGroupName(), {globalSpace: true});
        wireframeGroupNode.clear();
        wireframeGroupNode.add(this.mergedLineSegment);
        wireframeGroupNode.updateMatrixWorld(true);
    }
};

CLOUD.Model.prototype._clearReferencedMeshCache = function () {
    for (var geometryId in this.referencedMeshCache) {
        delete this.referencedMeshCache[geometryId];
    }
    this.referencedMeshCache = null;
};

CLOUD.Model.prototype._prepareInstanceGeometry = function (nodeInfo) {

    var geometry = this.cache.geometries[nodeInfo.geometryId];
    if(!geometry)
    {
        geometry = this._createBufferGeometry(nodeInfo, false);
        this._cacheGeometry(nodeInfo.geometryId, geometry);
        this.manager.addInstanceGeometry(nodeInfo.geometryId, geometry);
    }
    if (geometry) {
        var sceneMatrix = this.manager.getScene().getMatrixGlobal();
        var tmpMatrix = new THREE.Matrix4();
        var meshInfo = [];
        meshInfo.nodeId = nodeInfo.nodeId;
        meshInfo.matrix = tmpMatrix.multiplyMatrices(sceneMatrix, nodeInfo.matrix);
        meshInfo.databagId = this.databagId;
        this.manager.addMeshToCellMap(meshInfo);
        meshInfo = null;

    }
    this._createInstanceGeometry(nodeInfo);
};

CLOUD.Model.prototype._collectHoveredInstanceIds = function () {

    if (!this.instanceIds) {
        this.instanceIds = {};
    }

    var filterState = CLOUD.Model.EnumFilterState;
    var uid = this.getInstancedHoverId();
    if (uid) {
        if (!this.instanceIds[uid]) {
            this.instanceIds[uid] = {};
        }
        this.instanceIds[uid][filterState.HOVER] = true;
    }
};

CLOUD.Model.prototype._collectSelectedInstanceIds = function () {

    if (!this.instanceIds) {
        this.instanceIds = {};
    }

    var filterState = CLOUD.Model.EnumFilterState;
    var selectedIds = this.getInstancedSelections();
    if (selectedIds && selectedIds.length > 0) {
        for (var i = 0, len = selectedIds.length; i < len; i++) {
            var uid = selectedIds[i];
            if (!this.instanceIds[uid]) {
                this.instanceIds[uid] = {};
            }
            this.instanceIds[uid][filterState.SELECTED] = true;
        }
    }
};

CLOUD.Model.prototype._collectFilteredInstanceIds = function () {

    if (!this.instanceIds) {
        this.instanceIds = {};
    }

    var filterState = CLOUD.Model.EnumFilterState;

    var hiddenIds = this.getInstancedHiddenIds();
    if (hiddenIds && hiddenIds.length > 0) {
        for (var i = 0, len = hiddenIds.length; i < len; i++) {
            var uid = hiddenIds[i];
            if (!this.instanceIds[uid]) {
                this.instanceIds[uid] = {};
            }
            this.instanceIds[uid][filterState.HIDDEN] = true;
        }
    }

    var overrideSetObject = this.getInstancedOverrideSetObject();
    if (overrideSetObject) {
        for (var id in overrideSetObject) {
            if (overrideSetObject.hasOwnProperty(id)){
                if (!this.instanceIds[id]) {
                    this.instanceIds[id] = {};
                }
                this.instanceIds[id][filterState.OVERRIDED] = true;
            }
        }
    }

    var transparentUserIds = this.transparentUserIdSetObject;
    if (transparentUserIds){
        for (var uid in transparentUserIds) {
            if (transparentUserIds.hasOwnProperty(uid)){
                if (!this.instanceIds[uid]) {
                    this.instanceIds[uid] = {};
                }
                this.instanceIds[uid][filterState.TRANSPARENT] = true;
            }
        }
    }
};

CLOUD.Model.prototype._clearInstanceIds = function () {
    this.instanceIds = null;
};

CLOUD.Model.prototype._clearHoveredInstanceState = function () {

    var filterState = CLOUD.Model.EnumFilterState;

    if (!this.instanceIds) {
        return;
    }

    var uid = this.getInstancedHoverId();
    if (uid && this.instanceIds[uid]) {
        this._clearInstanceStateByUserId(uid);
        delete this.instanceIds[uid][filterState.HOVER];
    }
};

CLOUD.Model.prototype._clearSelectedInstanceState = function () {

    var filterState = CLOUD.Model.EnumFilterState;

    if (!this.instanceIds) {
        return;
    }

    var selectedIds = this.getInstancedSelections();
    if (selectedIds && selectedIds.length > 0) {
        for (var i = 0, len = selectedIds.length; i < len; i++) {
            var uid = selectedIds[i];
            if (this.instanceIds[uid]) {
                this._clearInstanceStateByUserId(uid);
                delete this.instanceIds[uid][filterState.SELECTED];
            }
        }
    }
};

CLOUD.Model.prototype._clearInstanceStateByUserId = function (userId) {

    var cachedInstance = this.cache.instance;
    var geometryIdMap = cachedInstance.mapPackIdToIndices[userId];

    function updateGeometryAttributeState(geometry, indices, state){
        var vState = geometry.getAttribute("vState").array;
        for (var j = 0; j < indices.length; ++j) {
            var index = indices[j];
            vState[index] = state;
        }
        geometry.getAttribute("vState").needsUpdate = true;
    }

    for (var geometryId in geometryIdMap) {
        var instanceGeometries = cachedInstance.geometries[geometryId];

        for (var mId in instanceGeometries) {
            var indices = geometryIdMap[geometryId][mId];
            if (indices === undefined) {
                continue;
            }

            var geometries = instanceGeometries[mId];
            var instanceMaterials = cachedInstance.materials[mId];

            for (var i = 0, iLen = instanceMaterials.length; i < iLen; i++) {
                var geometry = geometries[i];
                var instanceMaterial = instanceMaterials[i];
                var oriState = instanceMaterial._primary ? CLOUD.EnumInstanceState.NONE : CLOUD.EnumInstanceState.HIDDEN;

                // geometryId == "boxM"
                if (geometry instanceof Array) {
                    for (var j = 0, jLen = geometry.length; j < jLen; ++j) {
                        updateGeometryAttributeState(geometry[j], indices, oriState);
                    }
                } else {
                    updateGeometryAttributeState(geometry, indices, oriState);
                }
            }
        }
    }

};

CLOUD.Model.prototype._resetInstanceMaterial = function () {

    var cachedInstance = this.cache.instance;
    var i, j, k;
    var iLen, jLen, kLen;

    for (var geometryId in cachedInstance.geometries) {

        var instanceGeometries = cachedInstance.geometries[geometryId];

        for (var mId in instanceGeometries) {

            var geometries = instanceGeometries[mId];
            var instanceMaterials = cachedInstance.materials[mId];

            for (k = 0, kLen = instanceMaterials.length; k < kLen; k++) {

                var geometry = geometries[k];
                var instanceMaterial = instanceMaterials[k];
                var oriState = instanceMaterial._primary ? CLOUD.EnumInstanceState.NONE : CLOUD.EnumInstanceState.HIDDEN;

                // geometryId === 'boxM'
                if (geometry instanceof Array) {
                    for (j = 0, jLen = geometry.length; j < jLen; ++j) {
                        var vState = geometry[j].getAttribute("vState").array;
                        for (i = 0, iLen = vState.length; i < iLen; i++) {
                            vState[i] = oriState;
                        }
                        geometry[j].getAttribute("vState").needsUpdate = true;
                    }
                } else {
                    var vState = geometry.getAttribute("vState").array;
                    for (i = 0, iLen = vState.length; i < iLen; i++) {
                        vState[i] = oriState;
                    }
                    geometry.getAttribute("vState").needsUpdate = true;
                    //showAll
                }
            }
        }
    }

    // 线框
    for (var geometryId in cachedInstance.wireframeGeometries) {
        var instanceWireframeGeometry = cachedInstance.wireframeGeometries[geometryId];
        for (var mId in instanceWireframeGeometry) {
            var geometry = instanceWireframeGeometry[mId];
            if (geometry instanceof Array) {
                // geometryId === 'boxM'
                for (i = 0, iLen = geometry.length; i < iLen; ++i) {
                    geometry[i].addAttribute('vState', new THREE.InstancedBufferAttribute(
                        new Float32Array(cachedInstance.vState[geometryId][mId]), 1, 1
                    ));
                }
            } else {
                geometry.addAttribute('vState', new THREE.InstancedBufferAttribute(
                    new Float32Array(cachedInstance.vState[geometryId][mId]), 1, 1
                ));
            }
        }
    }
};

CLOUD.Model.prototype._updateInstanceWireframeByUserId = function (userId, geometryId, state) {

    var cachedInstance = this.cache.instance;
    var geometryIdMap = cachedInstance.mapPackIdToIndices[userId];

    // 只处理线框的显示隐藏
    if ((state === CLOUD.EnumInstanceState.HIDDEN) || (state === CLOUD.EnumInstanceState.NONE)) {
        var instanceWireframeGeometry = cachedInstance.wireframeGeometries[geometryId];

        for (var mId in instanceWireframeGeometry) {
            var indices = geometryIdMap[geometryId][mId];
            if (indices === undefined) {
                continue;
            }
            var geometry = instanceWireframeGeometry[mId];
            if (geometry instanceof Array) {
                // geometryId == "boxM"
                for (var i = 0, iLen = geometry.length; i < iLen; ++i) {
                    var vState = geometry[i].getAttribute("vState").array;
                    for (var j = 0, jLen = indices.length; j < jLen; ++j) {
                        var index = indices[j];
                        vState[index] = state;
                    }
                    geometry[i].getAttribute("vState").needsUpdate = true;
                }
            } else {
                var vState = geometry.getAttribute("vState").array;
                for (var j = 0, jLen = indices.length; j < jLen; ++j) {
                    var index = indices[j];
                    vState[index] = state;
                }
                geometry.getAttribute("vState").needsUpdate = true;
            }
        }
    }
};

CLOUD.Model.prototype._updateInstanceStateByUserId = function (userId, geometryId, state, materialName) {

    var cachedInstance = this.cache.instance;
    var geometryIdMap = cachedInstance.mapPackIdToIndices[userId];
    var selectedMaterial = this.selectedMaterial;
    var transparentMaterial = this.manager.filter._getMaterialByName('scene');

    function updateGeometryAttribute(geometry, indices, state, color){

        var vState = geometry.getAttribute("vState").array;
        var attrColor = geometry.getAttribute("aColor");
        var aColor = attrColor ? attrColor.array : null;

        for (var j = 0; j < indices.length; ++j) {

            var index = indices[j];
            vState[index] = state;

            if(aColor != null ){
                aColor[index * 4] = color[0];
                aColor[index * 4 + 1] = color[1];
                aColor[index * 4 + 2] = color[2];
                aColor[index * 4 + 3] = color[3];
            }
        }
        geometry.getAttribute("vState").needsUpdate = true;

        if(attrColor)
            attrColor.needsUpdate = true;
    }

    var instanceGeometries = cachedInstance.geometries[geometryId];

    for (var mId in instanceGeometries) {

        var indices = geometryIdMap[geometryId][mId];
        if (indices === undefined)
            continue;

        var currentMaterial = this.cache.materials[mId];
        var material, color;
        switch (state) {
            case CLOUD.EnumInstanceState.HOVER:
                if (materialName) {
                    material = this.manager.filter._getMaterialByName(materialName);
                    material = this.manager.sceneState.getHoverMaterial(material);
                } else {
                    material = this.manager.sceneState.getHoverMaterial(this.cache.materials[mId]);
                }
                break;
            case CLOUD.EnumInstanceState.SELECTED:
                material = selectedMaterial;
                break;
            case CLOUD.EnumInstanceState.TRANSPARENT:
                material = transparentMaterial;
                break;
            case CLOUD.EnumInstanceState.OVERRIDED:
                if (materialName) {
                    material = this.manager.filter._getMaterialByName(materialName);
                } else {
                    material = currentMaterial;
                }
                break;
            default:
                material = currentMaterial;
                break;
        }

        // shader中 半透明也是override的一种，所以透明状态也使用 CLOUD.EnumInstanceState.OVERRIDED
        if (state === CLOUD.EnumInstanceState.TRANSPARENT) {
            state = CLOUD.EnumInstanceState.OVERRIDED;
        }

        color = [material.color.r, material.color.g, material.color.b, material.opacity];

        var geometries = instanceGeometries[mId];
        var instanceMaterials = cachedInstance.materials[mId];

        for (var i = 0, iLen = instanceMaterials.length; i < iLen; i++) {
            var geometry = geometries[i];
            var instanceMaterial = instanceMaterials[i];
            var usedState = state;

            if (instanceMaterial.transparent !== material.transparent) {
                usedState = CLOUD.EnumInstanceState.HIDDEN;
            }

            // geometryId == "boxM"
            if (geometry instanceof Array) {
                for (var j = 0, jLen = geometry.length; j < jLen; ++j) {
                    updateGeometryAttribute(geometry[j], indices, usedState, color);
                }
            } else {
                updateGeometryAttribute(geometry, indices, usedState, color);
            }
        }
    }
};

CLOUD.Model.prototype._updateInstanceMaterialByUserId = function (userId, state, materialName) {

    CLOUD.Logger.time("update instance material");
    var cachedInstance = this.cache.instance;
    var geometryIdMap = cachedInstance.mapPackIdToIndices[userId];

    for (var geometryId in geometryIdMap) {
        this._updateInstanceStateByUserId(userId, geometryId, state, materialName);
        this._updateInstanceWireframeByUserId(userId, geometryId, state);
    }

    CLOUD.Logger.timeEnd("update instance material");
};

CLOUD.Model.prototype._updateInstanceMaterial = function () {

    CLOUD.Logger.time("update instance material");

    var filterState = CLOUD.Model.EnumFilterState;
    var overrideSetObject = this.getInstancedOverrideSetObject();

    for (var uid in this.instanceIds) {
        if (this.instanceIds.hasOwnProperty(uid)) {
            var states = this.instanceIds[uid];
            if (states[filterState.HIDDEN]) {
                this._updateInstanceMaterialByUserId(uid, CLOUD.EnumInstanceState.HIDDEN);
            } else if (states[filterState.TRANSPARENT]){
                this._updateInstanceMaterialByUserId(uid, CLOUD.EnumInstanceState.TRANSPARENT);
            } else if (states[filterState.SELECTED]) {
                this._updateInstanceMaterialByUserId(uid, CLOUD.EnumInstanceState.SELECTED);
            } else if (states[filterState.HOVER]) {
                if (overrideSetObject && overrideSetObject[uid]) {
                    this._updateInstanceMaterialByUserId(uid, CLOUD.EnumInstanceState.HOVER, overrideSetObject[uid]);
                }else {
                    this._updateInstanceMaterialByUserId(uid, CLOUD.EnumInstanceState.HOVER);
                }
            } else if (states[filterState.OVERRIDED]){
                this._updateInstanceMaterialByUserId(uid, CLOUD.EnumInstanceState.OVERRIDED, overrideSetObject[uid]);
            }
        }
    }

    CLOUD.Logger.timeEnd("update instance material");
};

CLOUD.Model.prototype.applyFilter = function () {

    var batchMergeEnabled = CLOUD.GlobalData.BatchMergeEnabled;
    var instanceEnabled = CLOUD.GlobalData.Instance;

    this._collectFilteredUserIds();
    this._collectSelectedUserIds();
    this._collectHoveredUserIds();

    if (instanceEnabled) {
        this._resetInstanceMaterial();
        this._clearInstanceIds();
        this._collectSelectedInstanceIds();
        this._collectHoveredInstanceIds();
        this._collectFilteredInstanceIds();
        this._updateInstanceMaterial();
    }

    if (batchMergeEnabled) {
        this._rebuildIndicesForWireframe();
        this._rebuildIndices();
        this._updateMergedMeshNodes();
    }
};

CLOUD.Model.prototype.applySelection = function () {

    var batchMergeEnabled = CLOUD.GlobalData.BatchMergeEnabled;
    var instanceEnabled = CLOUD.GlobalData.Instance;

    if (instanceEnabled) {
        this._clearSelectedInstanceState();
        this._clearHoveredInstanceState();
    }

    this._collectSelectedUserIds();
    this._collectHoveredUserIds();

    if (instanceEnabled) {
        this._collectSelectedInstanceIds();
        this._collectHoveredInstanceIds();
        this._updateInstanceMaterial();
    }

    if (batchMergeEnabled) {
        this._rebuildIndices();
        this._updateMergedMeshNodes();
    }
};

CLOUD.Model.prototype.clearSelection = function () {

    var batchMergeEnabled = CLOUD.GlobalData.BatchMergeEnabled;
    var instanceEnabled = CLOUD.GlobalData.Instance;

    if (instanceEnabled) {
        this._clearSelectedInstanceState();
        this._clearHoveredInstanceState();
    }

    this._clearSelections();
    this._collectHoveredUserIds();

    if (instanceEnabled) {
        this._collectHoveredInstanceIds();
        this._updateInstanceMaterial();
    }

    if (batchMergeEnabled) {
        this._rebuildIndices();
        this._updateMergedMeshNodes();
    }
};

CLOUD.Model.prototype.applyHover = function () {

    var batchMergeEnabled = CLOUD.GlobalData.BatchMergeEnabled;
    var instanceEnabled = CLOUD.GlobalData.Instance;

    if (instanceEnabled) {
        this._clearHoveredInstanceState();
    }

    this._collectHoveredUserIds();

    if (instanceEnabled) {
        this._collectHoveredInstanceIds();
        this._updateInstanceMaterial();
    }

    if (batchMergeEnabled) {
        this._rebuildIndices();
        this._updateMergedMeshNodes();
    }
};

CLOUD.Model.prototype.clearHover = function () {

    var batchMergeEnabled = CLOUD.GlobalData.BatchMergeEnabled;
    var instanceEnabled = CLOUD.GlobalData.Instance;

    if (instanceEnabled) {
        this._clearHoveredInstanceState();
    }

    this._clearHover();

    if (instanceEnabled) {
        this._updateInstanceMaterial();
    }

    if (batchMergeEnabled) {
        this._rebuildIndices();
        this._updateMergedMeshNodes();
    }
};

// 模型数据项类型
CLOUD.Model.NodeItemType = {
    SYMBOL: 0,
    MESH: 1,
    TUBE: 2,
    PIPE: 3,
    BOX: 4,
    BOX_M: 5,
    PIPE_M: 6,
    MESH_REF: 7,
    LINE: 8
};

CLOUD.Model.EnumFilterState = {
    HIDDEN: -1,
    NONE: 0,
    SELECTED: 1,
    HOVER: 2,
    TRANSPARENT: 3,
    OVERRIDED: 4
};