//CLOUD.Camera = function (width, height, fov, near, far) {
CLOUD.Camera = function (type, params) {

    CLOUD.CombinedCamera.call(this, type, params);

    this.realUp = this.up.clone(); //
    this.dirty = false;

    this.orthoScale = 1.0;

    this.positionPlane = new THREE.Plane();
    this.projScreenMatrix = new THREE.Matrix4();
    this.viewProjInverse = new THREE.Matrix4();

    this.frustum = new THREE.Frustum();

};

CLOUD.Camera.prototype = Object.create(CLOUD.CombinedCamera.prototype);
CLOUD.Camera.prototype.constructor = CLOUD.Camera;

CLOUD.Camera.prototype._updatePositionPlane = function () {
    this.positionPlane.setFromNormalAndCoplanarPoint(this.getWorldDirection(), this.position);
};

CLOUD.Camera.prototype._updateFrustum = function () {
    this.frustum.setFromMatrix(this.projScreenMatrix);
};

// 更新相机矩阵
CLOUD.Camera.prototype.updateMVP = function () {

    if(this.dirty){
        if (this.parent === null)
            this.updateMatrixWorld();

        this.matrixWorldInverse.getInverse(this.matrixWorld);
        this.projScreenMatrix.multiplyMatrices(this.projectionMatrix, this.matrixWorldInverse);
        this.viewProjInverse.getInverse(this.projScreenMatrix);

        this._updateFrustum();
        this._updatePositionPlane();
        this.dirty = false;
    }
};

// 获得相机视锥
CLOUD.Camera.prototype.getFrustum = function () {

    if(this.dirty){
        this.updateMVP();
    }
    return this.frustum;
};

CLOUD.Camera.prototype.LookAt = function (target, dir, up, focal) {

    var offset = new THREE.Vector3();
    offset.copy(dir);

    if (focal !== undefined)
        offset.setLength(focal);

    this.position.subVectors(target, offset);
    this.up = up;
    this.lookAt(target);
    this.realUp = up.clone();
    this.target = target.clone();
    this.dirty = true;

};

CLOUD.Camera.prototype.copy = function (source) {

    CLOUD.CombinedCamera.prototype.copy.call(this, source);

    this.realUp.copy(source.realUp);
    this.orthoScale = source.orthoScale;
    this.dirty = source.dirty;

    this.updateProjectionMatrix();
    this.updateMVP();

    return this;
};

CLOUD.Camera.prototype.setStandardView = function (stdView, box) {

    var target;

    if (box) {
        target = box.getCenter();
    } else {
        target = new THREE.Vector3(0, 0, 0);
    }

    var sceneSize = CLOUD.GlobalData.SceneSize;
    var focal = sceneSize / 2;

    switch (stdView) {
        case CLOUD.EnumStandardView.ISO:
            var position = new THREE.Vector3(-sceneSize, sceneSize, sceneSize);
            var dir = new THREE.Vector3();
            // BIMFACEDM-1456 : 如果场景中心点不在原点(0, 0, 0)，相机的方向应该使用原点计算，与target无关
            // dir.subVectors(target, position);
            var center = new THREE.Vector3(0, 0, 0);
            dir.subVectors(center, position);
            this.LookAt(target, dir, THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.Top:
            this.LookAt(target, new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, -1), focal);
            // 这里恢复up方向有问题，应该在本次渲染结束后才能恢复。
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.Bottom:
            this.LookAt(target, new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.Front:
            //this.LookAt(target, new THREE.Vector3(0, -0.5, -1), new THREE.Vector3(0, 1, 0), focal);
            this.LookAt(target, new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.Back:
            this.LookAt(target, new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.Right:
            this.LookAt(target, new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.Left:
            this.LookAt(target, new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.SouthEast:
            // 将视点抬高，避开坐标轴重叠 (-1, 0, -1)  --> (-1, -1, -1)
            //this.LookAt(target, new THREE.Vector3(-1, -1, -1), new THREE.Vector3(0, 1, 0), focal);
            // 注意：之前修改过bug（GGP-11834：标准视图与Jetfire不一致）。修改方法是抬高视点。
            // 但是在viewhouse的多维度观察视角下，抬高视点对应的实际上是RoofSouthEast,所以这里恢复视点。
            this.LookAt(target, new THREE.Vector3(-1, 0, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.SouthWest:
            // 将视点抬高，避开坐标轴重叠 (1, 0, -1)  --> (1, -1, -1)
            //this.LookAt(target, new THREE.Vector3(1, -1, -1), new THREE.Vector3(0, 1, 0), focal);
            // 注意：之前修改过bug（GGP-11834：标准视图与Jetfire不一致）。修改方法是抬高视点。
            // 但是在viewhouse的多维度观察视角下，抬高视点对应的实际上是RoofSouthEast,所以这里恢复视点
            this.LookAt(target, new THREE.Vector3(1, 0, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.NorthWest:
            // 将视点抬高，避开坐标轴重叠 (1, 0, 1)  --> (1, -1, 1)
            //this.LookAt(target, new THREE.Vector3(1, -1, 1), new THREE.Vector3(0, 1, 0), focal);
            // 注意：之前修改过bug（GGP-11834：标准视图与Jetfire不一致）。修改方法是抬高视点。
            // 但是在viewhouse的多维度观察视角下，抬高视点对应的实际上是NorthWest,所以这里恢复视点
            this.LookAt(target, new THREE.Vector3(1, 0, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.NorthEast:
            // 将视点抬高，避开坐标轴重叠 (-1, 0, 1)  --> (-1, -1, 1)
            //this.LookAt(target, new THREE.Vector3(-1, -1, 1), new THREE.Vector3(0, 1, 0), focal);
            // 注意：之前修改过bug（GGP-11834：标准视图与Jetfire不一致）。修改方法是抬高视点。
            // 但是在viewhouse的多维度观察视角下，抬高视点对应的实际上是RoofNorthEast,所以这里恢复视点
            this.LookAt(target, new THREE.Vector3(-1, 0, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.BottomFront:
            this.LookAt(target, new THREE.Vector3(0, 1, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.BottomBack:
            this.LookAt(target, new THREE.Vector3(0, 1, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.BottomRight:
            this.LookAt(target, new THREE.Vector3(-1, 1, 0), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.BottomLeft:
            this.LookAt(target, new THREE.Vector3(1, 1, 0), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.BottomSouthEast:
            this.LookAt(target, new THREE.Vector3(-1, 1, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.BottomSouthWest:
            this.LookAt(target, new THREE.Vector3(1, 1, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.BottomNorthWest:
            this.LookAt(target, new THREE.Vector3(1, 1, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.BottomNorthEast:
            this.LookAt(target, new THREE.Vector3(-1, 1, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.RoofFront:
            this.LookAt(target, new THREE.Vector3(0, -1, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.RoofBack:
            this.LookAt(target, new THREE.Vector3(0, -1, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.RoofRight:
            this.LookAt(target, new THREE.Vector3(-1, -1, 0), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.RoofLeft:
            this.LookAt(target, new THREE.Vector3(1, -1, 0), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.RoofSouthEast:
            this.LookAt(target, new THREE.Vector3(-1, -1, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.RoofSouthWest:
            this.LookAt(target, new THREE.Vector3(1, -1, -1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.RoofNorthWest:
            this.LookAt(target, new THREE.Vector3(1, -1, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.RoofNorthEast:
            this.LookAt(target, new THREE.Vector3(-1, -1, 1), new THREE.Vector3(0, 1, 0), focal);
            break;
        case CLOUD.EnumStandardView.TopTurnRight:
            this.LookAt(target, new THREE.Vector3(0, -1, 0), new THREE.Vector3(-1, 0, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.TopTurnBack:
            this.LookAt(target, new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.TopTurnLeft:
            this.LookAt(target, new THREE.Vector3(0, -1, 0), new THREE.Vector3(1, 0, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.BottomTurnRight:
            this.LookAt(target, new THREE.Vector3(0, 1, 0), new THREE.Vector3(-1, 0, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.BottomTurnBack:
            this.LookAt(target, new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, -1), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.BottomTurnLeft:
            this.LookAt(target, new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.FrontTurnTop:
            this.LookAt(target, new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, -1, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.FrontTurnLeft:
            this.LookAt(target, new THREE.Vector3(0, 0, -1), new THREE.Vector3(1, 0, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.FrontTurnRight:
            this.LookAt(target, new THREE.Vector3(0, 0, -1), new THREE.Vector3(-1, 0, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.RightTurnTop:
            this.LookAt(target, new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, -1, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.RightTurnFront:
            this.LookAt(target, new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, -1), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.RightTurnBack:
            this.LookAt(target, new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, 1), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.BackTurnTop:
            this.LookAt(target, new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, -1, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.BackTurnLeft:
            this.LookAt(target, new THREE.Vector3(0, 0, 1), new THREE.Vector3(-1, 0, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.BackTurnRight:
            this.LookAt(target, new THREE.Vector3(0, 0, 1), new THREE.Vector3(1, 0, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.LeftTurnTop:
            this.LookAt(target, new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -1, 0), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.LeftTurnBack:
            this.LookAt(target, new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 1), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;
        case CLOUD.EnumStandardView.LeftTurnFront:
            this.LookAt(target, new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, -1), focal);
            //this.up.copy(THREE.Object3D.DefaultUp);
            break;

    }
    this.updateProjectionMatrix();
    return target;
};

/**
 * 缩放到指定的包围盒范围
 *
 * @param {THREE.Box3} box - 包围盒
 * @param {Number} margin - 包围盒缩放比例 (< 1.0), 缺省值: 0.0。margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
 * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
 * @param {THREE.Vector3} direction - 相机观察方向
 */
CLOUD.Camera.prototype.zoomToBBox = function (box, margin, ratio, direction) {

    ratio = ratio || 1.0;
    margin = margin || 0.0;
    margin = margin < -1.0 ? -1.0 : margin; // 钳制

    var newBox = new THREE.Box3();
    newBox.copy(box);

    if (margin !== 0.0) {
        var boxLen = box.getSize().length() * 0.5;
        var diagonalLine = new THREE.Vector3();
        diagonalLine.subVectors(newBox.max, newBox.min).normalize();
        diagonalLine.multiplyScalar(boxLen * margin);
        newBox.expandByVector(diagonalLine);
    }

    var dir = direction ? direction : this.getWorldDirection();
    var up = this.up;
    var aspect = this.aspect;
    var halfFov = THREE.Math.degToRad(this.fov * 0.5); // 转成弧度

    var boxSize = newBox.getSize();
    var center = newBox.getCenter();
    var radius = boxSize.length() * 0.5;
    var distToCenter = radius / Math.sin(halfFov) * ratio;

    var offset = new THREE.Vector3();
    offset.copy(dir);
    offset.setLength(distToCenter);

    var position = new THREE.Vector3();
    position.subVectors(center, offset);

    // ---------- 计算新位置 S ----------------- //
    var right = new THREE.Vector3();
    right.crossVectors(dir, up);
    right.normalize();

    var newUp = new THREE.Vector3();
    newUp.crossVectors(dir, right);
    newUp.normalize();

    var vertPlane = new THREE.Plane();
    vertPlane.setFromNormalAndCoplanarPoint(right, position);

    var horzPlane = new THREE.Plane();
    horzPlane.setFromNormalAndCoplanarPoint(newUp, position);

    var maxHeightToCorner = 0;
    var maxHeight = 0;
    var maxDistFromHeight = 0;
    var maxWidth = 0;
    var maxDistFromWidth = 0;

    var corners = [
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3()
    ];

    corners[0].set(newBox.min.x, newBox.min.y, newBox.min.z); // 000
    corners[1].set(newBox.min.x, newBox.min.y, newBox.max.z); // 001
    corners[2].set(newBox.min.x, newBox.max.y, newBox.min.z); // 010
    corners[3].set(newBox.min.x, newBox.max.y, newBox.max.z); // 011
    corners[4].set(newBox.max.x, newBox.min.y, newBox.min.z); // 100
    corners[5].set(newBox.max.x, newBox.min.y, newBox.max.z); // 101
    corners[6].set(newBox.max.x, newBox.max.y, newBox.min.z); // 110
    corners[7].set(newBox.max.x, newBox.max.y, newBox.max.z);  // 111

    for (var i = 0; i < 8; i++) {
        var v = new THREE.Vector3();
        v.subVectors(corners[i], position);
        var dist = Math.abs(v.dot(dir));

        var h1 = Math.abs(horzPlane.distanceToPoint(corners[i]));
        var w1 = h1 * aspect;
        var w2 = Math.abs(vertPlane.distanceToPoint(corners[i]));
        var h2 = w2 / aspect;

        var h = Math.max(h1, h2);
        var w = Math.max(w1, w2);

        if (maxHeightToCorner < h) {
            maxHeightToCorner = h;
        }

        if (!maxHeight || !maxDistFromHeight || h > maxHeight * dist / maxDistFromHeight) {
            maxHeight = h;
            maxDistFromHeight = dist;
        }

        if (!maxWidth || !maxDistFromWidth || w > maxWidth * dist / maxDistFromWidth) {
            maxWidth = w;
            maxDistFromWidth = dist;
        }
    }

    var cameraDist = maxHeight / Math.tan(halfFov) + (distToCenter - maxDistFromHeight);
    if (aspect < 1.0) {
        cameraDist = maxWidth / Math.tan(halfFov) + (distToCenter - maxDistFromWidth);
    }

    // BIMFACEDM-2206：防止小构件被相机裁剪 (cameraDist < this.near)， 重新计算近裁剪面。
    if (cameraDist < this.near) {
        var delta = 0.001;
        this.near = (cameraDist * cameraDist + cameraDist * delta) / ((1 << 24) * delta);
    }

    offset.copy(dir).normalize().setLength(cameraDist);
    position.subVectors(center, offset);

    // ---------- 计算新位置 E ----------------- //

    // 正交投影和透视投影对应的相机位置保持一致
    this.position.copy(position);
    this.lookAt(center);
    this.target.copy(center);

    if (!this.isPerspective) {
        var halfHeight = Math.tan(this.fov * Math.PI / 180 / 2) * cameraDist;
        this.orthoScale = halfHeight / maxHeightToCorner;
        this.zoom = this.orthoScale;
    }

    this.updateProjectionMatrix();
    this.dirty = true;
    return center;
};

CLOUD.Camera.prototype.computeRay = function (cx, cy, domElement) {
    var viewportDim = new THREE.Vector2();

    if (domElement === undefined) {
        viewportDim.x = window.innerWidth;
        viewportDim.y = window.innerHeight;
    }
    else {
        var element = domElement === document ? domElement.body : domElement;

        // clientWidth: 是对象可见的宽度，不包含滚动条等边线，会随窗口的显示大小改变。
        // offsetWidth:	是对象的可见宽度，包含滚动条等边线，会随窗口的显示大小改变。
        // CloudCameraEditor.getContainerDimensions 使用的是offsetWidth, offsetHeight,保持统一。
        //viewportDim.x = element.clientWidth;
        //viewportDim.y = element.clientHeight;
        viewportDim.x = element.offsetWidth;
        viewportDim.y = element.offsetHeight;
    }

    // To Viewport
    var viewPos = new THREE.Vector2();

    // 注意这里传入的cx, cy是相对视口的值（即已做过偏移）
    viewPos.x = (cx / viewportDim.x) * 2 - 1;
    viewPos.y = -(cy / viewportDim.y) * 2 + 1;

    var ray = new THREE.Ray();
    if (this.isPerspective) {
        ray.origin.copy(this.position);
        ray.direction.set(viewPos.x, viewPos.y, 0.5).unproject(this).sub(this.position).normalize();
    }
    else {
        ray.origin.set(viewPos.x, viewPos.y, -1).unproject(this);
        ray.direction.set(0, 0, -1).transformDirection(this.matrixWorld);
    }

    return ray;
};

CLOUD.Camera.prototype.screenToWorld = function (cx, cy, domElement, target) {

    var ray = this.computeRay(cx, cy, domElement);
    // plane on target
    var dir = this.getWorldDirection().normalize();

    var plane = new THREE.Plane(dir);
    plane.setFromNormalAndCoplanarPoint(dir, target);

    return ray.intersectPlane(plane, target);
};

// 获取场景变换前的相机对应的Frustum
CLOUD.Camera.prototype.getWorldFrustum = function (matrixRoot) {

    var matrixWorldInverse = new THREE.Matrix4();
    var frustum = new THREE.Frustum();

    var worldCamera = this.clone();
    var targetPost = this.target;
    // 计算场景变换后的相机位置和目标点的距离
    var distancePost = targetPost.clone().sub(this.position).length();

    // 逆矩阵
    var matrixInverseRoot = new THREE.Matrix4();
    matrixInverseRoot.getInverse(matrixRoot);

    // 抽取旋转矩阵
    var matrixRotation = new THREE.Matrix4();
    matrixRotation.extractRotation(matrixRoot);
    var quaternion = new THREE.Quaternion();
    quaternion.setFromRotationMatrix(matrixRotation);
    quaternion.inverse();// 反转

    // 计算场景变换前的相机位置
    worldCamera.position.applyMatrix4(matrixInverseRoot);

    // 计算场景变换前的目标位置
    var targetPre = targetPost.clone();
    targetPre.applyMatrix4(matrixInverseRoot);

    // 计算场景变换前的相机方向
    // var dirPre = camera.getWorldDirection();
    // dirPre.applyQuaternion(quaternion).normalize();
    var dirPre = targetPre.clone().sub(worldCamera.position);

    // 计算场景变换前的相机位置和目标点的距离
    var distancePre = dirPre.length();

    dirPre.normalize();

    // 计算场景变换前的相机 near 和 far
    var scaleCoe = distancePre / distancePost;
    // worldCamera.near = camera.near * scaleCoe;
    worldCamera.far = camera.far * scaleCoe;

    worldCamera.up.applyQuaternion(quaternion).normalize();
    worldCamera.realUp.applyQuaternion(quaternion).normalize();
    worldCamera.updateProjectionMatrix();
    worldCamera.updateMatrixWorld();

    matrixWorldInverse.getInverse(worldCamera.matrixWorld);
    frustum.setFromMatrix(new THREE.Matrix4().multiplyMatrices(worldCamera.projectionMatrix, matrixWorldInverse));

    worldCamera = null;

    return frustum;

};

/**
 * 世界空间中的距离转换成绘图空间(相机空间)的距离
 *
 * @param {THREE.Matrix4} matrixScene - 场景变换矩阵
 * @param {Number} distance - 世界空间中的距离
 * @return {Number} distance - 绘图空间中的距离
 */
CLOUD.Camera.prototype.distanceFromWorldToDrawing = function (matrixScene, distance) {

    var origin = this.position.clone();
    var direction = this.target.clone();

    direction.subVectors(this.target, this.position);
    direction.normalize();

    // 先变回世界空间
    var inverseMatrix = new THREE.Matrix4();
    inverseMatrix.getInverse(matrixScene);

    direction.add(origin).applyMatrix4(inverseMatrix);
    origin.applyMatrix4(inverseMatrix);
    direction.sub(origin);
    direction.normalize().multiplyScalar(distance);

    // 再变回绘图空间
    direction.add(origin).applyMatrix4(matrixScene);
    // 起始点就是相机的位置
    // origin.applyMatrix4( matrixScene );
    // direction.sub(origin);
    direction.sub(this.position);

    return direction.length();

};


/**
 * 将相机从绘图坐标系转换到世界坐标系
 *
 * @param {Object} cameraInfo - 绘图坐标系中相机位置 {position:xxx, target:xxx, up:xxx}
 * @param {THREE.Matrix4} matrixScene - 场景变换矩阵
 * @returns {Object} - 世界系中相机位置 {position:xxx, target:xxx, up:xxx}
 */
CLOUD.Camera.drawingToWorld = function (cameraInfo, matrixScene) {

    var position = cameraInfo.position.clone();
    var target = cameraInfo.target.clone();
    var up = cameraInfo.up.clone();

    var inverseMatrix = new THREE.Matrix4();
    inverseMatrix.getInverse(matrixScene);

    up.add(position);
    up.applyMatrix4(inverseMatrix);

    position.applyMatrix4(inverseMatrix);
    target.applyMatrix4(inverseMatrix);

    up.sub(position);
    up.normalize();

    return {position: position, target: target, up: up};
};

/**
 * 将相机从世界坐标系转换到绘图坐标系
 *
 * @param {Object} cameraInfo - 世界坐标系中相机位置 {position:xxx, target:xxx, up:xxx}
 * @param {THREE.Matrix4} matrixScene - 场景变换矩阵
 * @returns {Object} - 绘图坐标系中相机位置 {position:xxx, target:xxx, up:xxx}
 */
CLOUD.Camera.worldToDrawing = function (cameraInfo, matrixScene) {

    var position = cameraInfo.position.clone();
    var target = cameraInfo.target.clone();
    var up = cameraInfo.up.clone();

    up.add(position);
    up.applyMatrix4(matrixScene);

    position.applyMatrix4(matrixScene);
    target.applyMatrix4(matrixScene);

    up.sub(position);
    up.normalize();

    return {position: position, target: target, up: up};
};