CLOUD.Raycaster = function (origin, direction, near, far) {

    this.ray = new THREE.Ray(origin, direction);
    // direction is assumed to be normalized (for accurate distance calculations)

    this.near = near || 0;
    this.far = far || Infinity;

    this.params = {
        Sprite: {},
        Mesh: {},
        Points: {threshold: 1},
        LOD: {},
        Line: {}
    };
};

CLOUD.Raycaster.prototype = {

    constructor: CLOUD.Raycaster,

    precision: 0.0001,
    linePrecision: 1,

    descSort: function (a, b) {
        return a.distance - b.distance;
    },

    set: function (origin, direction) {
        // direction is assumed to be normalized (for accurate distance calculations)

        this.ray.set(origin, direction);
    },

    setFromCamera: function (coords, camera) {

        // camera is assumed _not_ to be a child of a transformed object
        if (camera instanceof CLOUD.CombinedCamera) {
            if (camera.isPerspective) {
                this.ray.origin.copy(camera.position);
                this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(camera.position).normalize();
            } else {
                this.ray.origin.set(coords.x, coords.y,( camera.near + camera.far ) / ( camera.near - camera.far )).unproject(camera);
                this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            }
        } else if (camera instanceof THREE.PerspectiveCamera) {
            this.ray.origin.copy(camera.position);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(camera.position).normalize();
        } else if (camera instanceof THREE.OrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far )).unproject(camera);
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
        } else {
            console.error('CLOUD.Raycaster: Unsupported camera type.');
        }
    },

    // travesal octree, get octree nodes that intersect with the ray
    intersectOctantForNode: function(octreeRoot, octants) {
        var scope = this;
        var bbox = new THREE.Box3();

		function doIntersect(root) {
			var i;
			var length;
			bbox.set(root.min, root.max);
			if (scope.ray.intersectBox (bbox)) {
				octants.push(root);

				if (root.childOctants) {
					for (i = 0, length = root.childOctants.length; i < length; i++) {
						doIntersect(root.childOctants[i]);
					}
				}
			}
		}

        doIntersect(octreeRoot);
    }
};

// Get distance from the ray origin to the near intersect point to the box
// If the box is not intersected with the ray, return -1
THREE.Ray.prototype.intersectBoxWithDistance = function (box) {

    var tmin, tmax, tymin, tymax, tzmin, tzmax;

    var invdirx = 1 / this.direction.x,
        invdiry = 1 / this.direction.y,
        invdirz = 1 / this.direction.z;

    var origin = this.origin;

    if ( invdirx >= 0 ) {

        tmin = ( box.min.x - origin.x ) * invdirx;
        tmax = ( box.max.x - origin.x ) * invdirx;

    } else {

        tmin = ( box.max.x - origin.x ) * invdirx;
        tmax = ( box.min.x - origin.x ) * invdirx;

    }

    if ( invdiry >= 0 ) {

        tymin = ( box.min.y - origin.y ) * invdiry;
        tymax = ( box.max.y - origin.y ) * invdiry;

    } else {

        tymin = ( box.max.y - origin.y ) * invdiry;
        tymax = ( box.min.y - origin.y ) * invdiry;

    }

    if ( ( tmin > tymax ) || ( tymin > tmax ) ) return -1;

    // These lines also handle the case where tmin or tmax is NaN
    // (result of 0 * Infinity). x !== x returns true if x is NaN

    if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

    if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

    if ( invdirz >= 0 ) {

        tzmin = ( box.min.z - origin.z ) * invdirz;
        tzmax = ( box.max.z - origin.z ) * invdirz;

    } else {

        tzmin = ( box.max.z - origin.z ) * invdirz;
        tzmax = ( box.min.z - origin.z ) * invdirz;

    }

    if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return -1;

    if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

    if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

    if ( tmax < 0 ) return -1;

    if (tmin < 0) return 0;

    // get the near intersect point
    var optionalTarget = this.at( tmin >= 0 ? tmin : tmax );

    // get distance from the near point to ray origin
    var dx = optionalTarget.x - origin.x;
    var dy = optionalTarget.y - origin.y;
    var dz = optionalTarget.z - origin.z;
    return Math.sqrt( dx * dx + dy * dy + dz * dz);
};