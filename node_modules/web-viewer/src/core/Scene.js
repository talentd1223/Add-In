CLOUD.ObjectGroupType = {
    // Geometries imported from models
    GEOMETRY: "Geometry",

    INSTANCEGEOMETRY: "InstanceGeometry",
    INSTANCEWIREFRAMEGEOMETRY: "InstanceWireframeGeometry",
    // wireframe of geometries
    WIREFRAME: "Wireframe",
    // marker
    MARKER3D: "Marker3D",
    CLIPPLANE: "ClipPlane",
    FILLCLIPPLANE: "FillClipPlane",
    // IBL cube mesh
    IBLCUBE: "IBLCube",
    // planes added by customer with API
    CUSTOMPLANE: "CustomPlane",
    // pivot ball on mobile platform
    PIVOTBALL: "PivotBall",
	// Measure pick point
    MEASUREPICKPOINT: 'MeasurePickPoint',
    // Measure pick line
    MEASUREPICKLINE: 'MeasurePickLine',
    // Measure pick plane
    MEASUREPLANE: 'MeasurePlane',
    // Measure line
    MEASURELINE: 'MeasureLine',
    // octree node bounding box for debugging
    OCTREENODE: "OctreeNode",

    AREANODE: 'AreaNode',
    AXISGRIDMANAGER:'AxisGridManager',

    EXTRUDEBODYMANAGER: 'ExtrudeBodyManager'
};

CLOUD.Scene = function () {

    THREE.Object3D.call(this);

    this.type = 'Scene';
    this.autoUpdate = false; // 不自动更新

    // groups for displayable objects. All displayable object should belong to a group
    this.objectGroups = new CLOUD.ObjectGroup();
    this.add(this.objectGroups);

    // group that contains geometry meshes of all models
    this.geometryGroup = new CLOUD.ObjectGroup(CLOUD.ObjectGroupType.GEOMETRY, {
        pickableType: CLOUD.PICKABLETYPE.Geometry,
        globalSpace: true
    });
    this.objectGroups.add(this.geometryGroup);

    this.pool = new CLOUD.ObjectPool(CLOUD.MeshEx, 0);

    this.clipPlanes = null;
    this.fillClipPlane = null;
    this.areaNode = null;
    this.extrudeBodyManager = null;
    this.axisGridManager = null;

    this.IBLMaps = new ImageBasedLighting.IBLMaps();

    this.transformMatrix = new THREE.Matrix4(); // 用于保存变换后的矩阵 - 兼容处理，以后要删除

    this.lightArray = [];
    this.lightHelperArray = [];

    this.lightHelper = false;
    this.lightPreset();
};

CLOUD.Scene.prototype = Object.create(THREE.Object3D.prototype);
CLOUD.Scene.prototype.constructor = CLOUD.Scene;

CLOUD.Scene.prototype.destroy = function () {

    this.clearLight();
    this.clearLightHelper();

    if (this.sunLight) {
        this.remove(this.sunLight);
        this.sunLight = null;
    }

    if (this.fillLight0) {
        this.remove(this.fillLight0);
        this.fillLight0 = null;
    }

    if (this.fillLight1) {
        this.remove(this.fillLight1);
        this.fillLight1 = null;
    }

    if (this.fillLight2) {
        this.remove(this.fillLight2);
        this.fillLight2 = null;
    }

    if (this.hemisphereLight) {
        this.remove(this.hemisphereLight);
        this.hemisphereLight = null;
    }

    if (this.dirLight) {
        this.remove(this.dirLight);
        this.dirLight = null;
    }


    this.clearAll();

    this.pool.destroy();
    this.pool = null;

    //this.clipPlanes = null;
    //this.fillClipPlane = null;
};

CLOUD.Scene.prototype.resizePool = function (size) {

    if (!CLOUD.GlobalData.BatchMergeEnabled) {
        this.geometryGroup.clear();
        this.pool.resize(size, {parent: this.geometryGroup});
    }

};

/**
 * 清除场景数据
 *
 */
CLOUD.Scene.prototype.clearAll = function () {

    this.pool.clear();
    this.autoUpdate = false;
};

/**
 * 获得场景模型数据根节点
 *
 */
CLOUD.Scene.prototype.getRootNode = function () {
    return this.geometryGroup;
};


/**
 * 获得的场景包围盒(场景变换后,即工作区坐标系下)
 *
 */
CLOUD.Scene.prototype.getBoundingBox = function () {

    var box = new THREE.Box3();

    return function () {
        box.copy(this.geometryGroup.boundingBox);
        box.applyMatrix4(this.geometryGroup.matrix);
        return box;
    };

}();

/**
 * 获得的场景包围盒(场景变换前)
 *
 */
CLOUD.Scene.prototype.getBoundingBoxWorld = function () {
    return this.geometryGroup.boundingBox.clone();
};

/**
 * 获得场景变换矩阵
 *
 */
CLOUD.Scene.prototype.getMatrixGlobal = function () {
    return this.geometryGroup.matrix.clone();
};

CLOUD.Scene.prototype.getGlobalScaleFactor = function(){
    return this.geometryGroup.matrix.elements[0];
}

/**
 * 获得场景世界变换矩阵
 *
 */
CLOUD.Scene.prototype.getMatrixWorldGlobal = function () {
    return this.geometryGroup.matrixWorld;
};

/**
 * 获得场景旋转角度(Euler)
 *
 */
CLOUD.Scene.prototype.getRotationGlobal = function () {

    if (this.geometryGroup.matrix) {

        var rotMat = new THREE.Matrix4();
        rotMat.extractRotation(this.geometryGroup.matrix);

        var rotation = new THREE.Euler();
        rotation.setFromRotationMatrix(rotMat);

        return rotation;
    }

    return null;
};

/**
 * 获取相机到场景包围盒8个顶点的最大距离对应点所在平面与所给射线的交点
 *
 * @param {Object} direction - 相机方向
 * @param {Object} ray - 射线
 * @return {Object} 交点
 */
CLOUD.Scene.prototype.getTrackingPointFromBoundingBox = function (direction, ray) {

    if (!this.geometryGroup.boundingBox) return null;

    var position = ray.origin;
    var box = this.getBoundingBox();
    var maxLen = 0;

    var corners = [
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3()
    ];

    corners[0].set(box.min.x, box.min.y, box.min.z); // 000
    corners[1].set(box.min.x, box.min.y, box.max.z); // 001
    corners[2].set(box.min.x, box.max.y, box.min.z); // 010
    corners[3].set(box.min.x, box.max.y, box.max.z); // 011
    corners[4].set(box.max.x, box.min.y, box.min.z); // 100
    corners[5].set(box.max.x, box.min.y, box.max.z); // 101
    corners[6].set(box.max.x, box.max.y, box.min.z); // 110
    corners[7].set(box.max.x, box.max.y, box.max.z);  // 111

    for (var i = 0; i < 8; i++) {

        var v = new THREE.Vector3();
        v.subVectors(corners[i], position);

        var len = v.dot(direction);

        if (maxLen < len) {
            maxLen = len;
        }
    }

    var offsetVec = direction.clone().multiplyScalar(maxLen);
    var coplanarPoint = position.clone().add(offsetVec);

    var plane = new THREE.Plane();
    plane.setFromNormalAndCoplanarPoint(direction, coplanarPoint);

    return ray.intersectPlane(plane);
};

CLOUD.Scene.prototype.getNearDepthByRect = function () {

    var box = new THREE.Box3();
    var nearDepth = Infinity;
    var projectScreenMatrix = new THREE.Matrix4();
    var projectPosition = new THREE.Vector3();

    // 计算最近的深度
    function calcNearDepth(object) {
        projectPosition.setFromMatrixPosition(object.matrixWorld);
        projectPosition.applyProjection(projectScreenMatrix);

        var depth = projectPosition.z;

        if (depth < nearDepth && depth >= 0 && depth <= 1) {
            nearDepth = depth;
        }
    }

    function intersectObjectByBox(frustum, object) {

        if (object.boundingBox && !(object instanceof THREE.Mesh)) {
            box.copy(object.boundingBox);
            box.applyMatrix4(object.matrixWorld);
        }
        else {
            var geometry = object.geometry;

            if (geometry.boundingBox === null)
                geometry.computeBoundingBox();

            box.copy(geometry.boundingBox);
            box.applyMatrix4(object.matrixWorld);
        }

        return frustum.intersectsBox(box);
    }

    return function (frustum, camera) {
        nearDepth = Infinity;
        projectScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

        function frustumTest(node) {

            if (node instanceof CLOUD.MeshEx) {

                if (!intersectObjectByBox(frustum, node)) {
                    return;
                }

                // 计算最近的深度
                calcNearDepth(node);
            }
            else if (node.worldBoundingBox) {

                if (!frustum.intersectsBox(node.worldBoundingBox)) {
                    return;
                }

                // 计算最近的深度
                calcNearDepth(node);
            }

            var children = node.children;
            if (!children)
                return;

            for (var i = 0, l = children.length; i < l; i++) {
                var child = children[i];
                if (child.visible) {
                    frustumTest(child);
                }
            }
        }

        var children = this.geometryGroup.children;
        for (var i = 0, l = children.length; i < l; i++) {
            var child = children[i];
            if (child.visible) {
                frustumTest(child);
            }
        }

        return nearDepth;
    }
}();

CLOUD.Scene.prototype.getClipPlanes = function () {

    if (this.clipPlanes == null) {
        var bbox = this.getBoundingBox();
        this.clipPlanes = new CLOUD.ClipPlanes(bbox.getSize(), bbox.getCenter());
        this.objectGroups.add(this.clipPlanes);
    }

    return this.clipPlanes;
};

CLOUD.Scene.prototype.resetClipPlanes = function(){
    var clipPlanes = this.getClipPlanes();
    var bbox = this.getBoundingBox();
    clipPlanes.reset();
    clipPlanes.setSectionBox(bbox.min,bbox.max);
}

CLOUD.Scene.prototype.getFillClipPlane = function () {

    if (this.fillClipPlane == null) {
        var bbox = new THREE.Box3();
        bbox.copy(this.geometryGroup.boundingBox);
        bbox.applyMatrix4(this.geometryGroup.matrix);

        this.fillClipPlane = new CLOUD.FillClipPlane(bbox.getSize(), bbox.getCenter());
        this.objectGroups.add(this.fillClipPlane);
    }

    return this.fillClipPlane;
};

CLOUD.Scene.prototype.disableClipPlanes = function(){
    if(this.clipPlanes != null){
        this.clipPlanes.enable(false, false);
        this.clipPlanes.update();
    }
    if(this.fillClipPlane != null){
        this.fillClipPlane.enable(false, false);
        this.fillClipPlane.update();
    }
}


CLOUD.Scene.prototype.getAreaNode = function () {

    if (this.areaNode == null) {

        this.areaNode = new CLOUD.AreaNode();
        this.objectGroups.add(this.areaNode);
        this.areaNode.matrix.copy(this.geometryGroup.matrix);
        this.areaNode.matrixAutoUpdate = false;
        this.areaNode.updateMatrixWorld(true);

    }

    return this.areaNode;
};

CLOUD.Scene.prototype.getAxisGridManager = function () {
    if(this.axisGridManager == null)
    {
        this.axisGridManager = new CLOUD.AxisGridManager();
        this.objectGroups.add(this.axisGridManager);
        this.axisGridManager.matrix.copy(this.geometryGroup.matrix);
        this.axisGridManager.matrixAutoUpdate = false;
        this.axisGridManager.updateMatrixWorld(true);
    
    }
    return this.axisGridManager;
};

CLOUD.Scene.prototype.getExtrudeBodyManager = function () {
    if(this.extrudeBodyManager == null)
    {
        this.extrudeBodyManager = new CLOUD.ExtrudeBodyManager();
        this.objectGroups.add(this.extrudeBodyManager);
        this.extrudeBodyManager.matrix.copy(this.geometryGroup.matrix);
        this.extrudeBodyManager.matrixAutoUpdate = false;
        this.extrudeBodyManager.updateMatrixWorld(true);
    
    }
    return this.extrudeBodyManager;
};


/**
 * Shrink distance (near/far) scope with enabled clip planes.
 *
 * @param {THREE.Ray} ray - Ray object to intersect with clip planes
 * @param {Object} scope - near and far distance scope to the ray origin
 */
CLOUD.Scene.prototype.shrinkScopeByClipPlane = function (ray, scope) {
    if (this.clipPlanes && this.clipPlanes.isEnabled()) {

        var hit = this.clipPlanes.hitTest(ray);

        if (hit.distance == null)
            return;

        if (hit.sign) {
            if (hit.distance > scope.near) {
                scope.near = hit.distance;
            }
        }
        else if (hit.distance < scope.far) {
            scope.far = hit.distance;
        }
    }
};

/* NOT USED
 CLOUD.Scene.prototype.traverseIf = function (callback) {

 function traverseChild(node, callback) {

 var children = node.children;

 for (var i = 0, len = children.length; i < len; i++) {

 var child = children[i];

 if (!callback(child, node)) {
 break;
 }

 if (child.visible) {
 traverseChild(child, callback);
 }
 }
 }

 var children = this.geometryGroup.children;

 for (var i = 0, len = children.length; i < len; i++) {
 var child = children[i];
 traverseChild(child, callback);
 }
 };

 CLOUD.Scene.prototype.findNode = function (sceneId) {

 var children = this.geometryGroup.children;

 for (var i = 0, l = children.length; i < l; i++) {

 var child = children[i];

 if (child.userData && sceneId == child.userData.sceneId) {
 return child;
 }
 }

 return null;
 };

 CLOUD.Scene.prototype.getNodeById = function (id) {

 var children = this.geometryGroup.children;

 for (var i = 0, l = children.length; i < l; i++) {

 var node = children[i];

 if (id === node.name) {
 return node;
 }
 }

 return null;
 };

 CLOUD.Scene.prototype.showNodes = function (model, bVisible) {

 var children = this.geometryGroup.children;

 for (var i = 0, len = children.length; i < len; i++) {

 var child = children[i];

 if (child.databagId === model.databagId) {
 child.visible = bVisible;
 }
 }
 };

 CLOUD.Scene.prototype.containsBoxInFrustum = function () {

 var p1 = new THREE.Vector3(),
 p2 = new THREE.Vector3();

 return function (frustum, box) {

 var planes = frustum.planes;

 for (var i = 0; i < 6; i++) {
 var plane = planes[i];

 p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
 p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
 p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
 p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
 p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
 p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

 var d1 = plane.distanceToPoint(p1);
 var d2 = plane.distanceToPoint(p2);

 // if one outside plane, is not contained.

 if (d1 < 0 || d2 < 0) {
 return false;
 }
 }

 return true;
 };

 }();
 */

CLOUD.Scene.prototype.updateWorldMatrix = function (position, rotation, scale) {

    var matrix = new THREE.Matrix4();
    matrix.compose(position, rotation, scale);

    this.updateWorldMatrixByMatrix(matrix);
};

CLOUD.Scene.prototype.updateWorldMatrixByMatrix = function (matrix) {

    var groups = this.objectGroups.children;

    for (var i = 0, len = groups.length; i < len; i++) {
        if (groups[i].globalSpace) {
            groups[i].matrix.copy(matrix);
            groups[i].matrixAutoUpdate = false;
            groups[i].updateMatrixWorld(true);
        }
    }
};

CLOUD.Scene.prototype.clearLight = function () {

    for (var i = 0; i < this.lightArray.length; i++) {
        var light = this.lightArray[i];
        this.remove(light);
    }
    this.lightArray = [];

}

CLOUD.Scene.prototype.defaultLightPreset = function () {

    var initIntensity = 0.3;
    if (!this.hemisphereLight) {
        this.hemisphereLight = new THREE.HemisphereLight(0xffffff, 0xffffff, initIntensity * CLOUD.GlobalData.LightIntensityFactor);
    }

    this.add(this.hemisphereLight);
    this.lightArray.push(this.hemisphereLight);

    this.hemisphereLight.initIntensity = initIntensity;
    this.hemisphereLight.position.set(0, 500, 0);
    this.hemisphereLight.updateMatrixWorld(true);

    initIntensity = 0.7;
    if (!this.dirLight) {
        this.dirLight = new THREE.DirectionalLight(0xffffff, initIntensity * CLOUD.GlobalData.LightIntensityFactor);
    }

    this.add(this.dirLight);
    this.lightArray.push(this.dirLight);

    this.dirLight.initIntensity = initIntensity;
    this.dirLight.color.setHSL(0.1, 1, 0.95);
    this.dirLight.position.set(-1, 0.75, 1);
    this.dirLight.position.multiplyScalar(50);

}

CLOUD.Scene.prototype.updateDefaultLight = function (cameraDir) {

    var dirLight = this.dirLight;
    dirLight.intensity = dirLight.initIntensity * CLOUD.GlobalData.LightIntensityFactor;
    dirLight.position.set(cameraDir.x, cameraDir.y, cameraDir.z);
    dirLight.updateMatrixWorld(true);

    var hemisphereLight = this.hemisphereLight;
    hemisphereLight.intensity = hemisphereLight.initIntensity * CLOUD.GlobalData.LightIntensityFactor;

}

CLOUD.Scene.prototype.setupCommonLight = function () {

    if (!this.ambientLight) {
        this.ambientLight = new THREE.AmbientLight(0xffffff, 0.60);
    }
    this.ambientLight.intensity = 0.6;

    this.add(this.ambientLight);
    this.lightArray.push(this.ambientLight);

    if (!this.sunLight) {
        this.sunLight = new THREE.DirectionalLight(0xffffff, 1);
    }

    this.add(this.sunLight);
    this.lightArray.push(this.sunLight);

    this.sunLight.color.setHex(0xe1d6c4);
    this.sunLight.position.set(-100, 160, 100);
    this.sunLight.intensity = 0.72;
    this.sunLight.distance = 300;
    this.sunLight.updateMatrixWorld();

}

CLOUD.Scene.prototype.lightPreset01 = function () {

    this.setupCommonLight();

    if (!this.fillLight01) {
        this.fillLight01 = new THREE.DirectionalLight(0xffffff, 1);
    }

    this.add(this.fillLight01);
    this.lightArray.push(this.fillLight01);

    this.fillLight01.color.setHex(0xffffff);
    this.fillLight01.position.set(100, 100, 100);
    this.fillLight01.intensity = 1.0;
    this.fillLight01.updateMatrixWorld();

    if (!this.fillLight02) {
        this.fillLight02 = new THREE.DirectionalLight(0xffffff, 1);
    }

    this.add(this.fillLight02);
    this.lightArray.push(this.fillLight02);

    this.fillLight02.color.setHex(0xffffff);
    this.fillLight02.position.set(-100, 100, -100);
    this.fillLight02.intensity = 0.24;
    this.fillLight02.updateMatrixWorld();

    this.ambientLight.intensity = 0.6;
    this.sunLight.intensity = 0.9;

}

CLOUD.Scene.prototype.lightPreset02 = function () {

    this.setupCommonLight();

    if (!this.fillLight01) {
        this.fillLight01 = new THREE.DirectionalLight(0xffffff, 1);
    }

    this.add(this.fillLight01);
    this.lightArray.push(this.fillLight01);

    this.fillLight01.position.set(60, 80, 130);
    this.fillLight01.intensity = 0.28;
    this.fillLight01.updateMatrixWorld();

    if (!this.fillLight02) {
        this.fillLight02 = new THREE.DirectionalLight(0xffffff, 1);
    }

    this.add(this.fillLight02);
    this.lightArray.push(this.fillLight02);

    this.fillLight02.color.setHex(0x7b9bb4);
    this.fillLight02.position.set(100, 80, -100);
    this.fillLight02.intensity = 0.22;
    this.fillLight02.updateMatrixWorld();

    if (!this.fillLight03) {
        this.fillLight03 = new THREE.DirectionalLight(0xffffff, 1);
    }

    this.add(this.fillLight03);
    this.lightArray.push(this.fillLight03);

    this.fillLight03.color.setHex(0x7b9bb4);
    this.fillLight03.position.set(-140, 80, -50);
    this.fillLight03.intensity = 0.18;
    this.fillLight03.updateMatrixWorld();

}

CLOUD.Scene.prototype.lightPreset = function () {

    this.clearLight();

    if (CLOUD.GlobalData.LightPreset == 0) {
        this.defaultLightPreset();
    }
    else if (CLOUD.GlobalData.LightPreset === 1) {
        this.lightPreset01();
    }
    else if (CLOUD.GlobalData.LightPreset === 2) {
        this.lightPreset02();
    }
    else {
        this.setupCommonLight();
        this.sunLight.color.setHex(0xffffff);
        this.ambientLight.intensity = 0.72;
    }

    if (this.lightHelper) {
        this.addLightHelper();
    }

}

CLOUD.Scene.prototype.clearLightHelper = function () {

    for (var i = 0; i < this.lightHelperArray.length; i++) {
        var lightHelper = this.lightHelperArray[i];
        this.remove(lightHelper);
    }
    this.lightHelperArray = [];

}

CLOUD.Scene.prototype.addLightHelper = function () {

    this.clearLightHelper();

    for (var i = 0; i < this.lightArray.length; ++i) {

        var light = this.lightArray[i];
        if (light instanceof THREE.DirectionalLight) {
            var lightHelper = new THREE.DirectionalLightHelper(light, 200);
            this.add(lightHelper);
            this.lightHelperArray.push(lightHelper);
        }

    }

};

CLOUD.Scene.prototype.updateLightHelper = function () {

    for (var i = 0; i < this.lightHelperArray.length; ++i) {

        var lightHelper = this.lightHelperArray[i];
        lightHelper.update();
        lightHelper.updateMatrixWorld(true);

    }

};

CLOUD.Scene.prototype.updateLights = function (camera) {

    var axisY = new THREE.Vector3(0, 1, 0);
    var angle = Math.PI / 4;
    var scale = 1000.0;
    var height = 600.0;

    var camDirection = camera.position.clone();
    camDirection.sub(camera.target);
    camDirection.normalize();
    if (CLOUD.GlobalData.LightPreset === 1) {

        var lightDir = camDirection.clone().applyAxisAngle(axisY, angle * -1.2);
        this.fillLight01.position.copy(lightDir).normalize();
        this.fillLight01.position.multiplyScalar(scale);
        this.fillLight01.position.y = height;
        this.fillLight01.updateMatrixWorld();

        lightDir = camDirection.clone().applyAxisAngle(axisY, angle * 1.0);
        this.fillLight02.position.copy(lightDir).normalize();
        this.fillLight02.position.multiplyScalar(scale);
        this.fillLight02.position.y = height;
        this.fillLight02.updateMatrixWorld();

    }
    else if (CLOUD.GlobalData.LightPreset === 3) {

        var lightDir = camDirection.clone().applyAxisAngle(axisY, angle * -2);
        this.sunLight.position.copy(lightDir).normalize();
        this.sunLight.position.multiplyScalar(scale);
        this.sunLight.position.y = height;
        this.sunLight.updateMatrixWorld();

    }
    else if (CLOUD.GlobalData.LightPreset === 0){
        this.updateDefaultLight(camDirection);
    }

    if (this.lightHelper) {
        this.updateLightHelper();
    }

};

// create new group or return existed group
// params:   parameters for the group
// 		pickable:  true or false, if objects in this group is pickable by normal editor
//      priority:  priority for display. 0 - 10, larger number has high priority
//                 Note: transparent object is drawn at last
//                       for object in the group, its priority depends on its renderOrder
//      globalSpace: true if this group is in global space (space before scene transfer)
CLOUD.Scene.prototype.getOrCreateObjectGroup = function (name, params) {
    // sort according display priority
    var groups = this.objectGroups.children;
    for (var i = 0, len = groups.length; i < len; i++) {
        if (groups[i].name == name) {
            return groups[i];
        }
    }

    // create new group
    var group = new CLOUD.ObjectGroup(name, params);
    if (group.isGlobalSpace()) {
        // set matrix
        group.matrix.copy(this.geometryGroup.matrix);
        group.matrixAutoUpdate = false;
        group.updateMatrixWorld(true);
    }

    this.objectGroups.add(group); // TODO: order according to priority

    return group;
};

CLOUD.Scene.prototype.getObjectGroup = function (name) {
    var groups = this.objectGroups.children;
    for (var i = 0, len = groups.length; i < len; i++) {
        if (groups[i].name == name) {
            return groups[i];
        }
    }

    return null;
};

CLOUD.Scene.prototype.getObjectGroups = function () {
    return this.objectGroups.children;
};

CLOUD.Scene.prototype.removeObjectGroup = function (group) {
    this.objectGroups.remove(group);
};

// remove object group from object group array according to name
CLOUD.Scene.prototype.removeObjectGroupByName = function (name) {
    //
    this.objectGroups.removeByName(name);
};

CLOUD.Scene.prototype.hasObjectGroup = function (name) {

    return this.objectGroups.hasChild(name);
};

CLOUD.Scene.prototype.intersectToWorld = function (intersect) {

    // 注意：不确定相对坐标位置是否被其他模块使用，暂时先采用新的变量来保存世界坐标下的位置及包围盒
    // 最好是在求交点的时候，包围盒就和位置一起进行坐标变换, 就可以免除这里的计算了
    var sceneMatrix = this.getMatrixGlobal();

    // 获得世界坐标下的位置
    intersect.worldPosition = CLOUD.GeomUtil.getWorldPositionOfMesh(intersect.point, sceneMatrix);
    // 获得世界坐标下的包围盒
    intersect.worldBoundingBox = CLOUD.GeomUtil.getBoundingBoxWorldOfMesh(intersect.object, sceneMatrix);
};

/**
 * 世界坐标转绘图空间(场景变换后)坐标
 *
 * @param {object} point - 世界坐标下的点集 {x:0, y:0, z:0}
 * @return {object} 绘图区域坐标 {x:0, y:0, z:0}
 */
CLOUD.Scene.prototype.worldToDrawing = function (point) {

    var sceneMatrix = this.getMatrixGlobal();

    // 进行场景变换，获得场景变换后的世界坐标
    var result = new THREE.Vector3(point.x, point.y, point.z);
    result.applyMatrix4(sceneMatrix);

    return result;
};

/**
 * 绘图空间(场景变换后)坐标转世界坐标
 *
 * @param {object} point - 绘图区域坐标下的点集 {x:0, y:0, z:0}。
 * @return {object} 世界坐标 {x:0, y:0, z:0}
 */
CLOUD.Scene.prototype.drawingToWorld = function (point) {

    var sceneMatrix = this.getMatrixGlobal();

    var inverseScaleMatrix = new THREE.Matrix4();
    inverseScaleMatrix.getInverse(sceneMatrix);

    // 计算世界坐标下的位置
    var result = new THREE.Vector3(point.x, point.y, point.z);
    result.applyMatrix4(inverseScaleMatrix);

    return result;
};

/**
 * 获得mesh的包围盒
 *
 */
CLOUD.Scene.prototype.getBoundingBoxWorldByMesh = function (mesh) {

    var sceneMatrix = this.getMatrixGlobal();

    // 计算世界坐标下的包围盒
    var bBox = mesh.boundingBox;

    if (!bBox) {

        if (!mesh.geometry.boundingBox) {
            mesh.geometry.computeBoundingBox();
        }

        bBox = mesh.geometry.boundingBox;
    }

    var boundingBox = bBox.clone();
    boundingBox.applyMatrix4(mesh.matrixWorld);

    var inverseScaleMatrix = new THREE.Matrix4();
    inverseScaleMatrix.getInverse(sceneMatrix);
    boundingBox.applyMatrix4(inverseScaleMatrix);

    return boundingBox;
};

/**
 * 获得对象池
 *
 */
CLOUD.Scene.prototype.getObjectPool = function () {

    return this.pool;
};

/**
 * 设置 boundingbox
 *
 */
CLOUD.Scene.prototype.setBoundingBoxWorld = function (boundingBox) {

    if (this.geometryGroup.boundingBox) {
        this.geometryGroup.boundingBox.copy(boundingBox);
    } else {
        this.geometryGroup.boundingBox = boundingBox;
    }

};

/**
 * Get bounding box of gemoetries.
 *
 * param {Object} ids - mesh ids, if the ids is null, get bounding box for all geometry
 */
CLOUD.Scene.prototype.getBoundingBoxOfGeometries = function (ids) {
    var calculateAll = !ids;

    var bbox = new THREE.Box3();

    var pool = this.pool._pool;
    for (var i = 0, len = this.pool.counter; i < len; ++i) {

        var object = pool[i];
        if (!object.isVisible())
            continue;

        var geometry = object.geometry;

        if (!geometry) {
            CLOUD.Logger.log("empty geometry!");
            continue;
        }

        if (calculateAll || ids[object.name] !== undefined) {

            if (!geometry.boundingBox) {
                geometry.computeBoundingBox();
            }

            var box = geometry.boundingBox;

            if (box) {

                var boxTmp = box.clone();

                if (object.matrixWorld) {
                    boxTmp.applyMatrix4(object.matrixWorld);
                }

                bbox.expandByPoint(boxTmp.min);
                bbox.expandByPoint(boxTmp.max);
            }
        }

    }

    return bbox;
};

/**
 * 获得默认场景变换矩阵 - 兼容处理，以后要删除
 *
 */
CLOUD.Scene.prototype.getTransformMatrixGlobal = function () {
    return this.transformMatrix;
};

/**
 * 设置默认场景变换矩阵 - 兼容处理，以后要删除
 *
 */
CLOUD.Scene.prototype.setTransformMatrixGlobal = function (matrix) {
    this.transformMatrix.copy(matrix);
};
