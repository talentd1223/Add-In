CLOUD.FillClipPlane = function (size, center) {

    CLOUD.ObjectGroup.call(this, CLOUD.ObjectGroupType.FILLCLIPPLANE, {priority: 20});

    this.cubeSize = size.clone();
    this.center = center.clone();
    this.length = Math.max(this.cubeSize.x, Math.max(this.cubeSize.y, this.cubeSize.z));

    this.planeOffset = 0.0;
    this.normalIndex = 3;

    this.visible = false;
    this.rotatable = false;

    this.hit = false;

    this.clipplane = new THREE.Vector4();

    this.uniforms = {
        iClipPlane: {value: 0},
        vClipPlane: {value: new Array(new THREE.Vector4())}
    };

    this.planeMaterial = new CLOUD.PhongLightingMaterial({
        color: 0x6699CC,
        opacity: 0.3,
        transparent: true,
        side: THREE.DoubleSide,
        lights: true
    });

    this.planeHighLightMatrial = new CLOUD.PhongLightingMaterial({
        color: 0x00FF80,
        opacity: 0.3,
        transparent: true,
        side: THREE.DoubleSide,
        lights: true
    });

    this.initPlaneModel = function () {

        var len = this.children.length;
        for (var i = len - 1; i >= 0; --i) {
            this.remove(this.children[i]);
        }

        this.planeOffset = 0.0;

        var max = this.length;
        var plane = new THREE.PlaneGeometry(max, max);
        var planeMesh = new THREE.Mesh(plane, this.planeMaterial.clone());
        planeMesh.name = "fillClipPlane";
        planeMesh.customTag = true;
        planeMesh.renderOrder = 90;

        this.position.copy(this.center);

        this.clipplane.set(0, 0, 1, 0);

        this.add(planeMesh);

    };

    this.updateClippingParams = function(uniforms){

    };

    this.enable = function(enable, visible) {
        this.visible = visible;
        this.uniforms.iClipPlane.value = enable ? 1 : 0;
        this.update();
    };

    this.isEnabled = function () {
        return this.uniforms.iClipPlane.value == 0 ? false : true;
    };

    this.update = function () {
        this.updateMatrixWorld();
        var m = new THREE.Matrix4();
        m.getInverse(this.matrix);
        m.transpose();
        this.uniforms.vClipPlane.value[0] = this.clipplane.clone().applyMatrix4(m);
        this.updateClippingParams(this.uniforms);
    };

    this.getClipPlane = function(){

        return this.clipplane.clone();
    };

    this.offset = function (offset) {

        var length = 0.0;
        if (this.normalIndex < 2) length = this.cubeSize.x;
        else if (this.normalIndex < 4) length = this.cubeSize.z;
        else if (this.normalIndex < 6) length = this.cubeSize.y;

        this.planeOffset += offset;
        if (Math.abs(this.planeOffset) > length * 0.5) 
            this.planeOffset = this.planeOffset > 0 ? length * 0.5 : -length * 0.5;

        var tempClipPlane = this.uniforms.vClipPlane.value[0].clone();
        var tempNormal = new THREE.Vector3(tempClipPlane.x, tempClipPlane.y, tempClipPlane.z);
        tempNormal.normalize();
        var offsetVector = new THREE.Vector3(tempNormal.x * this.planeOffset, tempNormal.y * this.planeOffset, tempNormal.z * this.planeOffset);
        this.position.copy(this.center).add(offsetVector);

        this.update();

    };

    this.setOffset = function (offset) {

        var length = 0.0;
        if (this.normalIndex < 2) length = this.cubeSize.x;
        else if (this.normalIndex < 4) length = this.cubeSize.z;
        else if (this.normalIndex < 6) length = this.cubeSize.y;

        this.planeOffset = offset;
        if (Math.abs(offset) > length * 0.5) 
            this.planeOffset = offset > 0 ? length * 0.5 : -length * 0.5;

        var tempClipPlane = this.uniforms.vClipPlane.value[0].clone();
        var tempNormal = new THREE.Vector3(tempClipPlane.x, tempClipPlane.y, tempClipPlane.z);
        tempNormal.normalize();
        var offsetVector = new THREE.Vector3(tempNormal.x * this.planeOffset, tempNormal.y * this.planeOffset, tempNormal.z * this.planeOffset);
        this.position.copy(this.center).add(offsetVector);

        this.update();

    };

    //模型坐标系是Z轴朝上，OpenGL坐标系是Y轴朝上，平面模型在模型坐标系中是XOZ平面-Y法线
    this.changeNormal = function(index) {

        var mesh = this.children[0];
        if (index == 0) {
            this.clipplane.set(1, 0, 0, 0);// OpenGL中的X法线
            mesh.rotation.set(0.0, Math.PI / 2, 0.0);// 旋转到模型YOZ平面
        }
        else if (index == 1) {
            this.clipplane.set(-1, 0, 0, 0);// OpenGL中的-X法线
            mesh.rotation.set(0.0, -Math.PI / 2, 0.0);// 旋转到模型YOZ平面
        }
        else if (index == 2) {
            this.clipplane.set(0, 0, -1, 0);// OpenGL中的-Z法线
            mesh.rotation.set(Math.PI, 0.0, 0.0);// 旋转到模型XOZ平面
        }
        else if (index == 3) {
            this.clipplane.set(0, 0, 1, 0);// OpenGL中的Z法线
            mesh.rotation.set(0.0, 0.0, 0.0);// 旋转到模型XOZ平面
        }
        else if (index == 4) {
            this.clipplane.set(0, 1, 0, 0);// OpenGL中的Y法线
            mesh.rotation.set(-Math.PI / 2, 0.0, 0.0);// 旋转到模型XOY平面
        }
        else if (index == 5) {
            this.clipplane.set(0, -1, 0, 0);// OpenGL中的-Y法线
            mesh.rotation.set(Math.PI / 2, 0.0, 0.0);// 旋转到模型XOY平面
        }

        this.normalIndex = index;
        
        mesh.updateMatrixWorld();
        this.update();

    };

    var tempQuaternion = new THREE.Quaternion();

    var unitX = new THREE.Vector3(1.0, 0.0, 0.0);
    this.rotX = function (rot) {
        tempQuaternion.setFromAxisAngle(unitX, rot);
        this.quaternion.multiply(tempQuaternion);
        this.update();
    };

    var unitY = new THREE.Vector3(0.0, 1.0, 0.0);
    this.rotY = function (rot) {
        tempQuaternion.setFromAxisAngle(unitY, rot);
        this.quaternion.multiply(tempQuaternion);
        this.update();
    };

    this.highLight = function () {
        this.children[0].material = this.planeHighLightMatrial.clone();
    };

    this.cancelHighLight = function () {
        this.children[0].material = this.planeMaterial.clone();
        this.hit = false;
    };

    var FillClipPlaneInfo = function (enable, visible, rotatable, planeOffset, position, scale, quaternion, cubeSize, center) {
        this.enable = enable;
        this.visible = visible;
        this.rotatable = rotatable;
        this.planeOffset = planeOffset;
        this.position = position;
        this.scale = scale;
        this.quaternion = quaternion;
        this.cubeSize = cubeSize;
        this.center = center;
    };

    this.store = function () {

        return new FillClipPlaneInfo(this.uniforms.iClipPlane.value ? true : false, this.visible, this.rotatable, this.planeOffset, this.position.clone(), this.scale.clone(), this.quaternion.clone(),
            this.cubeSize.clone(), this.center.clone());

    };

    this.restore = function (info) {

        this.enable(info.enable, info.visible);
        this.rotatable = info.rotatable;
        this.planeOffset = info.planeOffset;
        
        this.position.copy(info.position);
        this.scale.copy(info.scale);

        this.quaternion._w = info.quaternion._w;
        this.quaternion._x = info.quaternion._x;
        this.quaternion._y = info.quaternion._y;
        this.quaternion._z = info.quaternion._z;

        this.update();

    };

    this.setProcess = function (process) {

        var length = 0.0;
        if (this.normalIndex < 2) length = this.cubeSize.x;
        else if (this.normalIndex < 4) length = this.cubeSize.z;
        else if (this.normalIndex < 6) length = this.cubeSize.y;

        if (process > 1.0) process = 1.0;
        else if (process < -1.0) process = -1.0;

        this.planeOffset = process * length * 0.5;

        var tempClipPlane = this.uniforms.vClipPlane.value[0].clone();
        var tempNormal = new THREE.Vector3(tempClipPlane.x, tempClipPlane.y, tempClipPlane.z);
        tempNormal.normalize();
        var offsetVector = new THREE.Vector3(tempNormal.x * this.planeOffset, tempNormal.y * this.planeOffset, tempNormal.z * this.planeOffset);
        this.position.copy(this.center).add(offsetVector);

        this.update();

    };

    this.getProcess = function () {

        var length = 0.0;
        if (this.normalIndex < 2) length = this.cubeSize.x;
        else if (this.normalIndex < 4) length = this.cubeSize.z;
        else if (this.normalIndex < 6) length = this.cubeSize.y;

        return this.planeOffset / length * 2.0;

    };
    
};

CLOUD.FillClipPlane.prototype = Object.create(CLOUD.ObjectGroup.prototype);
CLOUD.FillClipPlane.prototype.constructor = CLOUD.FillClipPlane;

CLOUD.FillClipPlane.prototype.init = function () {
    this.initPlaneModel();
};

CLOUD.FillClipPlane.prototype.hitTest = function (raycaster) {

    if (!this.visible) return;

    var minDistance = null;
    var minSign = null;

    this.hit = this.raycast(raycaster);
    if (this.hit) {
        var ray = raycaster.ray;
        var plane = new THREE.Plane();
        var v4 = this.uniforms.vClipPlane.value[0];
        plane.setComponents(v4.x, v4.y, v4.z, v4.w);
        minDistance = ray.distanceToPlane(plane);
        minSign = ray.direction.dot(plane.normal) < 0;
    }

    return {sign: minSign, distance: minDistance};
};

CLOUD.FillClipPlane.prototype.raycast = function (raycaster, intersects) {
    var planeIntersects = [];
    this.children[0].raycast(raycaster, planeIntersects);
    if (planeIntersects.length > 0) {
        return true;
    }

    return false;
};