CLOUD.ClipPlanes = function (size, center) {
    // high display priority, not pickable by normal editor because ClipPlaneTool will handle the pick
    CLOUD.ObjectGroup.call(this, CLOUD.ObjectGroupType.CLIPPLANE, {priority: 20});

    var faceName = [];
    faceName.push("clipPlane_right");
    faceName.push("clipPlane_left");
    faceName.push("clipPlane_top");
    faceName.push("clipPlane_bottom");
    faceName.push("clipPlane_front");
    faceName.push("clipPlane_back");

    this.cubeSize = size.clone();
    this.cubeSize.x +=0.5;
    this.cubeSize.y +=0.5;
    this.cubeSize.z +=0.5;
    this.center = center.clone();

    this.visible = false;
    this.rotatable = false;

    this.selectIndex = null;

    this.planeOffset = new Array(6);

    this.planeRotate = [0, 0, 0];

    this.uniforms = {
        iClipPlane: {type: "i", value: 0},
        vClipPlane: {
            type: "v4v",
            value: new Array(new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4())
        }
    };

    this.clipplanes = null;

    this.calculation = true;

    this.getPlaneNormal = function (face) {
        var planeNormal = new THREE.Vector4();
        var index = Math.floor(face / 2);
        var mod = face % 2;
        planeNormal.setComponent(index, Math.pow(-1, mod));
        planeNormal["w"] = -this.cubeSize.getComponent(index) * 0.5;
        this.planeOffset[face] = 0;
        return planeNormal;
    };

    this.planeMaterial = new CLOUD.PhongLightingMaterial({
        color: 0x6699CC,
        opacity: 0.3,
        transparent: true,
        side: THREE.DoubleSide,
        lights: true
    });

    this.planeHighLightMatrial = new CLOUD.PhongLightingMaterial({
        color: 0x00FF80,
        opacity: 0.3,
        transparent: true,
        side: THREE.DoubleSide,
        lights: true
    });

    this.initPlaneModel = function (face) {
        var index = Math.floor(face / 2);
        var mod = face % 2;

        var width = (index == 0 ? this.cubeSize.z : this.cubeSize.x);
        var height = (index == 1) ? this.cubeSize.z : this.cubeSize.y;

        var plane = new THREE.PlaneGeometry(width, height);
        var planeMesh = new THREE.Mesh(plane, this.planeMaterial.clone());
        planeMesh.name = faceName[face];
        planeMesh.customTag = true;
        planeMesh.position.setComponent(index, Math.pow(-1, mod) * this.cubeSize.getComponent(index) * 0.5);
        if (index == 0) planeMesh.rotation.y = Math.pow(-1, mod) * Math.PI * 0.5;
        else if (index == 1) planeMesh.rotation.x = Math.pow(-1, mod) * Math.PI * 0.5;
        //else if (index == 2 && mod == 0) planeMesh.rotation.x = Math.PI;

        planeMesh.renderOrder = 90;
        this.add(planeMesh);
    };

    this.initWireframes = function () {
        var vertexs = [
            -this.cubeSize.x * 0.5, -this.cubeSize.y * 0.5, -this.cubeSize.z * 0.5,
            this.cubeSize.x * 0.5, -this.cubeSize.y * 0.5, -this.cubeSize.z * 0.5,
            this.cubeSize.x * 0.5, this.cubeSize.y * 0.5, -this.cubeSize.z * 0.5,
            -this.cubeSize.x * 0.5, this.cubeSize.y * 0.5, -this.cubeSize.z * 0.5,

            -this.cubeSize.x * 0.5, -this.cubeSize.y * 0.5, this.cubeSize.z * 0.5,
            this.cubeSize.x * 0.5, -this.cubeSize.y * 0.5, this.cubeSize.z * 0.5,
            this.cubeSize.x * 0.5, this.cubeSize.y * 0.5, this.cubeSize.z * 0.5,
            -this.cubeSize.x * 0.5, this.cubeSize.y * 0.5, this.cubeSize.z * 0.5
        ];

        var colors = [
            1.0, 1.0, 1.0,
            1.0, 1.0, 1.0,
            1.0, 1.0, 1.0,
            1.0, 1.0, 1.0,
            1.0, 1.0, 1.0,
            1.0, 1.0, 1.0,
            1.0, 1.0, 1.0,
            1.0, 1.0, 1.0
        ];
        var indices = [
            0, 1,
            1, 2,
            2, 3,
            3, 0,
            4, 5,
            5, 6,
            6, 7,
            7, 4,
            0, 4,
            3, 7,
            1, 5,
            2, 6
        ];

        var geometry = new THREE.BufferGeometry();
		var material = new CLOUD.PhongLightingMaterial({
            color: 0xFFFFFF,
            lights: true
        });

        geometry.setIndex( indices );
		geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( vertexs, 3 ) );
        geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
        geometry.computeBoundingSphere();

        var lineMesh = new THREE.LineSegments( geometry, material );
        lineMesh.name = "Wireframes";
        lineMesh.customTag = true;

        this.add(lineMesh);
    };

    this.updateClippingParams = function(uniforms){

    };

    this.enable = function(enable, visible) {
        this.visible = visible;
        this.uniforms.iClipPlane.value = enable ? 6 : 0;
        this.updateClippingParams(this.uniforms);
    };

    this.isEnabled = function () {
        return this.uniforms.iClipPlane.value !== 0 ;
    };

    var ClipPlanesInfo = function (enable, visible, rotatable, calculation, planeOffset, planeRotate, position, scale, quaternion, cubeSize, center) {
        this.enable = enable;
        this.visible = visible;
        this.rotatable = rotatable;
        this.calculation = calculation;
        this.planeOffset = planeOffset.slice(0);
        this.planeRotate = planeRotate.slice(0);
        this.position = position;
        this.scale = scale;
        this.quaternion = quaternion;
        this.cubeSize = cubeSize;
        this.center = center;
    };

    this.store = function () {
        return new ClipPlanesInfo(this.uniforms.iClipPlane.value ? true : false, this.visible, this.rotatable, this.calculation, this.planeOffset, this.planeRotate, this.position.clone(), this.scale.clone(), this.quaternion.clone(),
            this.cubeSize.clone(), this.center.clone());
    };

    this.restore = function (info) {
        this.calculation = true;
        this.calculationPlanes(info.cubeSize, info.center);

        this.enable(info.enable, info.visible);
        this.rotatable = info.rotatable;
        this.calculation = info.calculation;

        for (var i = 0; i < 6; ++i) {
            this.planeOffset[i] = info.planeOffset[i];
        }
        for (var i = 0; i < 3; ++i) {
            this.planeRotate[i] = info.planeRotate[i];
        }
        this.position.copy(info.position);
        this.scale.copy(info.scale);

        this.quaternion._w = info.quaternion._w;
        this.quaternion._x = info.quaternion._x;
        this.quaternion._y = info.quaternion._y;
        this.quaternion._z = info.quaternion._z;

        this.update();
    };

    this.reset = function () {
        this.calculation = true;
        for (var i = 0; i < 6; ++i) {
            this.planeOffset[i] = 0;
        }
        for (var i = 0; i < 3; ++i) {
            this.planeRotate[i] = 0;
        }
        this.position.copy(this.center);
        this.scale.copy(new THREE.Vector3(1.0, 1.0, 1.0));
        this.quaternion.copy(new THREE.Quaternion());
        this.update();
    };

    this.calculationPlanes = function (size, center) {
        if (!this.calculation) return;

        this.cubeSize.copy(size);
        this.center.copy(center);

        var len = this.children.length;
        for (var i = len - 1; i >= 0; --i) {
            this.remove(this.children[i]);
        }

        for (var i = 0; i < 6; ++i) {
            this.uniforms.vClipPlane.value[i] = this.getPlaneNormal(i);
            this.initPlaneModel(i);
        }

        this.initWireframes();

        this.clipplanes = this.uniforms.vClipPlane.value.slice(0);

        this.reset();
    };

    this.update = function () {
        this.updateMatrixWorld();
        var m = new THREE.Matrix4();
        m.getInverse(this.matrix);
        m.transpose();
        for (var i = 0; i < 6; ++i) {
            this.uniforms.vClipPlane.value[i] = this.clipplanes[i].clone().applyMatrix4(m);
        }
        this.updateClippingParams(this.uniforms);
    };

    this.offset = function (face, offset) {
        this.calculation = false;

        var index = Math.floor(face / 2);
        var size = this.cubeSize.getComponent(index) * 0.5;

        if( Math.abs(offset) > size)
            return;

        this.planeOffset[face] += offset;

        var centerOffset = new THREE.Vector3();
        for (var i = 0; i < 6; ++i) {
            var normal = this.clipplanes[i].clone();
            var planeOffset = this.planeOffset[i];
            var deltaOffset = new THREE.Vector3(normal.x * planeOffset, normal.y * planeOffset, normal.z * planeOffset);
            centerOffset.add(deltaOffset);
        }

        var scale = 1 + (centerOffset.getComponent(index) / this.cubeSize.getComponent(index));
        if (scale > 0.0) {
            this.scale.setComponent(index, scale);
            var tempClipPlane = this.uniforms.vClipPlane.value[face].clone();
            var tempNormal = new THREE.Vector3(tempClipPlane.x, tempClipPlane.y, tempClipPlane.z);
            tempNormal.normalize();
            var deltaOffset = offset;
            var offsetVector = new THREE.Vector3(tempNormal.x * deltaOffset, tempNormal.y * deltaOffset, tempNormal.z * deltaOffset);
            if (face % 2 == 1) {
                this.position.sub(offsetVector.multiplyScalar(0.5));
            } else {
                this.position.add(offsetVector.multiplyScalar(0.5));
            }

            this.update();
        } else {
            this.planeOffset[face] -= offset;
        }
    };

    var tempQuaternion = new THREE.Quaternion();

    var unitX = new THREE.Vector3(1.0, 0.0, 0.0);
    this.rotX = function (rot) {
        this.calculation = false;
        tempQuaternion.setFromAxisAngle(unitX, rot);
        this.quaternion.multiply(tempQuaternion);
        this.update();
    };

    var unitY = new THREE.Vector3(0.0, 1.0, 0.0);
    this.rotY = function (rot) {
        this.calculation = false;
        tempQuaternion.setFromAxisAngle(unitY, rot);
        this.quaternion.multiply(tempQuaternion);
        this.update();
    };

    this.setSectionBox = function(min, max) {
        this.calculation = true;
        var cubeSize = new THREE.Vector3(max.x - min.x + 0.5, max.y - min.y + 0.5, max.z - min.z + 0.5);
        var center = new THREE.Vector3((min.x + max.x) * 0.5, (min.y + max.y) * 0.5, (min.z + max.z) * 0.5);
        this.calculationPlanes(cubeSize, center);
    };

    this.moveSectionPlane = function(planeName, offset) {
        var face = -1;
        if (planeName == 'right') {
            face = 0;
        }
        else if(planeName == 'left') {
            face = 1;
        }
        else if(planeName == 'top') {
            face = 2;
        }
        else if(planeName == 'bottom') {
            face = 3;
        }
        else if(planeName == 'front') {
            face = 4;
        }
        else if(planeName == 'back') {
            face = 5;
        }

        if (face != -1) {
            if (face % 2 != 0) {
                offset = -offset;
            }
            var delta = offset - this.planeOffset[face];
            this.offset(face, delta);
        }
    };

    var unitZ = new THREE.Vector3(0.0, 0.0, 1.0);
    this.rotateSectionBox = function(axis, offset) {
        if (axis == 'x') {
            this.planeRotate[0] = offset;
        }
        else if (axis == 'y') {
            this.planeRotate[1] = offset;
        }
        else if (axis == 'z') {
            this.planeRotate[2] = offset;
        }

        this.calculation = true;

        var tempQuaternionX = new THREE.Quaternion();
        tempQuaternionX.setFromAxisAngle(unitX, this.planeRotate[0]);

        var tempQuaternionY = new THREE.Quaternion();
        tempQuaternionY.setFromAxisAngle(unitY, this.planeRotate[1]);

        var tempQuaternionZ = new THREE.Quaternion();
        tempQuaternionZ.setFromAxisAngle(unitZ, this.planeRotate[2]);
        
        var tempQuaternion = new THREE.Quaternion();
        tempQuaternion.multiply(tempQuaternionX);
        tempQuaternion.multiply(tempQuaternionY);
        tempQuaternion.multiply(tempQuaternionZ);
        
        this.quaternion.copy(tempQuaternion);
        this.update();
    };

    this.highLight = function () {
        if (this.selectIndex == null)
            return;
        this.children[this.selectIndex].material = this.planeHighLightMatrial.clone();
    };

    this.cancelHighLight = function () {
        if (this.selectIndex == null)
            return;
        this.children[this.selectIndex].material = this.planeMaterial.clone();
        this.selectIndex = null;
    };
};

CLOUD.ClipPlanes.prototype = Object.create(CLOUD.ObjectGroup.prototype);
CLOUD.ClipPlanes.prototype.constructor = CLOUD.ClipPlanes;

CLOUD.ClipPlanes.prototype.init = function () {
    this.calculationPlanes(this.cubeSize, this.center);
};

CLOUD.ClipPlanes.prototype.hitTest = function (raycaster) {
    var minDistance = null;
    var minSign = null;

    this.raycast(raycaster);
    if (this.selectIndex != null) {
        var ray = raycaster.ray;
        var plane = new THREE.Plane();
        var v4 = this.uniforms.vClipPlane.value[this.selectIndex];
        plane.setComponents(v4.x, v4.y, v4.z, v4.w);
        minDistance = ray.distanceToPlane(plane);
        minSign = ray.direction.dot(plane.normal) < 0;
    }

    return {sign: minSign, distance: minDistance};
};

CLOUD.ClipPlanes.prototype.raycast = function (raycaster) {

    if (!this.visible) return;

    var planeIntersects = [];
    var selectPlane = null;
	
    this.selectIndex = null;
		
    for (var i = 0, len = 6; i < len; i++) {
		this.children[i].raycast(raycaster, planeIntersects);
        if (planeIntersects.length > 0) {
			var plane = planeIntersects.pop();
            if (!selectPlane || plane.distance < selectPlane.distance) {
                selectPlane = plane;
                this.selectIndex = i;
            }
			
			planeIntersects = [];
        }
    }
    
};