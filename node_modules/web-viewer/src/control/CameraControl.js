CLOUD.CameraControl = function (viewer, scene, camera, domElement, onChange) {

    this.viewer = viewer;
    this.camera = camera;
    this.domElement = domElement;
    this.scene = scene;

    this.intersector = new CLOUD.IntersectHelper(viewer);

    var _EPS = 0.000001;
    var _zAxisUp = new THREE.Vector3(0, 1, 0); // const

    var _lastPosition = new THREE.Vector3();
    var _lastQuaternion = new THREE.Quaternion();

    var _lastTrackingPoint;

    var _scope = this;

    var _cameraChanging = false;
	
	this.pivotBallGroup = null;

    this.minDollyDistance = 0.7;

    this.gravity = 0;
    
    /**
     * 判断相机是否发生变化
     *
     * @return {Boolean} 相机是否发生变化
     */
    this.isCameraChanging = function () {
        return _cameraChanging;
    };

    /**
     * 设置相机变化状态
     *
     * @return {Boolean} 相机是否发生变化
     */
    this.setCameraChanging = function (changing) {

        // 批注需要检测相机的变化状态，
        // 之前用的是camera.dirty，现在dirty只用于相机是否需要更新mvp，
        // 导致相机发生变化后，批注状态关闭功能失效，这里简单加入一个状态标识，后续采用消息机制处理
        _cameraChanging = changing;
    };


    /** switch to another camera. */
    this.setCamera = function(camera) {
        this.camera = camera;
    };

    this.getCamera = function () {
        this.camera.updateMVP(); // 获取相机时，更新MVP
        return this.camera;
    };

    this.dirtyCamera = function (dirty) {
        this.camera.dirty = dirty;
    };

    this.getFrustum = function () {
        return this.camera.getFrustum();
    };

    //flag to lock or unlock the rotation along axis z
    this.lockAxisZ = function(isLock){
        CLOUD.EditorConfig.LockAxisZ = isLock;
    };

    this.isLockedAxisZ = function(){
        return CLOUD.EditorConfig.LockAxisZ;
    };

    // TODO: this is not cameraControl's responsibility, get size by viewer.
    this.getClientSize = function() {
        var element = _scope.domElement === document ? _scope.domElement.body : _scope.domElement;

        return new THREE.Vector2(element.clientWidth, element.clientHeight);
    };
	
	this.delayHandle = function () {
		
		function handle() {
            _scope.update(true, true);
		}

		if (this.timeoutId) {
			clearTimeout(this.timeoutId);
		}

		// 延迟200ms以判断是否单击
		this.timeoutId = setTimeout(handle, 200);
		this.needUpdateRenderList(false);
	};

    /**
     *
     * @param delta  distance range in x,y dimension in pixel size
     * @param pivot  rotation pivot
     */
    this.processRotate = function (delta, pivot) {

        var clientSize = this.getClientSize();
		
        // rotating across whole screen goes 360 degrees around
        var thetaDelta = -2 * Math.PI * delta.x / clientSize.x;

        // rotating up and down along whole screen attempts to go 360, but limited to 180
        var phiDelta = -2 * Math.PI * delta.y / clientSize.y;

        _scope.handleRotation(thetaDelta, phiDelta, pivot);
    };

    this.handleRotation = function (thetaDelta, phiDelta, pivot ) {

        var camera = this.camera;
        var position = camera.position;
        var target = camera.target;
        var camDir = camera.getWorldDirection();

        var eye = target.clone().sub(position);
        var eyeDistance = eye.length();

        var viewTrf = null;

        // 调整相机位置
        var adjustCameraPosition = function (trf) {

            var viewVec, viewLength, newViewDir;
            var newTarget = new THREE.Vector3(); // 新目标点

            if (pivot) {

                viewVec = position.clone().sub(pivot);
                viewLength = viewVec.length();
                viewVec.normalize();

                newViewDir = viewVec.clone().applyQuaternion(trf).normalize();

                // 相机新位置
                position.copy(pivot).add(newViewDir.multiplyScalar(viewLength));

                // 保持相机到目标点的距离不变
                camDir.applyQuaternion(trf).normalize();

                // 设置target新位置
                newTarget.copy(position).add(camDir.multiplyScalar(eyeDistance));
                target.copy(newTarget);

            } else {

                viewVec = eye.clone();
                viewLength = eyeDistance;
                viewVec.normalize();

                newViewDir = viewVec.clone().applyQuaternion(trf).normalize();

                // 设置target新位置
                newTarget.copy(position).add(newViewDir.multiplyScalar(viewLength));
                target.copy(newTarget);
            }

        };

        var up = camera.realUp || camera.up;
        var rightDir = camDir.clone().cross(up).normalize();
        var realUp = rightDir.clone().cross(camDir).normalize();
        camera.realUp.copy(realUp);

        var rotAxis;

        // 锁定Z轴
        if (CLOUD.EditorConfig.LockAxisZ) {

            // 水平旋转
            if (Math.abs(thetaDelta) > Math.abs(phiDelta)) {

                rotAxis = _zAxisUp;
                viewTrf = new THREE.Quaternion().setFromAxisAngle(rotAxis, thetaDelta);
                adjustCameraPosition(viewTrf);
                camera.realUp.applyQuaternion(viewTrf).normalize();

            }

        } else {

            // 水平旋转
            if (Math.abs(thetaDelta) > Math.abs(phiDelta)) {

                // remark: this.camera.up 的使用有些奇怪，大多数都被置成了 THREE.Object3D.DefaultUp，后续需要在重新考虑下
                // 当this.camera.up为THREE.Object3D.DefaultUp时，其实水平旋转就是锁定了Z轴的旋转(模型的Z轴对应场景的Y轴)
                rotAxis = camera.up.clone().normalize();
                viewTrf = new THREE.Quaternion().setFromAxisAngle(rotAxis, thetaDelta);
                adjustCameraPosition(viewTrf);
                camera.realUp.applyQuaternion(viewTrf).normalize();

            } else if (Math.abs(phiDelta) > 0.0001) { // 垂直旋转

                rotAxis = camDir.clone().cross(up).normalize();
                viewTrf = new THREE.Quaternion().setFromAxisAngle(rotAxis, phiDelta);
                adjustCameraPosition(viewTrf);
                camera.realUp.applyQuaternion(viewTrf).normalize();

                // 旋转180度时，up的y值应该反向，否则移动会反
                this.adjustCameraUp();
            }

        }

        this.dirtyCamera(true);
        this.setCameraChanging(true); // add
    };

    this.adjustCameraForPan = function(pan) {
        var camera = this.camera;

        camera.target.add(pan);
        camera.position.add(pan);
        this.dirtyCamera(true);
        this.setCameraChanging(true); // add
    };

    // Invoking from viewer.render
    this.updateCamera = function() {

        var camera = this.camera;
        if(!camera.dirty) {
            return;
        }

        camera.lookAt(camera.target);
        camera.updateMVP();
    };

    // Invoking by editor tools
    this.update = function(forceRender, updateRenderList) {

        this.updateCamera();

        var camera = this.camera;
        if (forceRender) {
            //CLOUD.Logger.log("CameraControl.forceRender");
            if (updateRenderList !== undefined) {
                this.needUpdateRenderList(updateRenderList);
            }

            onChange();

            // render 可能会直接返回，这样直接关闭相机状态会出现问题
            // this.setCameraChanging(false); // add

            _lastPosition.copy(camera.position);
            _lastQuaternion.copy(camera.quaternion);
        } else {

            // update condition is:
            // min(camera displacement, camera rotation in radians)^2 > EPS
            // using small-angle approximation cos(x/2) = 1 - x^2 / 8

            if (_lastPosition.distanceToSquared(camera.position) > _EPS
                || 8 * (1 - _lastQuaternion.dot(camera.quaternion)) > _EPS) {

                //CLOUD.Logger.log("CameraControl.render");
                onChange();

                // render 可能会直接返回，这样直接关闭相机状态会出现问题
                // this.setCameraChanging(false); // add

                _lastPosition.copy(camera.position);
                _lastQuaternion.copy(camera.quaternion);
            }
        }

    };
	
	this.updateView = function (updateRenderList) {

        if (updateRenderList !== undefined) {
            this.needUpdateRenderList(updateRenderList);
        }

        onChange();

        // render 可能会直接返回，这样直接关闭相机状态会出现问题
        // this.setCameraChanging(false); // add
    };

	this.updateHighlight = function () {

	    onChange(true);

        // render 可能会直接返回，这样直接关闭相机状态会出现问题
        // this.setCameraChanging(false); // add
    };


    // 是否需要更新RenderList
    this.needUpdateRenderList = function (need) {
        this.viewer.editorManager.isUpdateRenderList = need;
    };

    // pass in x,y of change desired in pixel space,
    // right and down are positive
    this.pan = function (deltaX, deltaY) {
        var element = _scope.domElement === document ? _scope.domElement.body : _scope.domElement;
		var offset = new THREE.Vector3();

		// pass in distance in world space to move left
		function panLeft (distance) {
			var te = _scope.camera.matrix.elements;

			// get X column of matrix
			offset.set(te[0], te[1], te[2]);
			offset.multiplyScalar(-distance);

			_scope.camera.target.add(offset);
			_scope.camera.position.add(offset);
		}

		// pass in distance in world space to move up
		function panUp (distance) {
			var te = _scope.camera.matrix.elements;

			// get Y column of matrix
			offset.set(te[4], te[5], te[6]);
			offset.multiplyScalar(distance);

			_scope.camera.target.add(offset);
			_scope.camera.position.add(offset);
		}

        if (_scope.camera.isPerspective) {
            // perspective
            var position = _scope.camera.position;
            var targetDistance = position.clone().sub(_scope.camera.target).length();

            // half of the fov is center to top of screen
            targetDistance *= Math.tan((_scope.camera.fov / 2) * Math.PI / 180.0);

            //CLOUD.Logger.log(targetDistance);
            // we actually don't use screenWidth, since perspective camera is fixed to screen height
            panLeft(2 * deltaX * targetDistance / element.clientHeight);
            panUp(2 * deltaY * targetDistance / element.clientHeight);
        } else if (_scope.camera.top !== undefined) {
            // orthographic
            panLeft(deltaX * (_scope.camera.right - _scope.camera.left) / element.clientWidth);
            panUp(deltaY * (_scope.camera.top - _scope.camera.bottom) / element.clientHeight);
        } else {
            // camera neither orthographic or perspective
            CLOUD.Logger.warn('WARNING: CloudPickEditor.js encountered an unknown camera type - pan disabled.');
        }

        this.dirtyCamera(true);
        this.setCameraChanging(true); // add
    };

    this.panOnWorld = function () {

        var startPoint = new THREE.Vector3();
        var endPoint = new THREE.Vector3();
        var delta = new THREE.Vector3();

        return function (panStart, panEnd, pan, worldDimension) {

            var canvasContainer = _scope.getContainerDimensions();

            // 规范化开始点
            var canvasX = panStart.x - canvasContainer.left;
            var canvasY = panStart.y - canvasContainer.top;
            startPoint.x = canvasX / canvasContainer.width;
            startPoint.y = canvasY / canvasContainer.height;

            // 规范化结束点
            canvasX = panEnd.x - canvasContainer.left;
            canvasY = panEnd.y - canvasContainer.top;
            endPoint.x = canvasX / canvasContainer.width;
            endPoint.y = canvasY / canvasContainer.height;

            delta.subVectors(endPoint, startPoint);

            var offsetX = -delta.x * worldDimension.x;
            var offsetY = delta.y * worldDimension.y;
            var deltaX = _scope.getWorldRight().multiplyScalar(offsetX);
            var deltaY = _scope.getWorldUp().multiplyScalar(offsetY);

            pan.addVectors(deltaX, deltaY);
            _scope.dirtyCamera(true);
            _scope.setCameraChanging(true); // add
        }

    }();

    this.adjustCameraForDolly = function(scale, dollyPoint){

        var scaleFactor = scale - 1.0;

        if (Math.abs(scaleFactor) < _EPS) {
            return false;
        }

        var camera = this.camera;
        var cameraPosition = camera.position;
        var dirEye = this.getWorldEye();
        var dirDolly = new THREE.Vector3();

        if (!dollyPoint) {
            dirDolly.copy(dirEye);
        } else {
            dirDolly.subVectors(dollyPoint, cameraPosition);
        }

        dirDolly.multiplyScalar(scaleFactor);

        var distance = dirDolly.length();

        // 透视投影下允许穿透
        if (camera.isPerspective) {

            if (distance < this.minDollyDistance) {

                dirDolly.normalize().multiplyScalar(this.minDollyDistance);

            }
        }
        else {

            camera.orthoScale *= scale;
            camera.setZoom(camera.orthoScale);
        }

        var newCameraPosition = new THREE.Vector3();
        newCameraPosition.addVectors(cameraPosition, dirDolly);

        camera.position.copy(newCameraPosition);
        camera.target.copy(dirEye.add(newCameraPosition));
        this.dirtyCamera(true);
        this.setCameraChanging(true); // add
    };

    this.dolly = function (dollyCenterX, dollyCenterY, scale) {

        var pos = new THREE.Vector2(dollyCenterX, dollyCenterY);
        var intersectContext = this.getIntersectContext(pos);
        var centerPosition = this.intersector.hitTest(intersectContext);

        if (centerPosition != null) {
            this.adjustCameraForDolly(scale, centerPosition);
        } else {
            this.adjustCameraForDolly(scale, null);
        }
    };


    this.dollyByPoint = function (cx, cy, scale) {

        var trackingPoint = this.getTrackingPoint(cx, cy);
        this.adjustCameraForDolly(scale, trackingPoint);

    };

    this.endOperation = function () {
        this.intersector.lastIntersect = null;
    };

    // factor (-1, 1): 正数 - 放大， 负数 - 缩小
    this.zoom = function (factor, cx, cy) {
        var scale;
        if (factor > 0) {
            scale = 1.0 / (1 - factor);
            //this.dollyIn(1 - factor);
        } else {
            //this.dollyOut(1 + factor);
            scale = 1 + factor;
        }

        if (cx === undefined || cy === undefined) {
            this.adjustCameraForDolly(scale, null);
        }else {
            this.dollyByPoint(cx, cy, scale);
        }

        this.update();
    };

    /**
     * 获得canvas父容器尺寸 ({width : xxx, height : xxx, left : xxx, top : xxx})
     *
     * @return {Object} 如果父容器存在，则返回父容器尺寸， 否则，返回 null
     */
    this.getContainerDimensions = function () {
        return CLOUD.DomUtil.getContainerOffsetToClient(this.domElement);
    };

    this.computeFrustum = function () {

        var projectionMatrix = new THREE.Matrix4();
        var viewProjectionMatrix = new THREE.Matrix4();

        return function (x1, x2, y1, y2, frustum, dim) {

            var camera = this.camera;

            var ymax = camera.near * Math.tan(THREE.Math.degToRad(camera.fov * 0.5));
            var xmax = ymax * camera.aspect;

            var rx1 = ((x1 - dim.left) / dim.width) * 2 - 1;
            var rx2 = ((x2 - dim.left) / dim.width) * 2 - 1;
            var ry1 = -((y1 - dim.top) / dim.height) * 2 + 1;
            var ry2 = -((y2 - dim.top) / dim.height) * 2 + 1;

            projectionMatrix.makePerspective(rx1 * xmax, rx2 * xmax, ry1 * ymax, ry2 * ymax, camera.near, camera.far);

            camera.updateMatrixWorld();
            camera.matrixWorldInverse.getInverse(camera.matrixWorld);
            viewProjectionMatrix.multiplyMatrices(projectionMatrix, camera.matrixWorldInverse);
            frustum.setFromMatrix(viewProjectionMatrix);

        };

    }();

    this.screenToCanvas = function (cx, cy) {

        var dim = this.getContainerDimensions();
        return {x: cx - dim.left, y: cy - dim.top};

    };

    this.mapScreenToLocal = function (cx, cy, target) {
        var dim = this.getContainerDimensions();
        target.set(cx - dim.left, dim.height - (cy - dim.top));
    };

    this.mapWindowToViewport = function (cx, cy, target) {
        var dim = this.getContainerDimensions();
        var mouse = target || new THREE.Vector2();

        mouse.x = ((cx - dim.left) / dim.width) * 2 - 1;
        mouse.y = -((cy - dim.top) / dim.height) * 2 + 1;

        return mouse;
    };

    this.getCameraName = function () {
        var name;
        if (this.camera === viewer.defaultCamera) {
            if (this.camera.isPerspective) {
                name = "persp";
            } else {
                name = "orth";
            }

        }  else {
            name = this.camera.name;
        }

        return name;
    };

    this.getCameraInfo = function () {
        var camInfo = new CLOUD.CameraInfo(this.getCameraName(), this.camera.position, this.camera.target, this.camera.up);
        return JSON.stringify(camInfo);
    };

    // 放大缩小限制：根据相机与目标点距离来判断是否需要继续放大或缩小
    // 在限制范围内，可以继续缩放，否则，不再缩放
    this.isKeepZoom = function (zoom, minDistance, maxDistance) {

        this.dirtyCamera(true);
        this.setCameraChanging(true); // add

        if (minDistance === undefined) {
            minDistance = this.minDistance;
        }

        if (maxDistance === undefined) {
            maxDistance = this.maxDistance;
        }

        var position = this.camera.position;
        var target = this.camera.target;
        var offset = new THREE.Vector3();

        offset.copy(position).sub(target);
        var distance = offset.length() * (2 - zoom); // D = X + X * (1 - factor)

        if (distance < minDistance || distance > maxDistance) {
            return false;
        }

        return true;
    };

    this.computeRotation = function () {
        // 旋转矩阵
        var m1 = new THREE.Matrix4();
        m1.lookAt(this.camera.position, this.camera.target, this.camera.up);

        var quat2 = new THREE.Quaternion();
        quat2.setFromRotationMatrix(m1);

        // 获得旋转角
        var rotation = new THREE.Euler();
        rotation.setFromQuaternion(quat2, undefined, false);

        return rotation;
    };

    this.adjustCameraUp = function () {

        if (this.camera.realUp.y > 0) {

            this.camera.up = new THREE.Vector3(0, 1, 0);

        } else if (this.camera.realUp.y < 0) {

            this.camera.up = new THREE.Vector3(0, -1, 0);

        } else {

            if (this.camera.realUp.x > 0) {

                this.camera.up = new THREE.Vector3(1, 0, 0);

            } else if (this.camera.realUp.x < 0) {

                this.camera.up = new THREE.Vector3(-1, 0, 0);

            } else {

                if (this.camera.realUp.z > 0) {

                    this.camera.up = new THREE.Vector3(0, 0, 1);

                } else if (this.camera.realUp.z < 0) {

                    this.camera.up = new THREE.Vector3(0, 0, -1);
                }
            }
        }

    };

    this.getWorldEye = function () {
        return this.camera.target.clone().sub(this.camera.position);
    };

    this.getWorldRight = function () {
        // remark： 使用这个函数的地方存在问题，后续调查修改!!!
        var right = new THREE.Vector3();
        var up = this.camera.up;
        var eye = this.getWorldEye();
        right.crossVectors(eye, up);

        if (right.lengthSq() === 0) {
            if (up.z > up.y)
                eye.y -= 0.0001;
            else
                eye.z += 0.0001;

            right.crossVectors(eye, up);
        }

        return right.normalize();
    };

    this.getWorldRightByRealUp = function () {
        var right = new THREE.Vector3();
        var up = this.camera.realUp;
        var eye = this.getWorldEye();
        right.crossVectors(eye, up);

        if (right.lengthSq() === 0) {
            if (up.z > up.y)
                eye.y -= 0.0001;
            else
                eye.z += 0.0001;

            right.crossVectors(eye, up);
        }

        return right.normalize();
    };

    this.getWorldUp = function () {
        var right = this.getWorldRight();
        var eye = this.getWorldEye();
        return right.cross(eye).normalize();
    };

    this.getWorldDimension = function (cx, cy) {

        var position = this.camera.position;
        var eye = this.getWorldEye().normalize();

        // 计算跟踪距离
        var trackingPoint = this.getTrackingPoint(cx, cy);
        var trackingDir = trackingPoint.clone().sub(position);
        var distance = Math.abs(eye.dot(trackingDir));

        var canvasContainer = this.getContainerDimensions();
        var aspect = canvasContainer.width / canvasContainer.height;
        var height = 2.0 * distance * Math.tan(THREE.Math.degToRad(this.camera.fov * 0.5));
        var width = height * aspect;

        return new THREE.Vector2(width, height);

    };

    // 获得近裁面上点的世界坐标
    this.getWorldPointFromNearPlane = function (normalizedX, normalizedY) {

        var worldPoint = new THREE.Vector3(normalizedX, normalizedY, 0.0);
        worldPoint.unproject(camera);

        return worldPoint;
    };

    this.getTrackingPoint = function (cx, cy) {

        var pos = new THREE.Vector2(cx, cy);
        var intersectContext = this.getIntersectContext(pos);
        var trackingPoint = this.intersector.hitTest(intersectContext);

        if (!trackingPoint) {

            var normalizedXY = intersectContext.mouse;
            var position = this.camera.position;
            var eye = this.getWorldEye();
            var normEye = eye.clone().normalize();
            var worldPoint = this.getWorldPointFromNearPlane(normalizedXY.x, normalizedXY.y);
            var ray = new THREE.Ray();

            if (this.camera.isPerspective) {

                ray.origin.copy(position);
                ray.direction.copy(worldPoint.clone().sub(position).normalize());

            } else {

                var origin = worldPoint.clone();
                origin.sub(eye);
                ray.origin.copy(origin);
                ray.direction.copy(normEye);

            }

            if (!_lastTrackingPoint) {

                trackingPoint = this.getTrackingPointFromBoundingBox(normEye, ray);

            } else {

                // 保持上一次的基点和本次基点在同一平面内

                var plane = new THREE.Plane();
                plane.setFromNormalAndCoplanarPoint(normEye, _lastTrackingPoint);

                trackingPoint = ray.intersectPlane(plane);

                // 如果没有取到点，说明上一次的点在相机背后，重新取点
                if (!trackingPoint) {

                    //CLOUD.Logger.log("trackingPoint === null");
                    trackingPoint = this.getTrackingPointFromBoundingBox(normEye, ray);

                } else {

                    // 基准点在相机位置，重新取点

                    var dist = trackingPoint.distanceTo(position);

                    if (dist < _EPS) {

                        //CLOUD.Logger.log("equal");
                        trackingPoint = this.getTrackingPointFromBoundingBox(normEye, ray);
                    }
                }
            }

            // 没有取到点，则取worldPoint
            if (!trackingPoint) {

                CLOUD.Logger.log("tracking point is default!");
                trackingPoint = worldPoint;
            }
        }

        // 保存状态
        _lastTrackingPoint = trackingPoint.clone();

        return trackingPoint;
    };

    // 获取相机到场景包围盒8个顶点的最大距离对应点所在平面与所给射线的交点
    this.getTrackingPointFromBoundingBox = function (direction, ray) {

        var scene = this.scene;
        return scene.getTrackingPointFromBoundingBox(direction, ray);
    };

    // 设置相机位置
    this.setCameraPosition = function (position) {

        var camera = this.camera;

        var eye = this.getWorldEye();
        var distance = eye.length();

        var dir = eye.clone();
        dir.normalize();
        dir.setLength(distance);

        camera.position.copy(position);
        camera.target.addVectors(camera.position, dir);
        this.dirtyCamera(true);
        this.setCameraChanging(true); // add
    };

    // 前进 or 后退
    this.moveStraight = function (step, keepHeight) {
        
        var position = this.camera.position;
        var target = this.camera.target;

        if (keepHeight) {
            var diff = new THREE.Vector3(target.x - position.x, 0, target.z - position.z);
            var len = diff.length();
            var coe = step / len;
            var stepDiff = new THREE.Vector3(diff.x * coe, 0, diff.z * coe);

            position.add(stepDiff);
            target.add(stepDiff);
        }
        else {
            var eye = target.clone().sub(position);

            this.camera.translateZ(-step);
            target.addVectors(position, eye);
        }
        this.dirtyCamera(true);
        this.setCameraChanging(true); // add
    };

    this.getIntersectContext = function (pos) {
        var context = new CLOUD.IntersectContext();
        var scope = this;
        var modelManager = scope.viewer.modelManager;

        context.scene = scope.scene;
        context.camera = this.camera;

        if(pos != null){
            scope.mapWindowToViewport(pos.x, pos.y, context.mouse);
        }

        // 获得视口尺寸
        context.viewportSize = scope.viewer.renderer.getSize();
        context.octreeRoots = modelManager.getOctreeRoots();

        if (CLOUD.GlobalData.BatchMergeEnabled) {
            context.octantMap = modelManager.mapCellIdToNodes;//
        } else {
            context.octantMap = modelManager.octantToObjectMap;
        }

        context.instanceGeometries = modelManager.instanceGeometries;
        
        return context;
    };

    this.getLastIntersect = function () {

        return this.intersector.lastIntersect;
    };

    this.calculatePivot = function (rotateMode, clientXY) {
        var scope = this;

        var viewer = this.viewer;
        var scene = this.scene;
        var pivot = null;

        // 根据鼠标位置计算pivot点, 没有交点，取场景中点
        function _calcPivotByMouse (clientXY) {
            var context = scope.getIntersectContext(clientXY);
            var pt = scope.intersector.hitTest(context);
            if (pt) {
                return pt;
            } else {
                return scene.getBoundingBox().getCenter();
            }
        }

        switch (rotateMode) {

            case CLOUD.RotatePivotMode.SELECTION:
			
				var sceneState = viewer.modelManager.sceneState;

                //var box = scene.getBoundingBoxOfGeometries(sceneState.getSelectionSet());
                var box = viewer.getBoundingBoxByIds(sceneState.getSelectionSet());

                if(CLOUD.GlobalData.IsMobile){
                    pivot = _calcPivotByMouse(clientXY);
                } else {
                    if (!box || box.isEmpty()) {
                        pivot = _calcPivotByMouse(clientXY);
                    } else {
                        pivot = box.getCenter();
                    }
                }

                break;

            case CLOUD.RotatePivotMode.CENTER:

                pivot = scene.getBoundingBox().getCenter();
                break;

            case CLOUD.RotatePivotMode.CAMERA:

                pivot = null;
                break;

            default: // 默认 CLOUD.RotatePivotMode.MOUSEPOINT

                pivot = _calcPivotByMouse(clientXY);

                break;
        }
        this.dirtyCamera(true);
        this.setCameraChanging(true); // add
        this.pivot = pivot; // 移动兼容处理，先这里保持一份
        return pivot;

    };

    function pivotBallPos() {
        if (_scope.pivot != null) {
            return _scope.pivot;
        }
        else {

            var center = _scope.scene.getBoundingBox().getCenter();
            return center;
        }
    };

    function pivotBallSize() {
        var camera = _scope.camera;
        var position = camera.position;

        var cameraDir = _scope.camera.target.clone().sub(position);
        cameraDir.normalize();

        var plane = new THREE.Plane();
        plane.setFromNormalAndCoplanarPoint(cameraDir.clone().negate(), pivotBallPos());
        plane.normalize();
        var distance = plane.distanceToPoint(position);
        var planeWidth = distance * Math.tan(camera.fov * 0.5);

        var dim = _scope.getContainerDimensions();
        return planeWidth * 2 / (dim.height - dim.top);
    };
	
	function createPivotBall() {
        _scope.pivotBallGroup = _scope.scene.getOrCreateObjectGroup(CLOUD.ObjectGroupType.PIVOTBALL,
				{priority: 10, globalSpace: false});
		
		// Q: What's the difference between pivotBall and pivotCenter?
		var geometry = new THREE.SphereBufferGeometry(15, 64, 64);
		var pivotBall = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
			color: 0xffffff,
			depthTest: false,
			opacity: 0.5,
			transparent: true
		}));

		geometry = new THREE.SphereBufferGeometry(1, 64, 64);
		var pivotCenter = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
			color: 0xff0000,
			depthTest: false,
			opacity: 0.5,
			transparent: true
		}));

        _scope.pivotBallGroup.add(pivotBall);
        _scope.pivotBallGroup.add(pivotCenter);
	}

    this.touchUpdateRotationInPersonView = function(_thetaDelta, _phiDelta ) {
        this.dirtyCamera(true);
        this.setCameraChanging(true); // add

        var scope = this;

        var position = this.camera.position;

        var eye = this.camera.target.clone().sub(position);
        var eyeDistance = eye.length();
        var camDir = this.camera.getWorldDirection();

        var up = this.camera.realUp || this.camera.up;
        var rightDir = camDir.clone().cross(up).normalize();
        var realUp = rightDir.clone().cross(camDir).normalize();
        this.camera.realUp.copy(realUp);

        var adjustCameraPosition = function (trf) {
            var newTarget = new THREE.Vector3(); // 新目标点

            // 保持相机到目标点的距离不变
            camDir.applyQuaternion(trf).normalize();
            newTarget.copy(position).add(camDir.multiplyScalar(eyeDistance));
            // 相机目标点位置
            scope.camera.target.copy(newTarget);
        };

        var rotAxis, rotAngle;
        if (Math.abs(_thetaDelta) > Math.abs(_phiDelta)) {
            rotAxis = _zAxisUp;
            rotAngle = _thetaDelta;
        }
        else if (!CLOUD.EditorConfig.LockAxisZ) {
            rotAxis = rightDir;

            var cross = new THREE.Vector3(0, 1, 0).clone().cross(up);
            var dot = cross.dot(rightDir);
            var angle = Math.asin(cross.length());
            if (dot < 0) {
                angle = -angle;
            }
            if ((angle + _phiDelta) > (Math.PI / 4 - _EPS)) {
                _phiDelta = Math.PI / 4 - _EPS - angle;
            }
            else if ((angle + _phiDelta) < (-Math.PI / 4 + _EPS)) {
                _phiDelta = -Math.PI / 4 + _EPS - angle;
            }

            rotAngle = _phiDelta;
        }

        var viewTrf = new THREE.Quaternion().setFromAxisAngle(rotAxis, rotAngle);
        adjustCameraPosition(viewTrf);
        this.camera.realUp.applyQuaternion(viewTrf).normalize();
    };

    this.touchUpdateRotationInModelView = function(_thetaDelta, _phiDelta, _pivot) {

        this.dirtyCamera(true);
        this.setCameraChanging(true); // add

        var pivot = _pivot || this.scene.getBoundingBox().getCenter();

        var position = this.camera.position;

        var eye = this.camera.target.clone().sub(position);
        var eyeDistance = eye.length();
        var viewVec = position.clone().sub(pivot);
        var viewLength = viewVec.length();
        var viewTrf = null;
        var camDir = this.camera.getWorldDirection();

        viewVec.normalize();

        var adjustCameraPosition = function (trf) {
            var newTarget = new THREE.Vector3(); // 新目标点
            var newViewDir = viewVec.clone().applyQuaternion(trf).normalize();

            // 相机新位置
            position.copy(pivot).add(newViewDir.multiplyScalar(viewLength));

            // 保持相机到目标点的距离不变
            camDir.applyQuaternion(trf).normalize();
            newTarget.copy(position).add(camDir.multiplyScalar(eyeDistance));
            // 相机目标点位置
            _scope.camera.target.copy(newTarget);
        };

        var up = this.camera.realUp || this.camera.up;
        var rightDir = camDir.clone().cross(up).normalize();
        var realUp = rightDir.clone().cross(camDir).normalize();
        this.camera.realUp.copy(realUp);

        var rotAxis;

        // 锁定Z轴
        if (CLOUD.EditorConfig.LockAxisZ) {
            // 水平旋转
            if (Math.abs(_thetaDelta) > Math.abs(_phiDelta)) {

                rotAxis = _zAxisUp;
                viewTrf = new THREE.Quaternion().setFromAxisAngle(rotAxis, _thetaDelta);
                adjustCameraPosition(viewTrf);
                this.camera.realUp.applyQuaternion(viewTrf).normalize();
            }
        } else {
            // 水平旋转
            if (Math.abs(_thetaDelta) > Math.abs(_phiDelta)) {

                // remark: this.camera.up 的使用有些奇怪，大多数都被置成了 THREE.Object3D.DefaultUp，后续需要在重新考虑下
                // 当this.camera.up为THREE.Object3D.DefaultUp时，其实水平旋转就是锁定了Z轴的旋转(模型的Z轴对应场景的Y轴)
                rotAxis = this.camera.up.clone().normalize();
                viewTrf = new THREE.Quaternion().setFromAxisAngle(rotAxis, _thetaDelta);
                adjustCameraPosition(viewTrf);
                this.camera.realUp.applyQuaternion(viewTrf).normalize();

            } else if (Math.abs(_phiDelta) > 0.01) { // 垂直旋转

                rotAxis = camDir.clone().cross(up).normalize();

                var cross = new THREE.Vector3(0, 1, 0).clone().cross(up);
                var dot = cross.dot(rightDir);
                var angle = Math.asin(cross.length());
                if (dot < 0) {
                    angle = -angle;
                }
                if ((angle + _phiDelta) > (Math.PI / 2 - _EPS)) {
                    _phiDelta = Math.PI / 2 - _EPS - angle;
                }
                else if ((angle + _phiDelta) < (-Math.PI / 2 + _EPS)) {
                    _phiDelta = -Math.PI / 2 + _EPS - angle;
                }

                viewTrf = new THREE.Quaternion().setFromAxisAngle(rotAxis, _phiDelta);
                adjustCameraPosition(viewTrf);
                this.camera.realUp.applyQuaternion(viewTrf).normalize();

                // 旋转180度时，up的y值应该反向，否则移动会反
                this.adjustCameraUp();
            }
        }
		
		if (!this.pivotBallGroup) {
			createPivotBall();
		}
		
		this.pivotBallGroup.visible = true;
		
		var scale = pivotBallSize();
		var pos = pivotBallPos();
		for (var ci = 0; ci < this.pivotBallGroup.children.length; ci++) {
			var geo = this.pivotBallGroup.children[ci];
            geo.position.copy(pos);
			
			geo.scale.set(scale, scale, scale);

			geo.updateMatrixWorld();
		}
        
    };

    this.touchUpdateRotation = function (thetaDelta, phiDelta) {

        var position = this.camera.position;
        var sceneBoundingBox = this.scene.getBoundingBox();

        if (sceneBoundingBox.containsPoint(position)) {
            this.touchUpdateRotationInPersonView(thetaDelta, phiDelta);
        }
        else {
            this.touchUpdateRotationInModelView(thetaDelta, phiDelta, pivotBallPos());
        }
    };

    this.clearTouchRotateState = function() {
		if (this.pivotBallGroup) {
			this.pivotBallGroup.visible = false;
		}
    };

    this.touchEndHandler = function () {

        this.viewer.editorManager.cameraChange = false;

        this.clearTouchRotateState();

        this.touchUpdate();
    };
	
	this._adjustCameraForDolly = function(dollyPoint, scale){

        var scaleFactor = scale - 1.0;

        if (Math.abs(scaleFactor) < _EPS) {
            return false;
        }

        var camera = this.camera;
        var cameraPosition = camera.position;
        var dirEye = this.getWorldEye();
        var dirDolly = new THREE.Vector3();

        if (!dollyPoint) {
            dirDolly.copy(dirEye);
        } else {
            dirDolly.subVectors(dollyPoint, cameraPosition);
        }

        dirDolly.multiplyScalar(scaleFactor);

        var distance = dirDolly.length();

        // 透视投影下允许穿透
        if (camera.isPerspective) {

            if (distance < this.minDollyDistance) {

                dirDolly.normalize().multiplyScalar(this.minDollyDistance);

            }
        }

        var newCameraPosition = new THREE.Vector3();
        newCameraPosition.addVectors(cameraPosition, dirDolly);

        if( !camera.isPerspective ) {

            camera.orthoScale *= scale;
            camera.setZoom(camera.orthoScale);
        }

        camera.position.copy(newCameraPosition);
        camera.target.copy(dirEye.add(newCameraPosition));
        this.dirtyCamera(true);
        this.setCameraChanging(true); // add
        return true;
    };

    this.touchDolly = function (dollyCenterX, dollyCenterY, scale) {

        var pos = new THREE.Vector2(dollyCenterX, dollyCenterY);
        var intersectContext = this.getIntersectContext(pos);
        var centerPosition = this.intersector.hitTest(intersectContext);

        if (centerPosition != null) {
            this._adjustCameraForDolly(centerPosition, scale);
        } else {
            this._adjustCameraForDolly(null, scale);
        }
    };


    this.touchUpdate = function () {
        var lastPosition = new THREE.Vector3();
        var lastQuaternion = new THREE.Quaternion();

        return function () {

            //TODO: clarify the logic below
            // lookAt使用realUp
            var tmpUp = new THREE.Vector3();
            tmpUp.copy(this.camera.up);
            this.camera.up.copy(this.camera.realUp);
            this.camera.lookAt(this.camera.target);
            this.camera.up.copy(tmpUp);
            this.camera.updateMVP();

            {
                // FIXME: seems there is a bug that lastPosition and lastQuaternion are not
                //         initialized but used here
                if (lastPosition.distanceToSquared(this.camera.position) > _EPS
                    || 8 * (1 - lastQuaternion.dot(this.camera.quaternion)) > _EPS) {

                    //CLOUD.Logger.log("CameraControl.render");
                    onChange();

                    this.dirtyCamera(false);

                    // render 可能会直接返回，这样直接关闭相机状态会出现问题
                    // this.setCameraChanging(false); // add

                    lastPosition.copy(this.camera.position);
                    lastQuaternion.copy(this.camera.quaternion);
                }
            }
        }
    }();

    //
    // for walk editor
    //

    //  右转：angle为正； 左转：angle为负
    this.goTurnForWalk = function (angle) {

        var camera = this.getCamera();
        var position = camera.position;
        var target = camera.target;

        var diff = new THREE.Vector3(target.x - position.x, 0, target.z - position.z);
        var cosAngle = Math.cos(angle);
        var sinAngle = Math.sin(angle);
        var centerDiff = new THREE.Vector3(diff.x * cosAngle - diff.z * sinAngle, 0, diff.x * sinAngle + diff.z * cosAngle);

        target.x = position.x + centerDiff.x;
        target.z = position.z + centerDiff.z;
        this.dirtyCamera(true);
        this.setCameraChanging(true); // add
    };

    // 俯仰
    this.goPitchForWalk = function (angle) {

        var camera = this.getCamera();
        var position = camera.position;
        var target = camera.target;

        var offsetX = target.x - position.x;
        var offsetZ = target.z - position.z;
        var distance = Math.sqrt(offsetX * offsetX + offsetZ * offsetZ);
        var diff = new THREE.Vector3(distance, target.y - position.y, 0);
        var cosAngle = Math.cos(angle);
        var sinAngle = Math.sin(angle);
        var centerDiff = new THREE.Vector3(diff.x * cosAngle - diff.y * sinAngle, diff.x * sinAngle + diff.y * cosAngle, 0);
        // var percent = centerDiff.x / distance;

        // 俯仰，不用改变x,z
        // target.x = position.x + percent * offsetX;
        target.y = position.y + centerDiff.y;
        // target.z = position.z + percent * offsetZ;
        this.dirtyCamera(true);
        this.setCameraChanging(true); // add
    };

    // 根据世界系中的步进长度和绘图空间方向向量来获得绘图空间步进向量
    function getStepDiff(camera, matrixScene, direction, stepWorld) {

        var inverseMatrix = new THREE.Matrix4();
        inverseMatrix.getInverse(matrixScene);

        var position = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
        var positionWorld = position.clone();
        positionWorld.applyMatrix4(inverseMatrix);

        // 变换到世界系
        var stepDiff = new THREE.Vector3(direction.x, direction.y, direction.z);
        stepDiff.add(position);
        stepDiff.applyMatrix4(inverseMatrix);
        stepDiff.sub(positionWorld).normalize().multiplyScalar(stepWorld);
        stepDiff.add(positionWorld);

        // 转换到绘图空间
        stepDiff.applyMatrix4(matrixScene);
        stepDiff.sub(position);

        return stepDiff;
    }

    // 垂直移动照相机
    this.goUpDownForWalk = function (step) {

        // var camera = this.getCamera();
        // var position = camera.position;
        // var target = camera.target;
        //
        // // target和eye的Y轴上的坐标增加step
        // position.y += step;
        // target.y += step;

        var camera = this.getCamera();
        var position = camera.position;
        var target = camera.target;
        var up = new THREE.Vector3(0, 1, 0);
        var matrixScene = this.scene.getMatrixGlobal();

        // 需要每次重新计算步进么？？？
        var stepDiff = getStepDiff(camera, matrixScene, up, step);  

        // target和eye的Y轴上的坐标增加step
        position.y += stepDiff.y;
        target.y += stepDiff.y;         

        this.dirtyCamera(true);
        this.setCameraChanging(true); // add
    };
   
    this.stepCameraForWalk = function(direction, step) {
        // var camera = this.getCamera();
        // var position = camera.position;
        // var target = camera.target;
        //
        // // 新的target和eye在Y轴上的坐标不变
        // var diff = new THREE.Vector3(target.x - position.x, 0, target.z - position.z);
        // var len = diff.length();
        // var coe = step / len;
        // var stepDiff;
        //
        // switch (direction) {
        //     case CLOUD.MoveDirection.FORWARD:
        //         stepDiff = new THREE.Vector3(diff.x * coe, 0, diff.z * coe);
        //         break;
        //     case CLOUD.MoveDirection.BACK:
        //         stepDiff = new THREE.Vector3(-diff.x * coe, 0, -diff.z * coe);
        //         break;
        //     case CLOUD.MoveDirection.LEFT:
        //         stepDiff = new THREE.Vector3(diff.z * coe, 0, -diff.x * coe);
        //         break;
        //     case CLOUD.MoveDirection.RIGHT:
        //         stepDiff = new THREE.Vector3(-diff.z * coe, 0, diff.x * coe);
        //         break;
        // }
        //
        // position.add(stepDiff);
        // target.add(stepDiff);

        var camera = this.getCamera();
        var position = camera.position;
        var target = camera.target;
        var forward = new THREE.Vector3(target.x - position.x, 0, target.z - position.z).normalize();
        var up = new THREE.Vector3(0, 1, 0);
        var right = forward.clone().cross(up);
        var matrixScene = this.scene.getMatrixGlobal();
        var stepDiff;

        switch (direction) {
            case CLOUD.MoveDirection.FORWARD:
                stepDiff = getStepDiff(camera, matrixScene, forward, step);
                stepDiff.y = 0;
                break;
            case CLOUD.MoveDirection.BACK:
                forward.multiplyScalar(-1);
                stepDiff = getStepDiff(camera, matrixScene, forward, step);
                stepDiff.y = 0;
                break;
            case CLOUD.MoveDirection.LEFT:
                right.multiplyScalar(-1);
                stepDiff = getStepDiff(camera, matrixScene, right, step);
                stepDiff.y = 0;
                break;
            case CLOUD.MoveDirection.RIGHT:
                stepDiff = getStepDiff(camera, matrixScene, right, step);
                stepDiff.y = 0;
                break;
        }

        position.add(stepDiff);
        target.add(stepDiff);

        this.dirtyCamera(true);
        this.setCameraChanging(true); // add
    };

    this.hitTestWithGround = function(){
        var camera =  this.getCamera();

        var footDir = camera.up.clone().multiplyScalar(-1);
        var ray = new THREE.Ray(camera.position.clone(), footDir);
        var context = this.getIntersectContext(null);
        var oldValue = this.intersector.byGravity;
        this.intersector.byGravity = true;
        var hit = this.intersector.intersect(context, ray, false);        
        this.intersector.byGravity = oldValue;
        return hit;
    };

    this.computeGravity = function() {

        this.gravity = 0;
       
        var result = this.hitTestWithGround();
    
        if(result == null){
            var matrixScene = this.scene.getMatrixGlobal();
            var invSceneMatrix = new THREE.Matrix4();
            invSceneMatrix.getInverse(matrixScene);

            var groundPoint = this.camera.position.clone();
            groundPoint.applyMatrix4(invSceneMatrix);
            groundPoint.z = 0;
            groundPoint.applyMatrix4(matrixScene);
            this.distanceToGround = Math.abs(this.camera.position.y-groundPoint.y);
        }

        if(this.manHeight === undefined){
            this.computeManHeight();
        }
        else{
            var diff =  result?(result.distance - this.manHeight):(this.distanceToGround-this.manHeight);
            diff = diff /  this.scene.getGlobalScaleFactor();
            if(Math.abs(diff) < 0.1){
                return 0;
            }
            this.gravity = diff;
        }                    
    };

    this.computeManHeight = function() {
        if(this.manHeight){
            return;
        }
        var result = this.hitTestWithGround();
        var matrixScene = this.scene.getMatrixGlobal();
        var invSceneMatrix = new THREE.Matrix4();
        invSceneMatrix.getInverse(matrixScene);
        if(result != null){            
            var hitPoint = result.point.clone();
            hitPoint.applyMatrix4(invSceneMatrix);
            hitPoint.z += 1650;
            hitPoint.applyMatrix4(matrixScene);
            this.manHeight = Math.abs(result.point.y - hitPoint.y);    
        }
        else{
            var groundPoint = this.camera.position.clone();
            groundPoint.applyMatrix4(invSceneMatrix);
            groundPoint.z = 0;
            var eyeMan = groundPoint.clone();
            eyeMan.z += 1650; 
            groundPoint.applyMatrix4(matrixScene);
            eyeMan.applyMatrix4(matrixScene);

            this.manHeight = Math.abs(eyeMan.y-groundPoint.y);
        }
    };

    this.walkWithParallelEye = function () {

        var camera = this.camera;

        // 将相机移动到指定的点
        var eye = this.getWorldEye();
        var distance = eye.length();

        var scene = this.scene;
        var center = scene.getBoundingBox().getCenter();

        var newEye = new THREE.Vector3();
        newEye.subVectors(center, camera.position);

        var newDistance = newEye.length();
        newEye.y = 0;
        newEye.normalize();
        newEye.multiplyScalar(newDistance);

        camera.position.subVectors(center, newEye);
        camera.target.addVectors(camera.position, newEye.normalize().multiplyScalar(distance));

        var up = new THREE.Vector3(0, 1, 0);
        camera.up.copy(up);
        camera.realUp.copy(up);

        this.dirtyCamera(true);
        this.setCameraChanging(true); // add
        this.update(true);
    };

    //
    // for fly editor
    //

    this.updateFlyMove = function (moveState, moveStep) {

        //var moveStep = this.movementSpeed * this.getSpeedRate();
        var camera = this.camera;
        //var position = camera.position;
        //var target = camera.target;
        //var eye = target.clone().sub(position);

        this.dirtyCamera(true);
        this.setCameraChanging(true); // add

        var enumMoveDirection = CLOUD.MoveDirection;

        // 前进
        if (moveState & enumMoveDirection.FORWARD) {
            //this._goForward(moveStep);
            camera.translateZ(-moveStep); // forward
        }

        // 后退
        if (moveState & enumMoveDirection.BACK) {
            //this._goBack(moveStep);
            camera.translateZ(moveStep); // back
        }

        // 左移
        if (moveState & enumMoveDirection.LEFT) {
            //this._goLeft(moveStep);
            camera.translateX(-moveStep); // left
        }

        // 右移
        if (moveState & enumMoveDirection.RIGHT) {
            //this._goRight(moveStep);
            camera.translateX(moveStep); // right
        }

        // 上移
        if (moveState & enumMoveDirection.UP) {
            //this._goUp(moveStep);
            camera.translateY(moveStep); // up
        }

        // 下移
        if (moveState & enumMoveDirection.DOWN) {
            //this._goDown(moveStep);
            camera.translateY(-moveStep); // down
        }

        // 刷新
        this.flyOnWorld();

        // this.dirtyCamera(false);
        // this.setCameraChanging(false); // add
    };

    // 基于世界空间的漫游
    this.flyOnWorld = function () {

        var camera = this.camera;

        var up = camera.up.clone();

        if (camera.realUp) {
            camera.up.copy(camera.realUp);
        }

        // 使用realUp
        camera.lookAt(camera.target);

        if (camera.realUp) {
            camera.up.copy(up);
        }

        // 调用Render刷新
        onChange();

        this.dirtyCamera(false);

        // render 可能会直接返回，这样直接关闭相机状态会出现问题
        // this.setCameraChanging(false); // add

        _lastPosition.copy(camera.position);
        _lastQuaternion.copy(camera.quaternion);

    };

    this.rotateForFly = function(deltaYaw, deltaPitch, pitchMin, pitchMax) {
        var camera = this.camera;
        var position = camera.position;
        var target = camera.target;
        var eye = target.clone().sub(position);

        var worldUp = new THREE.Vector3(0, 1, 0);
        var upDir = camera.realUp || camera.up;
        var rightDir = eye.clone().cross(upDir).normalize();

        this.dirtyCamera(true);
        this.setCameraChanging(true); // add

        // Pitch around axis Z only when axis Z locked.
        if (CLOUD.EditorConfig.LockAxisZ) {
            deltaPitch = 0;
        }


        if (deltaPitch != 0) {
            var pitchTransform = new THREE.Quaternion().setFromAxisAngle(rightDir, -deltaPitch);
            var tmp = eye.clone();

            tmp.applyQuaternion(pitchTransform);

            var angle = tmp.angleTo(worldUp);
            // 钳制到[-PI/2, PI/2]
            angle = angle - 0.5 * Math.PI;

            // 限制角度
            if (angle >= pitchMin && angle <= pitchMax) {
                eye.applyQuaternion(pitchTransform);
            }
        }

        if (deltaYaw != 0) {
            //注意：鼠标左右移动的旋转轴要沿世界坐标系的y轴旋转，而不是摄像机自己的坐标轴，防止视角倾斜
            var yawTransform = new THREE.Quaternion().setFromAxisAngle(worldUp, -deltaYaw);

            eye.applyQuaternion(yawTransform);
        }

        target.addVectors(position, eye);

        // 刷新
        this.flyOnWorld();

        // this.dirtyCamera(false);
        // this.setCameraChanging(false); // add
    };

    this.fitAndRotateBySelection = function () {

        var viewer = this.viewer;
        viewer.zoomToSelection();

    };

    // 飞到指定点（平行视角）
    this.flyToPointWithParallelEye = function (point) {

        // 将相机移动到指定的点
        var eye = this.getWorldEye();
        var distance = eye.length();

        // 保持视角方向
        //var dir = new THREE.Vector3(0, 0, -1);
        var dir = eye.clone();
        dir.y = 0;
        dir.normalize();
        dir.setLength(distance);

        var up = new THREE.Vector3(0, 1, 0);

        this.camera.up = up;
        this.camera.realUp = up.clone();

        this.camera.position.copy(point);
        this.camera.target.addVectors(this.camera.position, dir);

        this.update(true);
    };

    // 飞到指定点（保持视角）
    this.flyToPoint = function (point) {

        var eye = this.getWorldEye();
        this.camera.position.copy(point);
        this.camera.target.addVectors(this.camera.position, eye);

        this.update(true);
    };


    /**
     * 设置漫游相机的高度
     *
     * @param {Array} elevations - 参考标高数组（从小到大的排序）
     * @param {Number} height - 相机相对高度(世界系中的高度，默认 1750mm)
     */
    this.setCameraHeight = function (elevations, height) {

        this.cameraAbsoluteHeightEnabled = false;
        this.cameraRelativeHeight = height;

        if (this.cameraConstraintHeights === undefined) {

            this.cameraConstraintHeights = [];

        } else {

            this.cameraConstraintHeights.length = 0;

        }

        for (var i = 0, len = elevations.length; i < len; ++i) {

            this.cameraConstraintHeights[i] = elevations[i];

        }

    };

    /**
     * 设置相机的绝对高度
     *
     * @param {Number} height - 相机绝对高度(世界系中的高度)
     */
    this.setCameraAbsoluteHeight = function (height) {

        this.cameraAbsoluteHeightEnabled = true;
        this.cameraAbsoluteHeight = height;

    };

    /**
     * 更新相机高度
     *
     */
    this.updateCameraHeight = function () {

        var scene = this.scene;
        var camera = this.getCamera();
        var cameraPositionWorld = scene.drawingToWorld(camera.position);// 转世界坐标
        var cameraHeightWorld = cameraPositionWorld.z;

        var newCameraHeightWorld, newCameraPosition;

        var cameraAbsoluteHeightEnabled = this.cameraAbsoluteHeightEnabled;

        if (cameraAbsoluteHeightEnabled) {

            if (this.cameraAbsoluteHeight === undefined) {

                this.cameraAbsoluteHeight = cameraHeightWorld;

            }

            newCameraHeightWorld = this.cameraAbsoluteHeight;

        } else {

            if (this.cameraConstraintHeights === undefined) {

                newCameraHeightWorld = cameraHeightWorld;

            } else {

                // 计算相机的放置位置
                var idx = CLOUD.Utils.findRange(this.cameraConstraintHeights, cameraHeightWorld);
                newCameraHeightWorld = this.cameraConstraintHeights[idx];
                newCameraHeightWorld += this.cameraRelativeHeight;

                // 限制高度
                if (idx < this.cameraConstraintHeights.length - 1) {

                    var nextCameraHeightWorld = this.cameraConstraintHeights[idx + 1];

                    if (newCameraHeightWorld > nextCameraHeightWorld) {
                        newCameraHeightWorld = nextCameraHeightWorld;
                    }

                }

            }

        }

        if (newCameraHeightWorld !== cameraHeightWorld) {

            // 转绘制坐标
            newCameraPosition = scene.worldToDrawing({
                x: cameraPositionWorld.x,
                y: cameraPositionWorld.y,
                z: newCameraHeightWorld
            });

            // 设置相机位置
            this.setCameraPosition(newCameraPosition);
        }

    };

    // utility method

    this.getRaycaster = function(clientX, clientY) {
        var raycaster = new CLOUD.Raycaster();

        var mouse = new THREE.Vector2();
        this.mapWindowToViewport(clientX, clientY, mouse);
        raycaster.setFromCamera(mouse, this.camera);

        return raycaster;
    };

    this.translateCameraForWalk = function (moveVector, moveStep) {

        // 平移不需要方向参数(CLOUD.MoveDirection.RIGHT)，后续在改写
        if (moveVector.x !== 0) {
            this.stepCameraForWalk(CLOUD.MoveDirection.RIGHT, moveVector.x * moveStep);
        }

        if (moveVector.y !== 0) {
            this.goUpDownForWalk(moveVector.y * moveStep * 0.5);
        }
        else{
            var step = moveStep;
            if(this.gravity != 0){
                var gravity = Math.abs(this.gravity);
                if(step >= gravity){
                    step = gravity;
                }               
                else{
                    step = gravity * 0.2;
                }
            }

            if(this.gravity > 0){
                this.goUpDownForWalk(-step);
            }
            else if(this.gravity < 0){
                this.goUpDownForWalk(step);
            }
        }

        if (moveVector.z !== 0) {
            this.stepCameraForWalk(CLOUD.MoveDirection.BACK, moveVector.z * moveStep);
        }

    };

    /**
     * 旋转相机
     *
     * @param {Object} rotationVector - 旋转向量
     * @param {Number} factor - 基于180度的缩放因子， 例如：1 - 表示从左边界至右边界旋转接近180度， 2 - 表示从左边界至右边界旋转接近360度
     */
    this.rotateCameraForWalk = function (rotationVector, factor) {

        // BIMFACEDM-3087: 左键点击旋转鼠标控制旋转角度，从左至右移动需接近180度
        // BIMFACEDM-2726: 鼠标滑动左右移动能够覆盖360度（如果鼠标刚好在中间，则是左右各180度），上下移动能够覆盖180度（如果鼠标刚好在中间，则是上下各90度）

        if (rotationVector.y !== 0) {

            // 左右旋转
            this.goTurnForWalk(-rotationVector.y * Math.PI * factor);
            rotationVector.y = 0;
        }

        if (rotationVector.x !== 0) {

            // 上下旋转
            this.goPitchForWalk(rotationVector.x * Math.PI);
            rotationVector.x = 0;
        }
    };

    this.zoomCameraForWalk = function (factor) {

        this.adjustCameraForDolly(factor, null);

    };

    this.movePlane = function(planeInfo, event, startPt, byBoxClip, postion){

        // compute the working plane: planeDir x camera.right
        if(postion == undefined){
            var clipPlane = new THREE.Plane();
            clipPlane.setComponents(planeInfo.x, planeInfo.y, planeInfo.z,planeInfo.w);
            postion = new THREE.Vector3();
            clipPlane.coplanarPoint(postion);    
        }

        var planeDir = new THREE.Vector3(planeInfo.x, planeInfo.y, planeInfo.z);
        var camera = this.camera;
        var dir = camera.getWorldDirection();
        var plane = new THREE.Plane();
        plane.setFromNormalAndCoplanarPoint(dir, postion);

        // compute the intesecting points on the working plane
        var ray1 = this.getRaycaster(event.clientX, event.clientY);
        var pt1 = new THREE.Vector3();

        var ray2 = this.getRaycaster(startPt.x, startPt.y);
        var pt2 = new THREE.Vector3();

        if(ray1.ray.intersectPlane(plane, pt1) && ray2.ray.intersectPlane(plane, pt2)){

            // compute offset value
            pt1.subVectors(pt1, pt2);               
            pt1.projectOnVector(planeDir);                    
            var len  = pt1.length();       
            if(pt1.dot(planeDir) < 0)
                len = -len;
            if(len != 0){
                if(byBoxClip){
                    planeDir.multiplyScalar(len);
                    len = planeDir.x + planeDir.y + planeDir.z;
                }
                return len;
            }
        }    

        return null;
    };
};