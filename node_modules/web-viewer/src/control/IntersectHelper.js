CLOUD.IntersectHelper = function (viewer) {
    this.raycaster = new CLOUD.Raycaster();

    this.viewer = viewer;
    this.filter = viewer.filter;

    this.lastIntersect = null;
};

CLOUD.IntersectHelper.prototype.destroy = function () {
    this.raycaster = null;
    this.lastIntersect = null;
};

CLOUD.IntersectContext = function () {
    this.scene = null;
    this.camera = null;
    // octree root nodes of all active models in current scene
    this.octreeRoots = null;
    // map from octree node id to object indices in object pool
    this.octantMap = null;
    // mouse click position, normalized
    this.mouse = new THREE.Vector2();
};

CLOUD.IntersectHelper.prototype.defaultIntersect = function (objectGroup, pickable, distanceScope) {
    if (!objectGroup.visible) {
        return;
    }

    var intersects = [];

    for (var i = 0, l = objectGroup.children.length; i < l; i++) {
        // TODO: add filter to support pickable

        var object = objectGroup.children[i];
        object.raycast(this.raycaster, intersects);
    }


    var finalIntersects = [];
    if (intersects.length > 0) {
        // remove objects out of the distance scope
        for (var j = 0; j < intersects.length; j++) {
            if (intersects[j].distance <= distanceScope.far && intersects[j].distance >= distanceScope.near && !this.viewer.clipPoint(intersects[j].point)) {
                finalIntersects.push(intersects[j]);
            }
        }
    }

    finalIntersects.sort(function (a, b) {
        return a.distance - b.distance;
    });

    return finalIntersects.length > 0 ? finalIntersects[0] : null;
};

/**
 * Get info of nearest intersected mesh object.
 *
 * @param {ObjectPool} pool - Mesh object pool
 * @param {OctreeNode} octreeRoots - octree root nodes of all active models in current scene
 * @param {Map} octantMap - map from octant to index of object pool
 * @param {Bool} pickable - flag if the intersected object is pickable
 * @param {Object} distanceScope - near and far distance scope to the ray origin
 */
CLOUD.IntersectHelper.prototype.intersectMeshesWithDistance = function (pool, octreeRoots, octantMap, pickable, distanceScope, instanceGeometries) {
    var i, j, k;
    var len, jLen, kLen;
    var object;
    var distance;
    var minusEpislon = -0.000001;
    var raycaster = this.raycaster;
    var intersectObjects = [];
    var octants = [];

    // Visit all octree, get octree nodes that intersect with the ray
    for (i = 0, len = octreeRoots.length; i < len; i++) {
        this.raycaster.intersectOctantForNode(octreeRoots[i], octants);
    }

    var filter = this.filter;
    var hasVisibleFilter = filter._hasVisibleFilter();
    var hasSelectableFilter = filter._hasSelectableFilter();
    var isPickableFiltered = function (object) {
        return ((hasVisibleFilter && !filter._isVisible(object)) ||
        (hasSelectableFilter && !filter._isSelectable(object)));
    };

    var isHidden = function (object) {
        return (hasVisibleFilter && !filter._isVisible(object));
    };

    if (this.byGravity == true) {
        distanceScope.near = 0;
    } else {
        distanceScope.near += minusEpislon;
    }

    if (CLOUD.GlobalData.BatchMergeEnabled) {
        for (i = 0, len = octants.length; i < len; i++) {
            var nodeInfos = octantMap['info'][octants[i].octantId];
            if (nodeInfos) {
                for (j = 0, jLen = nodeInfos.length; j < jLen; j++) {
                    var nodeInfo = nodeInfos[j];
                    var materialId = nodeInfo.materialId;
                    var uvProp = nodeInfo.uv ? '1' : '0';

                    // if (pickable && isPickableFiltered(nodeInfo)) {
                    //     continue;
                    // }

                    // pickable - true  ：pick、hover使用
                    //          - false ：选择、平移使用
                    if (pickable) {
                        if (isPickableFiltered(nodeInfo)) {
                            continue
                        }
                    } else {
                        // 只需判断是否隐藏
                        if (isHidden(nodeInfo)) {
                            continue;
                        }
                    }

                    if (nodeInfo.instanceOrNot) {
                        var meshInfo = octantMap['instance'][nodeInfo.nodeId];
                        var geometry = instanceGeometries[nodeInfo.geometryId];

                        for (k = 0, kLen = geometry.length; k < kLen; k++) {
                            if (!geometry[k].boundingBox) 
                                geometry[k].computeBoundingBox();
                            var object = new CLOUD.MeshEx(geometry[k]);
                            var parameters = {
                                userId: nodeInfo.name,
                                matrix: meshInfo.matrix,
                                databagId: meshInfo.databagId,
                                userData: nodeInfo.userData
                            };
                            object.spawn(parameters);
                            object.nodeId = nodeInfo.nodeId;

                            distance = object.intersectBoxWithDistance(raycaster);

                            if (distance >= distanceScope.near && distance <= distanceScope.far) {
                                intersectObjects.push({object: object, distance: distance});
                            }
                           object = null;
                           parameters = null;
                        }

                    } else {
                        var instanceObjects = octantMap['mesh'][materialId][uvProp];
                        for (var m = 0, mLen = instanceObjects.length; m < mLen; m++ ) {
                            object = instanceObjects[m];
                            var indicesGroup = object._indicesGroup;
                            var indexInfos = indicesGroup[nodeInfo.name];

                            if (!indexInfos) {
                                continue;
                            }

                            for (k = 0, kLen = indexInfos.length; k < kLen; k++) {

                                var indexInfo = indexInfos[k];
                                if (indexInfo.nodeId !== nodeInfo.nodeId) {
                                    continue;
                                }

                                // get the distance from ray origin to bounding box of object
                                distance = object.intersectBoxWithDistanceByIndices(raycaster, indexInfo);
                                if (distance >= distanceScope.near && distance <= distanceScope.far) {
                                    intersectObjects.push({object: object, distance: distance, indexInfo: indexInfo});
                                }
                            }
                        }

                    }


                }
            }
        }
    } else {
        // travesal mesh objects in all intersected octree nodes, get meshes which
        // bounding box is intersected with ray
        for (i = 0, len = octants.length; i < len; i++) {
            var nodeIndices = octantMap[octants[i].octantId];
            if (nodeIndices) {
                for (j = 0; j < nodeIndices.length; j += 2) {
                    for (var k = nodeIndices[j]; k <= nodeIndices[j + 1]; k++) {
                        object = pool._pool[k];

                        if (pickable && isPickableFiltered(object)) {
                            continue;
                        }

                        // get the distance from ray origin to bounding box of object
                        distance = object.intersectBoxWithDistance(raycaster);
                        if (distance >= distanceScope.near && distance <= distanceScope.far) {
                            intersectObjects.push({object: object, distance: distance});
                        }
                    }
                }
            }
        }
    }


    // sort object according to distance
    intersectObjects.sort(function (a, b) {
        return a.distance - b.distance;
    });

    var intersects = [];
    var finalIntersects = [];
    var minIntersectDistance = distanceScope.far;
    for (i = 0; i < intersectObjects.length; i++) {
        if (intersectObjects[i].distance > minIntersectDistance || intersectObjects[i].distance < distanceScope.near)
            continue;

        object = intersectObjects[i].object;

        intersects = [];
        var indexInfo = intersectObjects[i].indexInfo;

        if (indexInfo) {
            object.raycastByIndices(raycaster, intersects, indexInfo);
        }else {
                object.raycast(raycaster, intersects);
        }

        if (intersects.length > 0) {
            // one mesh may have multiple faces intersected with the ray, sort them
            // and the nearest intersect will be at the first
            intersects.sort(function (a, b) {
                return a.distance - b.distance;
            });

            // only get one intersect that passes the distance scope filter
            for (j = 0, jLen = intersects.length; j < jLen; j++) {
                if (intersects[j].distance < minIntersectDistance && intersects[j].distance > distanceScope.near && !this.viewer.clipPoint(intersects[j].point)) {
                    minIntersectDistance = intersects[j].distance - minusEpislon;
                    if (indexInfo) {
                        intersects[j].userId = indexInfo.userId; //
                        intersects[j].indexInfo = indexInfo;
                    }
                    finalIntersects.push(intersects[j]);
                    break;
                }
            }
        }
    }

    finalIntersects.sort(function (a, b) {
        return a.distance - b.distance;
    });

    return finalIntersects.length > 0 ? finalIntersects[0] : null;
};


CLOUD.IntersectHelper.prototype.intersect = function (context, ray, pickable) {
    var scope = this;
    var raycaster = scope.raycaster;

    // set up the ray
    if (ray === null) {
        raycaster.setFromCamera(context.mouse, context.camera);
    }
    else {
        var origin = ray.origin;
        var direction = ray.direction;

        raycaster.set(origin, direction);
    }

    // console.log("request intersect");

    // 3D mark中进行pick的时候需要世界到屏幕坐标的相互转换，置入两个属性
    // 用于pick的时候进行世界到屏幕坐标的相互转换(现阶段，Marker3D有用到)
    raycaster.camera = context.camera;
    raycaster.viewportSize = context.viewportSize;

    // require intersected mesh in camera visible scope
    var distanceScope = {near: context.camera.near, far: context.camera.far};
    // also take the clip plances into consideration
    context.scene.shrinkScopeByClipPlane(raycaster, distanceScope); // TODO: use a more general method

    var intersect;
    var allIntersects = [];
    var objectGroups = context.scene.getObjectGroups();
    for (var i = 0; i < objectGroups.length; i++) {
        if (!objectGroups[i].isPickable()) {
            continue;
        }

        switch (objectGroups[i].name) {
            case CLOUD.ObjectGroupType.GEOMETRY:
                intersect = this.intersectMeshesWithDistance(context.scene.pool,
                    context.octreeRoots, context.octantMap, pickable, distanceScope, context.instanceGeometries);
                break;
            default:
                intersect = this.defaultIntersect(objectGroups[i], pickable, distanceScope);
                break;
        }

        if (intersect) {
            intersect.objectType = objectGroups[i].pickableType;
            intersect.hoverEnabled = objectGroups[i].hoverEnabled;
            allIntersects.push(intersect);
        }
    }

    allIntersects.sort(function (a, b) {
        return a.distance - b.distance;
    });

    var length = allIntersects.length;

    if (length > 0) {
        // sort according to distance

        for (var ii = 0; ii < length; ++ii) {
            intersect = allIntersects[ii];

            var meshNode = intersect.object;
            if (meshNode.geometry) {

                if (intersect.objectType === CLOUD.PICKABLETYPE.Marker3d) {
                    intersect.userId = intersect.id;
                } else {
                    if (intersect.userId === undefined) {
                        intersect.userId = meshNode.name; // name -> userId
                    }
                }

                intersect.databagId = meshNode.databagId;
                this.lastIntersect = {intersect: intersect, pickable: pickable};
                
                // if (pickable) {
                //     this.lastIntersect = {intersect: intersect, pickable: true}
                // }
                // else {
                //     var selectable = this.filter._isVisible(intersect.object) && this.filter._isSelectable(intersect.object);
                //     this.lastIntersect = {intersect: intersect, pickable: selectable}
                // }

                return intersect;
            }
        }
    }

    this.lastIntersect = null;

    return null;
};

/**
 * Obtain intersect point
 *
 * @param {IntersectContext} intersectContext - context to do the intersect operation
 * @return {Object} position of intersect point; return null if hit nothing
 */
CLOUD.IntersectHelper.prototype.hitTest = function (intersectContext) {

    var intersect = this.intersect(intersectContext, null, false);

    return intersect !== null ? intersect.point : null;
};

CLOUD.IntersectHelper.prototype.pick = function (context, callback) {

    var intersect = this.intersect(context, null, true);
    
    if (callback) {
        callback(intersect);
    }

    return intersect;
};

CLOUD.IntersectHelper.prototype.getIntersectByRay = function (context, ray) {

    return this.intersect(context, ray, true);
};

CLOUD.PickUtil = {
    pickByRect: function (scene, frustum, selectState, modelManager, viewer) {
        var selObjects = [];
        var octants = [];
        var pool = scene.pool;
        var octreeRoots = modelManager.getOctreeRoots();
        var octantMap = modelManager.octantToObjectMap;
        var sceneState = modelManager.sceneState;
        var i, j ,k ,len, jLen, kLen;

        var bbox = new THREE.Box3();

        var p1 = new THREE.Vector3(),
            p2 = new THREE.Vector3();

        function intersectBox(frustum, box) {

            var nCount = 0;
            var planes = frustum.planes;

            for (var i = 0; i < 6; i++) {

                var plane = planes[i];

                p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

                var d1 = plane.distanceToPoint(p1);
                var d2 = plane.distanceToPoint(p2);

                // if both outside plane, no intersection

                if (d1 < 0 && d2 < 0) {

                    return false; // no intersection

                }
                else if (d1 * d2 >= 0) {
                    ++nCount;
                }
            }

            return nCount === 6; // contains the box
        }

        function clipBox(box) {

            var point = new THREE.Vector3();
            for (var i = 0; i < 8; ++i) {

                point.x = i < 4 ? box.min.x : box.max.x;
                point.y = i / 2 < 2 ? box.min.y : box.max.y;
                point.z = i % 2 == 0 ? box.min.z : box.max.z;

                if (!viewer.clipPoint(point)) {
                    return false;
                }

            }

            return true;

        }

        function frustumIntersectOctant(root) {
            bbox.set(root.min, root.max);

            if (frustum.intersectsBox(bbox)) {
                octants.push(root);

                // search subtree
                for (var i = 0, length = root.childOctants.length; i < length; ++i) {

                    var node = root.childOctants[i];
                    frustumIntersectOctant(node);
                }
            }
        }

        var filter = modelManager.filter;
        var hasVisibleFilter = filter._hasVisibleFilter();
        var hasSelectableFilter = filter._hasSelectableFilter();

        function isPickableFiltered(object) {

            return ((hasVisibleFilter && !filter._isVisible(object)) ||
            (hasSelectableFilter && !filter._isSelectable(object)));
        }

        if (selectState === CLOUD.OPSELECTIONTYPE.Clear) {
            sceneState.clearSelection();
            return;
        }

        // Visit all octree, get octree nodes that intersect with the frustum
        for (i = 0; i < octreeRoots.length; i++) {
            frustumIntersectOctant(octreeRoots[i], octants);
        }

        // travel mesh objects in all intersected octree nodes, get meshes which
        // bounding box is contained in frustum
        var object;

        if (CLOUD.GlobalData.BatchMergeEnabled) {
            octantMap = modelManager.mapCellIdToNodes;
            for (i = 0, len = octants.length; i < len; i++) {
                var nodeInfos = octantMap['info'][octants[i].octantId];
                if (nodeInfos) {
                    for (j = 0, jLen = nodeInfos.length; j < jLen; j++) {
                        var nodeInfo = nodeInfos[j];
                        if (isPickableFiltered(nodeInfo))
                            continue;

                        var materialId = nodeInfo.materialId;
                        var uvProp = nodeInfo.uv ? '1' : '0';

                        if (nodeInfo.instanceOrNot) {
                            var instanceGeometries = modelManager.instanceGeometries;
                            var meshInfo = octantMap['instance'][nodeInfo.nodeId];
                            var geometry = instanceGeometries[nodeInfo.geometryId];
    
                            for (k = 0, kLen = geometry.length; k < kLen; k++) {
                                if (!geometry[k].boundingBox) 
                                    geometry[k].computeBoundingBox();
                                var object = new CLOUD.MeshEx(geometry[k]);
                                var parameters = {
                                    userId: nodeInfo.name,
                                    matrix: meshInfo.matrix,
                                    databagId: meshInfo.databagId,
                                    userData: nodeInfo.userData
                                };
                                object.spawn(parameters);
                                object.nodeId = nodeInfo.nodeId;
    
                                bbox.copy(geometry[k].boundingBox);
                                bbox.applyMatrix4(meshInfo.matrix);
                                // Checking boundingbox although this is not accurate
                                if (intersectBox(frustum, bbox) && !clipBox(bbox)) { // frustum contains the box
                                    selObjects.push(object.name);
                                }
                                object = null;
                                parameters = null;
                            }

                        } else {

                            var instanceObjects = octantMap['mesh'][materialId][uvProp];
                            for (var m = 0, mLen = instanceObjects.length; m < mLen; m++ ) {
                                object = instanceObjects[m];
                                var matrixWorld = object.matrixWorld;
                                var indicesGroup = object._indicesGroup;
                                var indexInfos = indicesGroup[nodeInfo.name];

                                if (!indexInfos) {
                                    continue;
                                }

                                for (k = 0, kLen = indexInfos.length; k < kLen; k++) {

                                    var indexInfo = indexInfos[k];
                                    if (indexInfo.nodeId !== nodeInfo.nodeId) {
                                        continue;
                                    }

                                    bbox.copy(object.computeBoundingBox(indexInfo));
                                    bbox.applyMatrix4(matrixWorld);

                                    // Checking boundingbox although this is not accurate
                                    if (intersectBox(frustum, bbox) && !clipBox(bbox)) { // frustum contains the box
                                        selObjects.push(nodeInfo.name);
                                    }
                                }
                            }
                        }

                    }
                }
            }
        } else {
            for (i = 0, len = octants.length; i < len; i++) {
                var nodeIndices = octantMap[octants[i].octantId];
                if (nodeIndices) {
                    for (j = 0; j < nodeIndices.length; j += 2) {
                        for (var k = nodeIndices[j]; k <= nodeIndices[j + 1]; k++) {
                            object = pool._pool[k];

                            if (isPickableFiltered(object))
                                continue;

                            var geometry = object.geometry;
                            var material = object.material;
                            var matrixWorld = object.matrixWorld;

                            if (material === undefined)
                                continue;


                            if (geometry.boundingBox === null) geometry.computeBoundingBox();

                            bbox.copy(geometry.boundingBox);
                            bbox.applyMatrix4(matrixWorld);

                            // Checking boundingbox although this is not accurate
                            if (intersectBox(frustum, bbox) && !clipBox(bbox)) { // frustum contains the box
                                selObjects.push(object.name);
                            }
                        }
                    }
                }
            }
        }


        if (selObjects.length > 0) {

            if (CLOUD.OPSELECTIONTYPE.Remove === selectState) {
                sceneState.removeSelection(selObjects);

            }
            else if (CLOUD.OPSELECTIONTYPE.Add === selectState) {
                sceneState.addSelection(selObjects);

            }
        }
    },

    getObjectsInBox: function (scene, boundingbox, modelManager, viewer) {
        var selObjects = {};
        var octants = [];
        var pool = scene.pool;
        var octreeRoots = modelManager.getOctreeRoots();
        var octantMap = modelManager.octantToObjectMap;
        var bbox = new THREE.Box3();

        var i, j, k, len, jLen, kLen;

        function clipBox(box) {
            var point = new THREE.Vector3();
            for (var i = 0; i < 8; ++i) {
                point.x = i < 4 ? box.min.x : box.max.x;
                point.y = i / 2 < 2 ? box.min.y : box.max.y;
                point.z = i % 2 == 0 ? box.min.z : box.max.z;
                if (!viewer.clipPoint(point)) {
                    return false;
                }
            }
            return true;
        }

        function intesectsBox(box) {
            return box.max.x < boundingbox.min.x || box.min.x > boundingbox.max.x ||
            box.max.y < boundingbox.min.y || box.min.y > boundingbox.max.y ||
            box.max.z < boundingbox.min.z || box.min.z > boundingbox.max.z ? false : true;
        }

        function isInBox(box) {
            return box.max.x >= boundingbox.max.x && box.min.x <= boundingbox.min.x &&
            box.max.y >= boundingbox.max.y && box.min.y <= boundingbox.min.y &&
            box.max.z >= boundingbox.max.z && box.min.z <= boundingbox.min.z ? true : false;
        }

        function boxIntersectOctant(root) {
            bbox.set(root.min, root.max);
            if (intesectsBox(bbox)) {
                octants.push(root);
                // search subtree
                for (var i = 0, length = root.childOctants.length; i < length; ++i) {
                    var node = root.childOctants[i];
                    boxIntersectOctant(node);
                }
            }
        }

        var filter = modelManager.filter;
        var hasVisibleFilter = filter._hasVisibleFilter();
        var hasSelectableFilter = filter._hasSelectableFilter();

        function isPickableFiltered(object) {
            return ((hasVisibleFilter && !filter._isVisible(object)) ||
            (hasSelectableFilter && !filter._isSelectable(object)));
        }

        // Visit all octree, get octree nodes that intersect with the frustum
        for (i = 0; i < octreeRoots.length; i++) {
            boxIntersectOctant(octreeRoots[i], octants);
        }

        // travel mesh objects in all intersected octree nodes, get meshes which
        // bounding box is contained in frustum

        var object;

        if (CLOUD.GlobalData.BatchMergeEnabled) {
            octantMap = modelManager.mapCellIdToNodes;
            for (i = 0, len = octants.length; i < len; i++) {
                var nodeInfos = octantMap['info'][octants[i].octantId];
                if (nodeInfos) {
                    for (j = 0, jLen = nodeInfos.length; j < jLen; j++) {
                        var nodeInfo = nodeInfos[j];
                        if (isPickableFiltered(nodeInfo)) {
                            continue;
                        }

                        var materialId = nodeInfo.materialId;
                        var uvProp = nodeInfo.uv ? '1' : '0';

                        if (nodeInfo.instanceOrNot) {
                            var instanceGeometries = modelManager.instanceGeometries;
                            var meshInfo = octantMap['instance'][nodeInfo.nodeId];
                            var geometry = instanceGeometries[nodeInfo.geometryId];
    
                            for (k = 0, kLen = geometry.length; k < kLen; k++) {
                                if (!geometry[k].boundingBox) 
                                    geometry[k].computeBoundingBox();
                                var object = new CLOUD.MeshEx(geometry[k]);
                                var parameters = {
                                    userId: nodeInfo.name,
                                    matrix: meshInfo.matrix,
                                    databagId: meshInfo.databagId,
                                    userData: nodeInfo.userData
                                };
                                object.spawn(parameters);
                                object.nodeId = nodeInfo.nodeId;
    
                                bbox.copy(geometry[k].boundingBox);
                                bbox.applyMatrix4(meshInfo.matrix);
                                // Checking boundingbox although this is not accurate
                                if (intesectsBox(bbox) && !isInBox(bbox) && !clipBox(bbox)) { // frustum contains the box
                                    selObjects[object.name] = true;
                                }
                                object = null;
                                parameters = null;
                            }
                        } else {

                            var instanceObjects = octantMap['mesh'][materialId][uvProp];
                            for (var m = 0, mLen = instanceObjects.length; m < mLen; m++ ) {
                                object = instanceObjects[m];
                                var matrixWorld = object.matrixWorld;
                                var indicesGroup = object._indicesGroup;
                                var indexInfos = indicesGroup[nodeInfo.name];

                                if (!indexInfos) {
                                    continue;
                                }

                                for (k = 0, kLen = indexInfos.length; k < kLen; k++) {
                                    var indexInfo = indexInfos[k];
                                    if (indexInfo.nodeId !== nodeInfo.nodeId) {
                                        continue;
                                    }
                                    bbox.copy(object.computeBoundingBox(indexInfo));
                                    bbox.applyMatrix4(matrixWorld);
                                    // Checking boundingbox although this is not accurate
                                    if (intesectsBox(bbox) && !isInBox(bbox) && !clipBox(bbox)) { // frustum contains the box
                                        selObjects[nodeInfo.name] = true;
                                    }
                                }
                            }
                        }

                    }
                }
            }
        } else {
            for (i = 0, len = octants.length; i < len; i++) {
                var nodeIndices = octantMap[octants[i].octantId];
                if (nodeIndices) {
                    for (j = 0; j < nodeIndices.length; j += 2) {
                        for (var k = nodeIndices[j]; k <= nodeIndices[j + 1]; k++) {
                            object = pool._pool[k];
                            if (isPickableFiltered(object)) {
                                continue;
                            }
                            var geometry = object.geometry;
                            var material = object.material;
                            var matrixWorld = object.matrixWorld;
                            if (material === undefined) {
                                continue;
                            }
                            if (geometry.boundingBox === null) {
                                geometry.computeBoundingBox();
                            }
                            bbox.copy(geometry.boundingBox);
                            bbox.applyMatrix4(matrixWorld);
                            // Checking boundingbox although this is not accurate
                            if (intesectsBox(bbox) && !isInBox(bbox) && !clipBox(bbox)) { // frustum contains the box
                                selObjects[object.name] = true;
                            }
                        }
                    }
                }
            }
        }
        var retSelObjects = [];
        for (var obj in selObjects) {
            retSelObjects.push(obj);
        }
        return retSelObjects;
    }
};
