/**
 * 模型浏览类
 *
 * @class  CLOUD.Viewer
 *
 */
CLOUD.Viewer = function () {

    this.domElement = null;
    this.camera = null;
    this.renderer = null;

    // 增量绘制
    this.countRenderRequest = 0;
    this.maxCountRenderRequest = 10000;
    this.rendering = false;
    this.incrementRenderHandle = 0;

    this.callbacks = {};

    this.tmpBox = new THREE.Box3();

    this.enableCameraNearFar = true; // 允许动态计算裁剪面
    this.currentHomeView = CLOUD.EnumStandardView.ISO; // home视图设置
    this.initialView = CLOUD.EnumStandardView.ISO; // init视图设置

    this.filter = new CLOUD.FilterManager();
    this.modelManager = new CLOUD.ModelManager(this.filter);
    this.editorManager = new CLOUD.EditorManager();

    this.isRecalculationPlanes = false;
    this.calculationPlanesBind = this.calculationPlanes.bind(this);
    this.addRenderFinishedCallback(this.calculationPlanesBind);

    this.transitionAnimationState = true;
    this.animator = new CLOUD.CameraAnimator();
    this.animator.setDuration(1000);// 持续1s

    this.IBLManager = new CLOUD.IBLManager(this);

    this._renderStateChanged = false; // 渲染数据状态改变标志
};

/**
 * @lends CLOUD.Viewer.prototype
 *
 */
CLOUD.Viewer.prototype = {

    constructor: CLOUD.Viewer,

    // ------ 注册自定义回调函数 S -------------- //
    /**
     * 注册回调函数
     *
     * @param {String} type - 回调函数类型
     * @param {function()} callback - 回调函数
     */
    addCallbacks: function (type, callback) {

        var list = this.callbacks[type];

        if (!list) {
            list = [];
            this.callbacks[type] = list;
        }

        if (list.indexOf(callback) === -1) {
            list.push(callback);
        }
    },

    /**
     * 取消某类型回调函数注册
     *
     * @param {String} type - 回调函数类型
     * @param {function()} callback - 回调函数
     */
    removeCallbacks: function (type, callback) {

        var list = this.callbacks[type];

        if (!list) {
            return;
        }

        var index = list.indexOf(callback);

        if (index !== -1) {
            list.splice(index, 1);
        }
    },

    /**
     * 取消所有注册
     *
     */
    removeAllCallbacks: function () {

        for (var type in this.callbacks) {

            var list = this.callbacks[type];

            for (var i = 0, length = list.length; i < length; i++) {
                list.splice(0, 1);
            }
        }

        for (var type in this.callbacks) {

            delete this.callbacks[type];
        }

        this.callbacks = {};
    },

    /**
     * 响应回调
     *
     */
    onCallbacks: function (type) {

        var list = this.callbacks[type];

        if (!list) {
            return;
        }

        // remark：回调函数内部注销回调会造成遍历错误，
        // 这里每次遍历都判断列表长度，实际上这样处理只是避免了系统崩溃，结果其实错误的，因为会漏掉一部分函数处理。
        // 避免回调事件函数内部注销自己(或其它函数事件)
        for (var i = 0; i < list.length; i++) {
            list[i] && list[i]();
        }
    },

    // ------ 注册自定义回调函数 E -------------- //

    // ------ 管理外部插件的render S -------------- //

    /**
     * 注册 render 回调函数
     *
     * @param {function()} callback - render 回调函数
     */
    addRenderCallback: function (callback) {
        this.addCallbacks("render", callback);
    },

    /**
     * 取消 render 回调注册
     *
     * @param {function()} callback - render 回调函数
     */
    removeRenderCallback: function (callback) {
        this.removeCallbacks("render", callback);
    },

    /**
     * 响应 render 回调
     *
     */
    onRenderCallback: function () {
        this.onCallbacks("render");
    },

    /**
     * 注册 render Finished
     *
     */
    addRenderFinishedCallback: function (callback) {
        this.addCallbacks("renderFinished", callback);
    },

    /**
     * 取消 render Finished 注册
     *
     * @param {function()} callback - render finished 回调函数
     */
    removeRenderFinishedCallback: function (callback) {
        this.removeCallbacks("renderFinished", callback);
    },

    /**
     * 响应 render Finished
     *
     */
    onRenderFinishedCallback: function () {
        this.onCallbacks("renderFinished");
    },

    // ------ 管理外部插件的render E -------------- //

    /**
     * 释放资源
     *
     */
    destroy: function () {

        this.removeAllCallbacks();
        this.editorManager.unregisterDomEventListeners(this.domElement);
        this.domElement.removeChild(this.domElement.childNodes[0]);
        this.domElement = null;

        this.editorManager.destroy();
        this.modelManager.destroy();

        if (this.renderer && this.renderer.destroy) {
            this.renderer.destroy();
        }

        this.renderer = null;
        this.modelManager = null;
        this.editorManager = null;
    },

    _setupRenderer: function () {
        var scope = this;
        var settings = this.renderSettings;
        if (CLOUD.GlobalData.BatchMergeEnabled) {
            CLOUD.GlobalData.IncrementRender = false;
            //CLOUD.GlobalData.Instance = false;//not test yet
            this.renderer = new THREE.WebGLRenderer(settings);
            console.log("renderer: batch merge renderer");
        } else {
            CLOUD.GlobalData.IncrementRender = true;
            //CLOUD.GlobalData.Instance = false;//tested
            this.renderer = new THREE.WebGLRendererByIncrement(settings);
            this.orderedRenderer = new CLOUD.OrderedRenderer();
            this.renderer.setRenderer(this.orderedRenderer);
            this.renderer.setRenderTicket(0);
            console.log("renderer: increment renderer");
        }

        this.renderer.domElement.addEventListener("webglcontextlost", function (event) {
            event.preventDefault();
            if (scope.incrementRenderHandle > 0) {
                cancelAnimationFrame(scope.incrementRenderHandle);
                console.log("---------------- webglcontextlost --------------");
            }
        }, false);

        // window.innerWidth, window.innerHeight
        var viewportWidth = this.domElement.offsetWidth;
        var viewportHeight = this.domElement.offsetHeight;

        this.renderer.setClearColor(0x000000, 0);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(viewportWidth, viewportHeight);

        this.renderer.toneMapping = CLOUD.GlobalData.ToneMapping;
        this.renderer.gammaFactor = 2.2;
        this.renderer.gammaInput = true;
        this.renderer.gammaOutput = true;

        // Added by xmh begin
        // 允许获得焦点，将键盘事件注册到父容器（之前注册到window上会存在各种联动问题），鼠标点击父容器，激活canvas
        this.renderer.domElement.setAttribute('tabindex', '0');
        this.renderer.domElement.setAttribute('id', 'cloud-main-canvas');
        // Added by xmh end
        this.domElement.appendChild(this.renderer.domElement);
        // Register Events
        this.editorManager.registerDomEventListeners(this.domElement);

        CLOUD._renderComposer.init(this.renderer, viewportWidth, viewportHeight);
    },

    /**
     * 初始化
     *
     * @param {dom} domElement - dom容器
     */
    init: function (domElement) {

        console.log("Web3D: " + CLOUD.Version);
        CLOUD.GlobalData.IsMobile = !(this.isDesktop());

        var scope = this;
        var maxDrawCacheNum = CLOUD.GlobalData.maxDrawCacheNum;
        var settings = {alpha: true, preserveDrawingBuffer: true, antialias: true, maxDrawCacheNum: maxDrawCacheNum};

        //if (!CLOUD.GlobalData.disableAntialias)
        //    settings.antialias = true;

        var canvas;
        try {
            canvas = document.createElement('canvas');
            var webglContext = canvas.getContext('webgl', settings) || canvas.getContext('experimental-webgl', settings);
            if (!webglContext) {
                settings.antialias = false;
            }
            settings.webglContext = webglContext;
        } catch (e) {
            return false;
        }

        this.domElement = domElement;

        CLOUD.GeomUtil.initializeUnitInstances();

        settings.canvas = canvas;
        this.renderSettings = settings;

        // window.innerWidth, window.innerHeight
        var viewportWidth = domElement.offsetWidth;
        var viewportHeight = domElement.offsetHeight;

        // Camera
        var cameraParams = {width: viewportWidth, height: viewportHeight, fov: 45, near: 0.1, far: CLOUD.GlobalData.SceneSize * 20.0};
        this.camera = this.defaultCamera = new CLOUD.Camera(CLOUD.CAMERATYPE.PERSPECTIVE, cameraParams );
        var camera = this.camera;
        this.cameraControl = new CLOUD.CameraControl(this, this.getScene(), camera, domElement, function (sceneNotChanged) {
            scope.render(sceneNotChanged);
        });

        this.setEditorDefault();

        // // Register Events
        // this.editorManager.registerDomEventListeners(this.domElement);

        this.modelManager.onUpdateViewer = function () {
            scope.render(true);
        };

        //this.editorManager.registerDomEventListeners(canvas);
        return true;
    },

    /**
     *  刷新渲染模型
     *
     */
    render: function (sceneNotChanged) {

        // benchmark @ 20180314
        // console.time("viewer.render");
        var scope = this;
        var camera = this.camera;
        var modelManager = this.modelManager;
        var renderer = this.renderer;
        var scene = this.getScene();
        var incrementRenderEnabled = CLOUD.GlobalData.IncrementRender;

        // 没有模型加载,返回
        if (!modelManager.hasModel()) {

            // BIMFACEDM-2869
            // 1. empty scene （no model loaded)
            // 2. loaded model was unloaded, we need render empty scene.
            CLOUD.Logger.log("model not loaded!");
            renderer.render(scene, camera);
            return;
        }

        // BIMFACE-144:启用环境光照
        // if (CLOUD.GlobalData.IBL && this.getIBLManager().textureLoad == false) {
        //     return;
        // }
        if (CLOUD.GlobalData.IBL && this.getIBLManager().textureLoad == false) {
            return;
        }

        // BIMFACE-156: 过滤器数据在加载完数据之前就进行过设置（理论上应该数据加载完成之后进行业务操作才正常！），
        // 则进行绘制数据索引重整（该问题出现在【批次合并策略】中）
        // 引擎内部记录过滤状态
        if (modelManager.hasModelDataReady()){
            if (this.getFilter().isStateChanged() || this.isRenderStateChanged()) {
                if (this.getFilter().isStateChanged()) {
                    this.getFilter().diableStateChanged();
                }
                if (this.isRenderStateChanged()) {
                    this.setRenderStateChanged(false)
                }
                this.modelManager.applyFilter();
            }
        }

        // 增量绘制
        if (incrementRenderEnabled) {

            ++this.countRenderRequest;

            if (this.countRenderRequest > this.maxCountRenderRequest)
                this.countRenderRequest = 0;

            if (this.rendering) {
                return;
            }

            this.rendering = true;

            // update camera's inner/outer status, both "calculateNearFar" and "prepareScene" will use this info.
            modelManager.calculateCameraModelRelation(camera.position);
            this.calculateNearFar();
            this.cameraControl.updateCamera();

            scene.updateLights(camera);

            var isUpdateRenderList = this.editorManager.isUpdateRenderList;

            if (CLOUD.GlobalData.EnableRenderPass) {
                CLOUD._renderComposer.restart(sceneNotChanged, this.modelManager.sceneState.hoverId);
                // always update render list
                // TODO: consider a better solution not to update the render list, for example, zoom the scene
                renderer.setObjectListUpdateState(true);
            }
            else {
                renderer.resetIncrementRender();// 重置增量绘制状态
                renderer.setObjectListUpdateState(isUpdateRenderList);// 设置更新状态
            }

            function incrementRender(callId, autoClear) {

                var renderId = callId;

                return function () {

                    // var renderer = scope.renderer;
                    renderer.autoClear = autoClear;

                    if (scope.editorManager.cameraChange) {

                        renderer.resetIncrementRender();// 重置增量绘制状态
                        renderer.autoClear = true;
                        scope.editorManager.cameraChange = false;

                    } else {

                        renderer.autoClear = autoClear;

                    }

                    // var timeTag = "IncrementRender_";
                    // timeTag += renderId;

                    // console.time(timeTag);

                    var isFinished = CLOUD.GlobalData.EnableRenderPass ?
                                        CLOUD._renderComposer.renderIncrement(scene, camera)
                                        :renderer.render(scene, camera);

                    // console.timeEnd(timeTag);

                    if (!isFinished && renderId === scope.countRenderRequest) {
                        // setTimeout(function(){ //throttle requestAnimationFrame to 30fps, ie. 1000/30 = 33ms
                        //     scope.incrementRenderHandle = requestAnimationFrame(incrementRender(scope.countRenderRequest, false));
                        // }, 33);
                        scope.incrementRenderHandle = requestAnimationFrame(incrementRender(renderId, false));

                    } else {

                        scope.rendering = false;

                        // CLOUD.Logger.timeEnd("incrementRender");

                        if (renderId !== scope.countRenderRequest) {
                            scope.render();
                        } else {

                            CLOUD.GlobalData.EnableRenderPass && CLOUD._renderComposer.finish();

                            // benchmark @ 20180314
                            //console.timeEnd("viewer.render");

                            // console.log("------------ finished rendering ------------");
                            // 结束后回调函数
                            scope.onRenderFinishedCallback();
                        }
                    }
                }
            }

            // 这样修改会缺帧，恢复到之前的处理方式
            // setTimeout(function(){ //throttle requestAnimationFrame to 30fps, ie. 1000/30 = 33ms
            //    scope.incrementRenderHandle = requestAnimationFrame(incrementRender(scope.countRenderRequest, true));
            // }, 33);

            this.incrementRenderHandle = requestAnimationFrame(incrementRender(scope.countRenderRequest, true));

            if (isUpdateRenderList) {
                modelManager.prepareScene(camera);
            }

            this.onRenderCallback();

        } else { // 正常绘制

            // update camera's inner/outer status, both "calculateNearFar" and "prepareScene" will use this info.
            modelManager.calculateCameraModelRelation(camera.position);
            this.calculateNearFar();
            this.cameraControl.updateCamera();

            scene.updateLights(camera);
            modelManager.prepareScene(camera);

            CLOUD.Logger.time("webgl render");
            if (CLOUD.GlobalData.EnableRenderPass) {
                CLOUD._renderComposer.restart(sceneNotChanged, this.modelManager.sceneState.hoverId);
                CLOUD._renderComposer.render(scene, camera);
            } else {
                renderer.render(scene, camera, null, true);
            }
            // CLOUD.GlobalData.EnableRenderPass ? CLOUD._renderComposer.render(scene, camera)
            //                                         :renderer.render(scene, camera);
            CLOUD.Logger.timeEnd("webgl render");

            // benchmark @ 20180314
            //console.timeEnd("viewer.render");

            this.onRenderCallback();
            this.onRenderFinishedCallback();// 结束后回调函数
        }

        this.cameraControl.setCameraChanging(false); // add

        // console.timeEnd("viewer.render");
    },

    /**
     * 窗口大小变化回调事件
     *
     * @param {Number} width - 窗口宽
     * @param {Number} height - 窗口高
     */
    resize: function (width, height) {

        var camera = this.camera;
        camera.setSize(width, height);
        camera.updateProjectionMatrix();

        this.renderer.setSize(width, height);
        if (CLOUD.GlobalData.EnableRenderPass) {
            CLOUD._renderComposer.setSize(width, height);
        }

        this.onCallbacks("resize");
        this.render();
    },

    /**
     * 动态计算相机远近裁剪面
     *
     */
    calculateNearFar: function () {

        var scene = this.getScene();
        var boundingBox = scene.getBoundingBoxWorld();
        var camera = this.camera;

        // reducing z-fighting by dynamically adjust near/far
        if (boundingBox != null) {

            var box = this.tmpBox;
            box.copy(boundingBox);
            box.applyMatrix4(scene.getMatrixGlobal());

            var center = box.getCenter();
            var position = camera.position;
            var newPos = position.clone().sub(center);
            var length = newPos.length();
            var maxLength = box.getSize().length();

            var zNear, zFar;

            if (this.modelManager.containsCamera || !this.enableCameraNearFar) {

                zFar = maxLength;

                if (camera.isPerspective) {
                    zNear = 0.1;
                } else {
                    zNear = -zFar;
                }


            } else {

                var radius = 0.5 * maxLength;
                zFar = length + radius;

                if (camera.isPerspective) {
                    var delta = 0.001;
                    zNear = (length * length + length * delta) / ((1 << 24) * delta);

                    if(length > radius && zNear + radius > length) {
                        // BIMFACEDM-2821:
                        // When observing from outside of scene's bound sphere,
                        // avoiding huge 'near' which cutting out the scene.
                        zNear = length - radius;
                    }
                } else {
                    zNear = -zFar;
                }
            }

            camera.setNearFar(zNear, zFar);
        }
    },

    /**
     *  注册Dom事件
     *
     */
    registerDomEventListeners: function () {
        if (this.domElement) {
            this.editorManager.registerDomEventListeners(this.domElement);
        }
    },

    /**
     *  取消Dom事件
     *
     */
    unregisterDomEventListeners: function () {
        if (this.domElement) {
            this.editorManager.unregisterDomEventListeners(this.domElement);
        }
    },

    /**
     *  注册模型事件监听器
     *
     */
    registerEventListener: function (type, callback) {
        this.modelManager.addEventListener(type, callback);
    },

    /**
     * 加载模型
     *
     * @param {String} databagId - 模型包名
     * @param {String} serverUrl - 服务器地址
     * @param {Boolean} notifyProgress - 是否通知加载进度，默认true
     * @param {Boolean} debug - 是否调试，可选
     */
    load: function (databagId, serverUrl, notifyProgress, debug) {

        notifyProgress = notifyProgress || true;
        var scope = this;

        return this.modelManager.load({
                databagId: databagId,
                serverUrl: serverUrl,
                notifyProgress: notifyProgress,
                debug: debug
            },
            function () {
                
                if (scope._useBatchMerge === undefined) {
                    scope._useBatchMerge = scope.modelManager.shouldUseBatchRendering();
                    CLOUD.GlobalData.BatchMergeEnabled = scope._useBatchMerge;
                    scope._setupRenderer();
                }
            },
            function () {

                scope.modelManager.updateScene(); //
                scope.modelManager.updateMeshNodes();

                console.time("Rendering: ");

                // user might do something when finishing loading model,
                // here make default render call after user's customization.
                // customized camera setting ,should dirty the camera.
                if (scope.camera.dirty) {
                    scope.render();
                    var filter = scope.modelManager.filter;
                    var nodeInfos = scope.modelManager.getNodeInfos();
                    filter.initFilterManager(nodeInfos);
                } else {
                    scope.goToInitialView();
                    scope.zoomAll();
                }

                console.timeEnd("Rendering: ");
            });
    },

    /**
     * 卸载模型
     *
     * @param {String} databagId - 模型包名
     */
    unload: function (databagId) {

        // TODO: check the active camera, if the active camera belongs to the model,
        //        should not unload the model

        var success = this.modelManager.unload(databagId);

        if (success) {
            this.zoomAll();
            this.render();
        }

    },

    /**
     * 卸载所有模型
     *
     */
    unloadAll: function () {

        this.modelManager.unloadAll();
        this.render();
    },

    /**
     * 显示指定模型
     *
     * @param {String} databagId - 模型包名
     */
    showModel: function (databagId) {

        var success = this.modelManager.showModel(databagId);

        if (success) {
            this.render();
        }

    },

    /**
     * 隐藏指定模型
     *
     * @param {String} databagId - 模型包名
     */
    hideModel: function (databagId) {

        var success = this.modelManager.hideModel(databagId);

        if (success) {
            this.render();
        }

    },

    /**
     * 隐藏或显示模型
     *
     * @param {Object} model - 模型对象
     *@param {Boolean} bVisible - 是否可见
     */
    showScene: function (model, bVisible) {

        if (model) {

            model.setVisible(bVisible);
            this.render();
        }
    },

    /**
     * 清除场景数据
     *
     */
    clearAll: function () {
        this.getScene().clearAll();
    },

    /**
     * 清空过滤器，取消剖切
     */
    restore: function(){
        this.getFilter().clear();
        this.getScene().disableClipPlanes();
        this.modelManager.dispatchEvent({type: CLOUD.EVENTS.ON_VIEWER_RESTORED});
    },

    /**
     * 获得场景对象
     *
     */
    getScene: function () {
        return this.modelManager.scene;
    },

    /**
     * 获得交互管理对象
     */
    getEditorManager: function() {
        return this.editorManager;
    },

    /**
     * 获得过滤器对象
     *
     */
    getFilter: function () {
        return this.filter;
    },

    /**
     * 获得当前 Editor 名字标识
     *
     * @return {String} Editor 名字标识
     */
    getCurrentEditorName: function () {
        return this.editorManager.getCurrentEditorName();
    },

    /** 获得 Editor 对象
     *
     * @returns {Object} Editor 模式
     */
    getCurrentEditor: function () {

        return this.editorManager.getCurrentEditor();
    },

    /**
     * 设置 Editor 模式
     *
     * @param {String} name - Editor 名字标识 {@link CLOUD.EditorMode}
     */
    setEditorMode: function (name) {
        this.editorManager.setEditorMode(this, name);
    },

    /**
     * 设置缺省的Editor模式（框选模式 - RectPick Editor）
     *
     */
    setEditorDefault: function () {
        this.setEditorMode(CLOUD.EditorMode.PICK);
    },

    /**
     * 设置单选模式 - Pick Editor
     *
     */
    setPickMode: function () {
        console.warn('CLOUD.Viewer.setPickMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.PICK);
    },

    /**
     * 设置框选模式 - RectPick Editor
     *
     */
    setRectPickMode: function () {
        console.warn('CLOUD.Viewer.setRectPickMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.PICK_BY_RECT);
    },

    /**
     * 设置自由旋转模式 - Orbit Editor
     *
     */
    setOrbitMode: function () {
        console.warn('CLOUD.Viewer.setOrbitMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.ORBIT);
    },

    /**
     * 设置缩放模式 - Zoom Editor
     *
     */
    setZoomMode: function () {
        console.warn('CLOUD.Viewer.setZoomMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.ZOOM);
    },

    /**
     * 设置框选缩放模式 - RectZoom Editor
     *
     */
    setRectZoomMode: function () {
        console.warn('CLOUD.Viewer.setRectZoomMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.ZOOM_BY_RECT);
    },

    /**
     * 设置平移模式 - Pan Editor
     *
     */
    setPanMode: function () {
        console.warn('CLOUD.Viewer.setPanMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.PAN);
    },

    /**
     * 设置飞行模式 - Fly Editor
     *
     */
    setFlyMode: function () {
        console.warn('CLOUD.Viewer.setFlyMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.FLY);
    },

	/**
     * 设置测量模式 - Measure Editor
     *
     */
    setMeasureMode: function () {
        console.warn('CLOUD.Viewer.setMeasureMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.MEASURE);
    },

    /**
     * 设置切面模式 - ClipPlanes Editor
     *
     */
    setClipPlanesMode: function () {
        console.warn('CLOUD.Viewer.setClipPlanesMode() has been deprecated. Use CLOUD.Viewer.setEditorMode(name) instead.');
        this.setEditorMode(CLOUD.EditorMode.CLIP_BY_BOX);
    },

    /**
     * 获得场景包围盒(变换前)
     *
     * @return {THREE.Box3} 场景包围盒
     */
    getBoundingBoxWorld: function () {
        return this.getScene().getBoundingBoxWorld();
    },

    /**
     * 获得场景包围盒(变换后)
     *
     * @return {THREE.Box3} 场景包围盒
     */
    getBoundingBox: function () {
        return this.getScene().getBoundingBox();
    },

    /**
     * 放大
     *
     * @param {Number} factor - 放大因子
     */
    zoomIn: function (factor) {
        // 缩放时，改变相机缩放因子zoom，就会改变相机FOV，从而造成模型显示变形
        // 思路：保持相机FOV和目标点位置不变，调整相机位置达到缩放的目的
        //this.camera.setZoom(factor);

        // 放大，factor > 0
        if (factor === undefined) {
            factor = 0.1;
        }

        if (factor < 0) {
            factor = 0;
        }

        this.cameraControl.zoom(factor);
    },

    /**
     * 缩小
     *
     * @param {Number} factor - 缩小因子
     */
    zoomOut: function (factor) {
        // 缩放时，改变相机缩放因子zoom，就会改变相机FOV，从而造成模型显示变形
        // 思路：保持相机FOV和目标点位置不变，调整相机位置达到缩放的目的
        //this.camera.setZoom(factor);

        if (factor === undefined) {
            factor = 0.1;
        }

        if (factor > 0) {
            factor *= -1;
        } else {
            factor = 0;
        }

        // 缩小，factor < 0
        this.cameraControl.zoom(factor);
    },

    /**
     * 缩放到场景包围盒大小
     *
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    zoomAll: function (margin, ratio) {
        var box = this.getScene().getBoundingBox();
        this._zoomToLocalBBox(box, margin, ratio);
    },

    /**
     * 缩放到场景内部包围盒大小
     *
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    zoomToBuilding: function (margin, ratio) {

        this.zoomAll(margin, ratio);
    },

    /**
     * 缩放到选中构件包围盒大小
     *
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    zoomToSelection: function (margin, ratio) {
		var scene = this.getScene();
		var sceneState = this.modelManager.sceneState;
        // var box = scene.getBoundingBoxOfGeometries(sceneState.getSelectionSet());
        var box = this.getBoundingBoxByIds(sceneState.getSelectionSet());
        if(box.isEmpty()) {
            box = scene.getBoundingBox(); // workspace
        }
        this._zoomToLocalBBox(box, margin, ratio);
    },

	/** Internal use only */
    /**
     * 缩放到指定包围包围盒大小
     *
     * @param {THREE.Box3} box - 包围盒（工作区坐标系，非世界坐标系）
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    _zoomToLocalBBox: function (box, margin, ratio, direction) {

        // TODO: zoomToBox的转场动画没实现（现在的CameraAnimator只是根据相机dir和up进行了插值)，重构时实现
        // TODO: regulaize camera and cameraControl's responsibility
        this.camera.zoomToBBox(box, margin, ratio, direction);
        this.cameraControl.update(true, true);
    },

    /**
     * 缩放到指定包围包围盒大小
     *
     * @param {THREE.Box3} box - 包围盒（世界坐标系）
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    zoomToBBox: function (box, margin, ratio) {

        // VAAS-335: zoomToBBox changes input parameter "box".
        // Make a copy of "box".
        var _bound = new THREE.Box3();
        if (!box) {
            _bound.copy(this.getScene().getBoundingBox());
        } else {
            _bound.copy(box);
            _bound.applyMatrix4(this.getScene().getMatrixGlobal());
        }
        this._zoomToLocalBBox(_bound, margin, ratio);
    },

    /**
     * 根据观察方向缩放到指定包围盒范围
     *
     * @param {THREE.Box3} box - 包围盒（世界坐标系）
     * @param {THREE.Vector3} direction - 观察方向（从包围盒中心指向某个参考点）
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    zoomToBBoxByDirection: function (box, direction, margin, ratio) {

        if (!direction) {
            this.zoomToBBox(box, margin, ratio);
            return;
        }

        if (direction && box) {
            var zoomBox = box.clone();
            var refPoint = zoomBox.getCenter().clone().add(direction);

            zoomBox.applyMatrix4(this.getScene().getMatrixGlobal());
            refPoint.applyMatrix4(this.getScene().getMatrixGlobal());

            var newDirection = refPoint.clone().sub(zoomBox.getCenter());

            if (newDirection.length() > 0.0001) {
                newDirection.normalize();
                viewer.camera.realUp.copy(THREE.Object3D.DefaultUp);// 先调整相机up方向,使得一直朝上
				this._zoomToLocalBBox(zoomBox, margin, ratio, newDirection);
            } else {
				this._zoomToLocalBBox(zoomBox, margin, ratio);
            }
        }

    },

    /**
     * 根据外围大包围盒和指定包围盒缩放到指定包围盒范围
     *
     * @param {THREE.Box3} box - 指定构件包围盒（世界坐标系）
     * @param {THREE.Box3} outerBox - 外围大包围盒
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    zoomToBBoxWithOuterBox: function (box, outerBox, margin, ratio) {

        if (!outerBox) {
            this.zoomToBBox(box, margin, ratio);
            return;
        }

        if (outerBox && box) {
            var zoomBox = box.clone();
            var refPoint = outerBox.getCenter();

            zoomBox.applyMatrix4(this.getScene().getMatrixGlobal());
            refPoint.applyMatrix4(this.getScene().getMatrixGlobal());

            var newDirection = refPoint.clone().sub(zoomBox.getCenter());

            if (newDirection.length() > 0.0001) {
                newDirection.normalize();
                this.camera.realUp.copy(THREE.Object3D.DefaultUp);// 先调整相机up方向,使得一直朝上
				this._zoomToLocalBBox(zoomBox, margin, ratio, newDirection);
            } else {
				this._zoomToLocalBBox(zoomBox, margin, ratio);
            }

        }
    },

    /**
     * 获取指定box中的构件ID列表
     * @param {THREE.Box3} box - 包围盒
     * @return 构件ID数组
     */
    getObjectsInBox: function(box){
        var _bound = new THREE.Box3();
        _bound.copy(box);
        _bound.applyMatrix4(this.getScene().getMatrixGlobal());
        return CLOUD.PickUtil.getObjectsInBox(this.getScene(), _bound, this.modelManager, this);
    },

    /**
     * 设置视角
     * TODO: 这个函数应该叫做goToStandardView , 因为它触发了绘制。相机需要整体重构。
     *
     * @param {Number} stdView - 视角（CLOUD.EnumStandardView.ISO， CLOUD.EnumStandardView.Top etc）
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Function} callback() - 回调函数
     */
    setStandardView: function (stdView, margin, callback) {

        var box;
        var camera = this.camera;

        box = this.getScene().getBoundingBox();

        if (this.transitionAnimationState) { //enableAnimation

            this.animator.setStandardView(stdView, this, box, margin, callback);

        } else {

            camera.setStandardView(stdView, box); // 设置观察视图

            var target = this.camera.zoomToBBox(box, margin);// fit all
            this.cameraControl.update(true, true);

            callback && callback();// 是否回调

        }

    },

    /**
     * 设置观察视图, 该动作会不会触发重新绘制 (私有）
     * 该接口依赖场景数据，须在场景加载完成后使用才可以达到期望的结果。
     * TODO: 重构viewer 应该通过CameraControl控制相机姿态，而不应该直接使用camera
     * 2018.01.31 xiaojian
     *
     *
     * @param {Number} stdView - 视角（CLOUD.EnumStandardView.ISO， CLOUD.EnumStandardView.Top etc）
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     */
    _setStandardView: function (stdView, margin) {

        var camera = this.camera;
        var box = this.getScene().getBoundingBox();
        camera.setStandardView(stdView, box);
        camera.zoomToBBox(box, margin);
    },
    /**
     * 根据指定视角及包围盒缩放
     *
     * @param {Number} stdView - 视角（CLOUD.EnumStandardView.ISO， CLOUD.EnumStandardView.Top etc）
     * @param {THREE.Box3} box - 原始（未变换的）世界包围盒
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    setStandardViewWithBox: function (stdView, box, margin, ratio) {

        if (box) {
            box.applyMatrix4(this.getScene().getMatrixGlobal());
        } else {
            box = this.getScene().getBoundingBox();
        }

        if (this.transitionAnimationState) { //enableAnimation

            this.animator.setStandardView(stdView, this, box, margin);

        } else {

            var camera = this.camera;
            camera.setStandardView(stdView, box); // 设置观察视图
            camera.zoomToBBox(box, margin, ratio);
            this.cameraControl.update(true, true);
        }
    },

    /**
     * 根据 Top 视角及包围盒缩放(注意：这里名字有误导， 其实被设成了 ISO 视角)
     *
     * @param {THREE.Box3} box - 原始（未变换的）世界包围盒
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.0, margin > 0 模型缩小（包围盒变大），margin < 0 模型放大（包围盒变小）
     * @param {Number} ratio - 相机与中心距离的拉伸比例, 缺省值: 1.0
     */
    setTopView: function (box, margin, ratio) {
        this.setStandardViewWithBox(CLOUD.EnumStandardView.ISO, box, margin, ratio);
    },

    /**
     * 设置初始视角
     *
     * @param {Number} viewType - 视角（CLOUD.EnumStandardView.ISO， CLOUD.EnumStandardView.Top etc）
     */
    setInitialViewType: function (viewType) {

        console.warn('CLOUD.Viewer.setInitialViewType() has been deprecated. Use CLOUD.Viewer.setInitialView() instead.');
        this.setInitialView(viewType);
    },

    /**
     * 设置初始视角
     *
     * @param {Number} viewType - 视角（CLOUD.EnumStandardView.ISO， CLOUD.EnumStandardView.Top etc）
     */
    setInitialView: function (viewType) {
        this.initialView = viewType;  // TODO: 不应该在接口层维护相机状态，移至CameraControl
        this._setStandardView(viewType);

    },

    /**
     * 切换到初始视图
     *
     */
    goToInitialView: function (margin) {
        this.setStandardView(this.initialView, margin, null);
    },

    /**
     * 设置 home 视图类型
     *
     * @param {Number} viewType - 视角（CLOUD.EnumStandardView.ISO， CLOUD.EnumStandardView.Top etc）
     */
    setHomeViewType: function (viewType) {
        console.warn('CLOUD.Viewer.setHomeViewType() has been deprecated. Use CLOUD.Viewer.setHomeView() instead.');
        this.setHomeView(viewType);
    },

    /**
     * 设置 home 视图类型
     *
     * @param {Number} viewType - 视角（CLOUD.EnumStandardView.ISO， CLOUD.EnumStandardView.Top etc）
     */
    setHomeView: function (viewType) {
        this.currentHomeView = viewType;
        this._setStandardView(viewType);

    },

    /**
     * 切换到 home 视图
     *
     * @param {Number} margin - 包围盒缩放比例, 缺省值: 0.05
     */
    goToHomeView: function (margin) {
        this.setStandardView(this.currentHomeView, margin, null);
    },

    /**
     * 绕场景中心沿指定轴旋转一定角度
     *
     * @param speedRate 旋转速率；大于0 时逆时针旋转，小于0 时顺时针旋转
     * @param axis 旋转轴， 'x' 或 'y'， 默认为x 轴
     */
    rotateByAxis: function(speedRate, axis) {
        var rotatePivot = this.cameraControl.calculatePivot(CLOUD.RotatePivotMode.CENTER, null);

        var speed = 2 * Math.PI / 60 / 60 * speedRate;
        if (!axis || axis == 'x') {
            this.cameraControl.handleRotation(-speed, 0, rotatePivot);
        } else if (axis == 'y') {
            this.cameraControl.handleRotation(0, -speed, rotatePivot);
        } else {
            console.warn("Illegal rotation axis for Viewer.rotateByAxis().");
            return;
        }

        this.cameraControl.update(true);
    },

    /**
     * 设置图片资源的路径。默认在“images/”
     *
     * @param {String} path - 资源路径
     */
    setImageResPath: function (path) {
        CLOUD.GlobalData.TextureResRoot = path;
    },

    /**
     * 设置场景中所有灯光的光照强度的调整系数
     *
     * @param {Number} factor - 灯光强度系数
     */
    setLightIntensityFactor: function (factor) {
        CLOUD.GlobalData.LightIntensityFactor = factor;
    },

    /**
     * 设置每帧的最大耗时
     *
     * @param {Number} limitTime - 最长时间
     */
    setLimitFrameTime: function (limitTime) {
        if (CLOUD.GlobalData.IncrementRender) {

            if (limitTime <= 0) {
                limitTime = 30;
            }

            CLOUD.GlobalData.LimitFrameTime = limitTime;
        }
    },

    /**
     * 限制帧率
     *
     * @param {Number} frameRate - 最大帧率
     */
    limitFrameRate: function (frameRate) {

        if (CLOUD.GlobalData.IncrementRender) {

            if (frameRate <= 0) {
                frameRate = 4;
            }

            CLOUD.GlobalData.LimitFrameTime = 1000 / frameRate;
        }
    },

    /**
     * 相机变换 - 将世界系相机位置变化到绘图空间
     *
     * @param {Object} camera - 相机状态JSON对象
     *                          （{"position":"26513.603437903, -14576.4810728955, 15107.6582255056",
     *                          "direction":"-220.050259546712, 169.277369901229, -125.801809656091",
     *                          "up":"0, 0, 304.8"})
     * @return {Object} 新相机信息
     */
    transformCamera: function (camera) {
        return CLOUD.CameraUtil.transformCamera(camera, this.modelManager.scene);
    },

    /**
     * 获得世界空间的相机状态，包括：
     *     name：     相机名称
     *     position:  位置
     *     target:    相机对准的目标
     *     up:        相机向上的朝向
     *
     * @return {String} 相机信息字符串
     */
    getCamera: function () {
        //return this.cameraControl.getCameraInfo();

        var scene = this.getScene();
        var matrixScene = scene.getMatrixGlobal();

        var camera = this.cameraControl.getCamera();
        var cameraName = this.cameraControl.getCameraName();
        var camInfo = new CLOUD.CameraInfo(cameraName,camera.position, camera.target, camera.up);

        camInfo = CLOUD.Camera.drawingToWorld(camInfo, matrixScene);

        var newCameraInfo = new CLOUD.CameraInfo(cameraName,camInfo.position, camInfo.target, camInfo.up);

        return JSON.stringify(newCameraInfo);
    },

    /**
     * 设置世界空间(兼容绘图空间，无版本号的数据为绘图空间数据)的相机状态
     *
     * @param {String} jsonStr - 相机信息字符串
     * @param {Boolean} force - 是否强制更新相机
     * @param {Function} callbackFinish - 相机设置完成后回调函数
     */
    setCamera: function (jsonStr, force, callbackFinish) {

        var scope = this;

        var camInfo = CLOUD.CameraUtil.parseCameraInfo(jsonStr);
        if (camInfo === null) {
            console.log("Invalid camera info string. Fail to set camera.")
        }else if ( this.switchToCamera(camInfo.name)) {

            var scene = this.getScene();
            var matrixScene = scene.getMatrixGlobal();
            var newCameraInfo = null;

            // 临时代码：兼容处理
            if (camInfo.version) {
                newCameraInfo = CLOUD.Camera.worldToDrawing(camInfo, matrixScene);
            } else {
                newCameraInfo = camInfo;
            }

            if (this.transitionAnimationState) {

                var currentCameraInfo = {
                    position: this.camera.position.clone(),
                    target: this.camera.target.clone(),
                    up: this.camera.up.clone()
                };

                this.animator.active(currentCameraInfo, newCameraInfo, this, function (target) {
                    scope.cameraControl.update(true, true);
                }, callbackFinish)

            } else {

                var dir = new THREE.Vector3();
                dir.subVectors(newCameraInfo.target, newCameraInfo.position);
                this.camera.LookAt(newCameraInfo.target, dir, newCameraInfo.up);

                if(force) {
                    this.cameraControl.updateCamera();
                }

                callbackFinish && callbackFinish();
            }
        }
    },

    /**
     * 获得render buffer base64图形数据
     *
     * @param {Color} backgroundClr - 背景颜色
     * @param {Function} callback - 回调函数（参数为截取的 base64 图形数据）
     * @return {String} 如果存在回调函数，则返回 null， 否则 返回 base64 图形数据
     */
    getRenderBufferScreenShot: function (backgroundClr, callback) {

        // 在高分屏上toDataURL直接获得图片数据比实际的图片大
        var domElement = this.renderer.domElement;
        var dataUrl = domElement.toDataURL("image/png");
        var canvasWidth = domElement.width;
        var canvasHeight = domElement.height;
        var pixelRatio = window.devicePixelRatio || 1;
        var w = canvasWidth / pixelRatio;
        var h = canvasHeight / pixelRatio;

        if (!w || !h) {

            if (callback) {
                callback(dataUrl);
                return null
            } else {
                return dataUrl;
            }
        }

        var nw, nh, nx = 0,
            ny = 0;

        if (w > h || (canvasWidth / canvasHeight < w / h)) {
            nw = w;
            nh = canvasHeight / canvasWidth * w;
            ny = h / 2 - nh / 2;
        } else {
            nh = h;
            nw = canvasWidth / canvasHeight * h;
            nx = w / 2 - nw / 2;
        }

        if (callback) {

            var newImage = new Image();
            newImage.onload = function () {

                var tmpCanvas = document.createElement("canvas");
                var ctx = tmpCanvas.getContext("2d");
                tmpCanvas.width = w;
                tmpCanvas.height = h;

                if (backgroundClr) {
                    ctx.fillStyle = backgroundClr;
                    ctx.fillRect(0, 0, w, h);
                }

                ctx.drawImage(newImage, nx, ny, nw, nh);

                var newURL = tmpCanvas.toDataURL("image/png");

                callback(newURL);
            };

            newImage.src = dataUrl;

            return null;
        }

        var newImage = new Image();

        newImage.src = dataUrl;

        var tmpCanvas = document.createElement("canvas");
        var ctx = tmpCanvas.getContext("2d");
        tmpCanvas.width = w;
        tmpCanvas.height = h;

        if (backgroundClr) {
            ctx.fillStyle = backgroundClr;
            ctx.fillRect(0, 0, w, h);
        }

        ctx.drawImage(newImage, nx, ny, nw, nh);

        var newURL = tmpCanvas.toDataURL("image/png");

        return newURL;
    },

    /**
     * 截取指定大小的base64图形
     *
     * @param {Number} width - 截图宽度
     * @param {Number} height - 背景颜色
     * @param {Function} callback - 回调函数（参数为截取的 base64 图形数据）
     * @return {String} 如果存在回调函数，则返回 null， 否则 返回 base64 图形数据
     */
    screenShot: function (width, height, callback) {
        var scope = this;

        function getRenderBufferScreenShot(width, height, callback) {
            var domElement = scope.renderer.domElement;
            var dataUrl = domElement.toDataURL("image/png");
            var canvasWidth = domElement.width;
            var canvasHeight = domElement.height;
            var pixelRatio = window.devicePixelRatio || 1;
            var w = width;
            var h = height;

            if (!w || !h) {
                if (callback) {
                    callback(dataUrl);
                    return null
                } else {
                    return dataUrl;
                }
            }

            var nw, nh, nx = 0,
                ny = 0;

            if (w > h || (canvasWidth / canvasHeight < w / h)) {
                nw = w;
                nh = canvasHeight / canvasWidth * w;
                ny = h / 2 - nh / 2;
            } else {
                nh = h;
                nw = canvasWidth / canvasHeight * h;
                nx = w / 2 - nw / 2;
            }

            if (callback) {

                var newImage = new Image();
                newImage.onload = function () {

                    var tmpCanvas = document.createElement("canvas");
                    var ctx = tmpCanvas.getContext("2d");
                    tmpCanvas.width = w;
                    tmpCanvas.height = h;
                    ctx.drawImage(newImage, nx, ny, nw, nh);

                    var newURL = tmpCanvas.toDataURL("image/png");
                    callback(newURL);
                };

                newImage.src = dataUrl;

                return null;
            }
        }

        var dataUrl = getRenderBufferScreenShot(width, height, callback);

        this.render();

        return dataUrl;
    },

    /**
     * 获得render buffer base64图形数据
     *
     * @param {Color} backgroundClr - 背景颜色
     * @param {Function} callback(dataUrl) - 回调函数（参数为截取的 base64 图形数据）
     * @return {String} 如果存在回调函数，则返回 null， 否则 返回 base64 图形数据
     */
    canvas2image: function (backgroundClr, callback) {

        var dataUrl;
        var scope = this;

        if (callback) {

            this.getRenderBufferScreenShot(backgroundClr, function (dataUrl) {

                callback(dataUrl);

                // 每次获得截图后，缓存数据貌似被清除了
                // 所以在每次调用后render一次
                scope.render();
            });

        } else {

            dataUrl = this.getRenderBufferScreenShot(backgroundClr);
            // 在chrome中多调用几次，会出现图片显示不正常（显示空白，原因是转换的值变得不正常了），
            // 每次获得截图后，缓存数据貌似被清除了
            // 所以在每次调用后render一次
            this.render();

            return dataUrl;

        }

        return null;
    },

    /**
     * 是否锁定Z轴
     *
     * @param {Boolean} isLock - true 锁定， 否则 解锁
     */
    lockAxisZ: function (isLock) {

        if (this.cameraControl) {
            this.cameraControl.lockAxisZ(isLock);
        }
    },
    isLockedAxisZ: function(){
        return this.cameraControl.isLockedAxisZ();
    },

    /**
     * 允许双击半透明
     *
     * @param {Boolean} enable - true 允许
     */
    enableTranslucentByDClick: function (enable) {
        CLOUD.GlobalData.EnableDemolishByDClick = enable;
    },

    /**
     *  旋转照相机
     *
     * @param {THREE.Vector2} rotationDelta - rotation value, pixel value in the screen coordinate
     */
    rotateCamera: function(rotationDelta) {
        this.cameraControl.processRotate(rotationDelta);
		this.cameraControl.update();
    },

    /**
     * 取得照相机信息，包括照相机的朝向和up轴方向
     */
    getActiveCameraInfo: function() {
        var info = {};
        info.up = new THREE.Vector3();
        info.dir = new THREE.Vector3();

        var mainCamera = this.camera;

        // 获得相机方向向量
        var dir = mainCamera.getWorldDirection();

        info.up.copy(mainCamera.realUp || mainCamera.up);
        info.dir.copy(dir);

		return info;
    },

    /**
     * 计算切面
     *
     */
    calculationPlanes: function () {

        if (this.isRecalculationPlanes) {
            this.isRecalculationPlanes = false;
            var scene = this.getScene();
            // var box = this.getScene().getBoundingBoxOfGeometries();
            var box = this.getBoundingBoxByIds();
            if(box.isEmpty()) {
                box = scene.getBoundingBox();
            }
            scene.getClipPlanes().calculationPlanes(box.getSize(), box.getCenter());
            this.render();
        }
    },

    /**
     * 重置切面状态
     *
     */
    recalculationPlanes: function () {
        this.isRecalculationPlanes = true;
    },

    /**
     * 设置octree 深度
     *
     * @param {Number} depth - 深度
     */
    setOctantDepth: function (depth) {
        CLOUD.GlobalData.OctantDepth = depth;
    },

    /**
     * 重置对象池大小
     *
     * @param {Number} size - 对象池对象数
     */
    resizePool: function (size) {
        CLOUD.GlobalData.maxObjectNumInPool = size;
        this.modelManager.updateSceneRenderable();
        this.render();
    },

    /**
     * 设置高优先级
     *
     * @param {Array} categories - 高优先级category
     * @param {Number} region - 内外部（0：内部，1：外部）
     */
    setCategoriesToHighPriority: function (categories, region) {
        var side = (region == 0) ? "inner" : "outer";
        this.modelManager.setCategoriesToHighPriority(categories, side);
    },

    /**
     * 清除内部或者外部 category 高优先级
     *
     * @param {Number} region - 内外部（0：内部，1：外部）
     */
    clearCategoriesFromHighPriority: function (region) {
        var side = (region == 0) ? "inner" : "outer";
        this.modelManager.clearCategoriesFromHighPriority(side);
    },

    /**
     * 清除内外部 category 高优先级
     *
     */
    clearAllCategoriesFromHighPriority: function () {
        this.modelManager.clearAllCategoriesFromHighPriority();
    },

    /**
     * 按条件隔离构件
     *
     * @param {Array} conditions    - 多个条件对象数组，单个数组取交集，多个数组取并集
     *                                  [{"categoryId":-2001340},{"specialty":"AR"},{"categoryId":-2321500,"levelName":"F03"}]
     * @param {String} state        - 隔离的方式 "hide"：其他隐藏，"translucent"：其他半透明
     */
    isolate: function (conditions, state) {

        var filter = this.getFilter();

        switch (state) {
            case "hide":
                filter.setIsolateConditions(conditions, CLOUD.EnumIsolateState.HIDDEN_OTHERS);
                break;
            case "translucent":
                filter.setIsolateConditions(conditions, CLOUD.EnumIsolateState.TRANSLUCENT_OTHERS);
                break;
            default:
                console.log("no this isolate state : " + state);
                break;
        }


    },

    /**
     * 设置隔离构件材质
     *
     * @param {Object} params - 材质参数
     *         params = {color: 0x888888, opacity: 0.1, transparent: true, side: THREE.DoubleSide}
     */
    setIsolateMaterial: function (params) {

        var filter = this.getFilter();
        filter.setIsolateMaterial(params);

    },

    /**
     * 重置隔离材质
     *
     */
    resetIsolateMaterial: function () {

        var filter = this.getFilter();
        filter.resetIsolateMaterial();

    },

    /**
     * 设置左右键，只对Orbit/Pick editor模式起作用
     *
     * @param {String} button - 左右键标识 ("left"," right")
     */
    setOrbitButton: function (button) {
		var orbitEditor = this.editorManager._getEditorByName(this, CLOUD.EditorMode.ORBIT);
		var pickEditor = this.editorManager._getEditorByName(this, CLOUD.EditorMode.PICK);
		var config = {};
		if (button === "left") {

			config = {
				ORBIT: THREE.MOUSE.LEFT,
				PAN2: THREE.MOUSE.MIDDLE,
				PAN: THREE.MOUSE.RIGHT
			};

		} else if (button === "right") {

			config = {
				ORBIT: THREE.MOUSE.RIGHT,
				PAN2: THREE.MOUSE.MIDDLE,
				PAN: THREE.MOUSE.LEFT
			};

		}

		if (orbitEditor) orbitEditor.updateButtons(config);
		if (pickEditor) pickEditor.updateButtons(config);
    },

    /**
     * 显示轴网信息
     *
     * @param {Object} intersect - 相交信息对象, 来源pick, 参考ON_CLICK_PICK事件的返回对象
     */
    showPickedInformation: function (intersect) {

        CLOUD.UIHelper.showPickedInformation(intersect);

    },

    //callback函数中只包含一个intersect参数，intersect是一个对象包含以下变量
    //databagId, distance, face, faceIndex, object:MeshEx, point userId, worldBoundingBox, worldPosition
    setSelectPadCallback: function (callback) {

        //var selectPad = this.editorManager.editors[CLOUD.BaseEditor.EditorType.PickWithRect].selectPad;

        var editor = this.editorManager.getCurrentEditor();

        if (editor && editor.selectPad) {
            editor.selectPad.callback = callback;
        }

    },
    /**
     * 设置客户端设备是否是移动端，
     *
     * @param isMobile, true 表示客户端运行在移动设备上。false 表示非移动端（一般指PC）
     */
    setDeviceMobile: function (isMobile) {
        CLOUD.GlobalData.IsMobile = isMobile || false;
    },

    /**
     * 设置绕点旋转模式
     *
     * @param {Number} mode - 模式 参见CLOUD.RotatePivotMode
     */
    setPointRotateMode: function (mode) {

        CLOUD.EditorConfig.RotatePivotMode = mode;

    },

    /**
     * 世界坐标转绘图空间(场景变换后)坐标
     *
     * @param {object} point - 世界坐标下的点集 {x:0, y:0, z:0}
     * @return {object} 绘图区域坐标 {x:0, y:0, z:0}
     */
    worldToDrawing: function (point) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return null;
        }

        var scene = this.getScene();
        var retPoint = scene.worldToDrawing(point);

        return {x: retPoint.x, y: retPoint.y, z: retPoint.z};
    },

    /**
     * 绘图空间(场景变换后)坐标转世界坐标
     *
     * @param {object} point - 绘图区域坐标下的点集 {x:0, y:0, z:0}。
     * @return {object} 世界坐标 {x:0, y:0, z:0}
     */
    drawingToWorld: function (point) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return null;
        }

        // 转世界坐标
        var scene = this.getScene();
        var retPoint = scene.drawingToWorld(point);

        return {x: retPoint.x, y: retPoint.y, z: retPoint.z};
    },

    /**
     * 世界坐标转客户坐标(相对于canvas区域)
     *
     * @param {object} wPoint - 世界坐标下的点集 {x:0, y:0, z:0}
     * @return {object} 客户区域坐标 {x:0, y:0, z:0}, 没有转换则返回null
     */
    worldToCanvas: function (wPoint) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return null;
        }

        var clientRect = cameraControl.getContainerDimensions();

        if (!clientRect) {
            return null;
        }

        var camera = cameraControl.getCamera();
        var scene = this.getScene();

        // 转绘图空间坐标(场景变换)
        var point = scene.worldToDrawing(wPoint);

        // 转相对于canvas的坐标
        var result = CLOUD.CameraUtil.drawingToCanvas(camera, point, clientRect.width, clientRect.height);

        return result;

    },

    /**
     * 客户区域坐标(相对于canvas区域)转世界坐标
     *
     * @param {object} cPoint - 客户区域坐标下的点集 {x:0, y:0, z:0}, 其中z为进行反投影是的深度，默认为 0。
     * @return {object} 世界坐标 {x:0, y:0, z:0}, 没有转换则返回null
     */
    canvasToWorld: function (cPoint) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return null;
        }

        var clientRect = cameraControl.getContainerDimensions();

        if (!clientRect) {
            return null;
        }

        var camera = cameraControl.getCamera();
        var scene = this.getScene();

        // 转绘图空间坐标
        var point = CLOUD.CameraUtil.canvasToDrawing(camera, cPoint, clientRect.width, clientRect.height);

        // 转世界坐标
        var result = scene.drawingToWorld(point);

        return {x: result.x, y: result.y, z: result.z};
    },

    /**
     * 世界坐标(原始坐标)转客户区域坐标(相对于窗口客户区域)
     *
     * @param {object} wPoint - 世界坐标下的点集 {x:0, y:0, z:0}
     * @return {object} 客户区域坐标 {x:0, y:0, z:0}, 没有转换则返回null
     */
    worldToClient: function (wPoint) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return null;
        }

        var clientRect = cameraControl.getContainerDimensions();

        if (!clientRect) {
            return null;
        }

        var camera = cameraControl.getCamera();
        var scene = this.getScene();

        // 转绘图空间坐标(场景变换)
        var point = scene.worldToDrawing(wPoint);

        // 转相对于canvas的坐标
        var result = CLOUD.CameraUtil.drawingToCanvas(camera, point, clientRect.width, clientRect.height);

        if (result) {

            // 转客户区域坐标
            result.x += clientRect.left;
            result.y += clientRect.top;

            return result;
        }

        return null;
    },

    /**
     * 世界坐标(原始坐标)转客户区域坐标(相对于窗口客户区域),主要解决三维坐标在相机后面的情况
     *
     * @param {object} start - 世界坐标下的起点 {x:0, y:0, z:0}
     * @param {object} end - 世界坐标下的终点 {x:0, y:0, z:0}
     * @return {object} 客户区域坐标 {start:{x:0, y:0, z:0}, end:{x:0, y:0, z:0}}, 没有转换则返回null
     */
    worldPointsToClient: function (start, end) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return null;
        }

        var clientRect = cameraControl.getContainerDimensions();

        if (!clientRect) {
            return null;
        }

        var camera = cameraControl.getCamera();
        var scene = this.getScene();

        var _start = scene.worldToDrawing(start);
        var _end = scene.worldToDrawing(end);

        var result = CLOUD.CameraUtil.drawingPointsToCanvas(camera, _start, _end, clientRect.width, clientRect.height);

        if (result) {

            // 转客户区域坐标
            result.start.x += clientRect.left;
            result.start.y += clientRect.top;

            result.end.x += clientRect.left;
            result.end.y += clientRect.top;

            return result;
        }

        return null;

    },

    /**
     * 客户区域坐标(相对于窗口客户区域)转世界坐标(原始坐标)
     *
     * @param {object} cPoint - 客户区域坐标下的点集 {x:0, y:0, z:0}, 其中z为进行反投影是的深度，默认为 0。
     * @return {object} 世界坐标 {x:0, y:0, z:0}, 没有转换则返回null
     */
    clientToWorld: function (cPoint) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return null;
        }

        var clientRect = cameraControl.getContainerDimensions();

        if (!clientRect) {
            return null;
        }

        var point = {x: cPoint.x, y: cPoint.y, z: cPoint.z};

        // 转相对于canvas的坐标
        point.x -= clientRect.left;
        point.y -= clientRect.top;

        var camera = cameraControl.getCamera();
        var scene = this.getScene();

        // 转绘图空间坐标
        var point = CLOUD.CameraUtil.canvasToDrawing(camera, point, clientRect.width, clientRect.height);

        // 转世界坐标
        var result = scene.drawingToWorld(point);

        return {x: result.x, y: result.y, z: result.z};
    },

    /**
     * 世界坐标(原始坐标)点含在相机视锥中
     *
     * @param {object} wPoint - 世界坐标 {x:0, y:0, z:0}
     * @return {Boolean} 在相机视锥中，返回true，否则，返回false
     */
    insideCamera: function (wPoint) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return false;
        }

        var scene = this.getScene();

        // 转换到绘制空间的坐标
        var point = scene.worldToDrawing(wPoint);
        var frustum = cameraControl.getFrustum();

        return frustum.containsPoint(point);
    },

    /**
     * 根据给定世界系中的点以平行视线方向定位
     *
     * @param {Object} wPoint - 世界系坐标点 {x: 0, y:0, z:0}
     */
    locateToPointWithParallelEye: function (wPoint) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return false;
        }

        var scene = this.getScene();
        var point = scene.worldToDrawing(wPoint);

        cameraControl.flyToPointWithParallelEye(point);

    },

    /**
     * 根据给定世界系中的点保持视角进行定位
     *
     * @param {Object} wPoint - 世界系坐标点 {x: 0, y:0, z:0}
     */
    locateToPoint: function (wPoint) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return false;
        }

        var scene = this.getScene();
        var point = scene.worldToDrawing(wPoint);

        cameraControl.flyToPoint(point);
    },

    /**
     * 是否启用鼠标hover
     *
     * @param {Boolean} enable - 启用或禁止
     */
    enableHover: function (enable) {
        CLOUD.GlobalData.Hover = enable;
    },

    getIBLManager: function() {
        return this.IBLManager;
    },

    loadEnvMap: function (url) {

        var mapUrl = ["posx.hdr", "negx.hdr", "posy.hdr", "negy.hdr", "posz.hdr", "negz.hdr"];
        var envMapUrl = [];
        for (var i = 0; i < 6; ++i) {
            envMapUrl.push('/' + url + "/" + mapUrl[i]);
        }

        var scope = this;
        var cubeTextureLoader = new THREE.HDRCubeTextureLoader();
        cubeTextureLoader.load(THREE.FloatType, envMapUrl, function (hdrCubeMap) {
            scope.environmentCubeMap = hdrCubeMap;
            scope.modelManager.updateMaterialsValue('envMap', hdrCubeMap);
            scope.setRenderStateChanged(true);
            scope.render();
        });

    },

    setEnvMapIntensity: function (value) {
        this.modelManager.updateMaterialsValue("envMapIntensity", value);
        this.setRenderStateChanged(true);
        this.render();
    },

    closeEnvMap: function() {
        this.modelManager.updateMaterialsValue('envMap', null);
        this.setRenderStateChanged(true);
        this.render();
    },

    isSupportSSAO: function(){
        if (CLOUD.GlobalData.IncrementRender) {
            return false;
        }
        
        return true;
    },

    isSSAOEnabled: function(){
        return CLOUD.GlobalData.SSAO;
    },

    enableSSAO: function (value) {

        if (this.isSupportSSAO() == false) {
            return false;
        }

        if(CLOUD.GlobalData.SSAO == value)
            return true;

        CLOUD.GlobalData.EnableRenderPass = value;
        CLOUD.GlobalData.SSAO = value;
        this.setRenderStateChanged(true);
        this.render();

        return true;
    },

    switchNewStyleMaterial: function (newStyle) {

        this.modelManager.switchNewStyleMaterial(newStyle);
        this.setRenderStateChanged(true);
        this.render();

    },

    /**
     * 添加带纹理的平面(世界系坐标，Z轴朝上)
     *
     * @param {THREE.Vector3} min - 最小点
     * @param {THREE.Vector3} max - 最大点
     * @param {String} url - 贴图路径
     * @param {Function} callback - 成功回调函数
     * @return {THREE.Mesh} 请自行保存生成的平面, visible属性控制平面是否显示
     */
    addPlane: function (min, max, url, callback) {
        var center = new THREE.Vector3();
        center.addVectors(new THREE.Vector3(min.x, min.y, min.z), new THREE.Vector3(max.x, max.y, max.z));
        center.multiplyScalar(0.5);

        var plane = new THREE.PlaneBufferGeometry(max.x - min.x, max.y - min.y);

        var mesh = new THREE.Mesh(plane, new THREE.MeshBasicMaterial({
            side: THREE.DoubleSide,
            transparent: true,
            depthTest: true
        }));
        //mesh.rotation.x = -Math.PI * 0.5;
        mesh.position.copy(center);
        mesh.renderOrder = 10; // give a higher priority

        var scene = this.getScene();
        var group = scene.getOrCreateObjectGroup(CLOUD.ObjectGroupType.CUSTOMPLANE, {globalSpace: true});
        group.add(mesh);
        mesh.updateMatrixWorld(true);

        var scope = this;
        var loader = new THREE.TextureLoader();
        loader.load(url, function onSuccess(texture) {
            mesh.material.map = texture;
            mesh.material.needsUpdate = true;
            scope.setRenderStateChanged(true);
            callback && callback();
        });

        return mesh;
    },

    /**
     * 移除带纹理的平面
     *
     * @param {THREE.Mesh} plane - 传入使用addPlane函数返回的对象，用于在场景中删除平面
     */
    removePlane: function (plane) {

        var scene = this.getScene();
        var group = scene.getObjectGroup(CLOUD.ObjectGroupType.CUSTOMPLANE);
        if (group) {
            group.remove(plane);
        }
    },

    /**
     * 是否启用纹理贴图
     *
     * @param {Boolean} enable - true 启用，false：禁用
     */
    enableTextureMapping: function (enable) {

        CLOUD.GlobalData.EnableTextureMapping = enable;

        // var needsUpdate = this.modelManager.updateTextureMapping(enable);
        //
        // if (needsUpdate) {
        //     this.render();
        // }
    },

    /**
     * 设置鼠标滚轮方向
     * 默认滚轮方向 - 前滚：相机前进， 后滚：相机回退
     * 反转滚轮方向 - 前滚：相机回退， 后滚：相机前进
     *
     * @param {Boolean} state - 是否反转
     */
    setReverseWheelDirection: function (state) {

        CLOUD.EditorConfig.ReverseWheelDirection = !!state;

    },

    /**
     * 获得鼠标滚轮反转状态
     *
     * @return {Boolean} 反转状态
     */
    getReverseWheelDirection: function () {

        return CLOUD.EditorConfig.ReverseWheelDirection;

    },

    /**
     * 设置移动速度倍率
     *
     * @param {Number} rate - 倍数, 0.25 - x0.25, 是原来的1/4速度, 4.0 - x4.0, 是原来速度的4倍.
     */
    setMovementSpeedRate: function (rate) {

        if (rate === undefined) {
            return;
        }

        CLOUD.EditorConfig.MovementSpeedRate = rate;
    },

    /**
     * 获得移动速度倍率
     *
     * @return {Number} 倍数
     */
    getMovementSpeedRate: function () {

        return CLOUD.EditorConfig.MovementSpeedRate;

    },

    /**
     * 相机移动
     *
     * @param {Number} direction 移动方向 {@link CLOUD.MoveDirection}
     * @param {Number} step 步进大小
     * @param {Boolean} go 是否启动
     */
    moveTo: function (direction, step, go) {

        var editor = this.editorManager.editor;

        // if (editor && editor.slaveEditor) {
        //     editor.slaveEditor.moveTo(direction);
        // }

        if (editor) {
            editor.moveTo(direction, step, go);
        }

    },

    /**
     * 朝指定方向旋转
     *
     * @param {Object} delta 旋转偏移量 ({x: 10, y: 10})
     */
    rotateTo: function (delta) {
        var editor = this.editorManager.editor;
        if (editor) {
            editor.rotateTo(delta);
        }
    },

    /**
     * 是否启用半透明遮挡视线的构件
     *
     * @param {Boolean} enable - true 启用，false：禁用
     */
    enableOcclusionTranslucent: function (enable) {
        CLOUD.GlobalData.OcclusionTranslucentEnabled = !!enable;
    },

    /**
     * 设置遮挡视线的构件的不透明度
     *
     * @param {Number} opacity - 不透明度
     */
    setOcclusionOpacity: function (opacity) {
        CLOUD.GlobalData.OcclusionOpacity = opacity;
    },

    /**
     * 设置遮挡视线的构件的距离阈值，超过该阈值，则半透明遮挡物
     *
     * @param {Number} distance - 距离阈值
     */
    setOcclusionDistanceToCamera: function (distance) {
        CLOUD.GlobalData.OcclusionDistanceToCamera = distance;
    },

    /**
     * 根据选中的构件进行fit及绕其旋转
     *
     */
    fitAndRotateBySelection: function () {

        if (this.cameraControl) {
            this.cameraControl.fitAndRotateBySelection();
        }

    },

    /**
     * 设置漫游行走时相机的高度
     *
     * @param {Array} elevations - 参考标高数组（从小到大的排序）
     * @param {Number} height - 相机相对高度(世界系中的高度 > 0，默认 1750mm)
     * @param {Boolean} forceRender - 强制刷新, 默认强制刷新
     */
    setRoamingWalkHeight: function (elevations, height, forceRender) {

        if (!(elevations instanceof Array)) {

            console.log("elevations is not arry");
            return;

        }

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return false;
        }

        if (height <= 0) {
            height = 1750;
        }

        if (forceRender === undefined) {
            forceRender = true;
        }

        cameraControl.setCameraHeight(elevations, height);

        if (forceRender) {

            var editor = this.editorManager.getCurrentEditor();

            if (editor && (editor.name === CLOUD.EditorMode.WALK) && editor.update) {
                cameraControl.flyOnWorld();
            }
        }

    },

    /**
     * 设置漫游行走时相机的绝对高度
     *
     * @param {Number} height - 相机绝对高度(世界系中的高度)
     * @param {Boolean} forceRender - 强制刷新, 默认强制刷新
     */
    setRoamingWalkAbsoluteHeight: function (height, forceRender) {

        var cameraControl = this.cameraControl;

        if (!cameraControl) {
            console.log("camera is not initialized!!!");
            return false;
        }

        if (forceRender === undefined) {
            forceRender = true;
        }

        cameraControl.setCameraAbsoluteHeight(height);

        if (forceRender) {

            var editor = this.editorManager.getCurrentEditor();

            if (editor && (editor.name === CLOUD.EditorMode.WALK) && editor.update) {
                cameraControl.flyOnWorld();
            }
        }

    },

    /**
     * 将相机从绘图坐标系转换到世界坐标系
     *
     * @returns {Object} - 世界系中相机位置 {position:xxx, target:xxx, up:xxx}
     */
    cameraToWorld: function (cameraInfo) {

        if (this.camera) {

            return CLOUD.Camera.drawingToWorld(cameraInfo, this.getScene().getMatrixGlobal());

        }

        return null;

    },

    /**
     * 将相机从世界坐标系转换到绘图坐标系
     *
     * @returns {Object} - 绘图坐标系中相机位置 {position:xxx, target:xxx, up:xxx}
     */
    cameraToDrawing: function (cameraInfo) {

        if (this.camera) {

            return CLOUD.Camera.worldToDrawing(cameraInfo, this.getScene().getMatrixGlobal());

        }

        return null;

    },

    /*=====================  API for selection Begin =======================*/

    /**
     * Clear all selected object to unselected state.
     *
     * If the selection object list of the scene is changed, ON_SELECTION_CHANGED event is triggered.
     */
    clearSelection: function() {
        this.modelManager.sceneState.clearSelection();
    },

    /**
     * Add objects to selection list of the scene. These object will be selected.
     * If the selection object list of the scene is changed, ON_SELECTION_CHANGED event is triggered.
     *
     * @param {Array} objIdList - Object Ids.
     *
     */
    addToSelection: function(objIdList) {
        this.modelManager.sceneState.addSelection(objIdList);
    },

    /**
     * Remove objects from selection list of the scene. These object will be unselected.
     * If the selection object list of the scene is changed, ON_SELECTION_CHANGED event is triggered.
     *
     * @param {Array} objIdList - Object Ids.
     *
     */
    removeFromSelection: function(objIdList) {
        this.modelManager.sceneState.removeSelection(objIdList);
    },

    /**
     * Replace selection list of the scene with the object Id list. These object will be selected.
     * If the selection object list of the scene is changed, ON_SELECTION_CHANGED event is triggered.
     *
     * @param {Array} objIdList - Object Ids.
     *
     */
    setSelection: function(objIdList) {
        this.modelManager.sceneState.setSelection(objIdList);
    },

    /**
     * Add objects to selection list of the scene. These object will be selected.
     * If the selection object list of the scene is changed, ON_SELECTION_CHANGED event is triggered.
     *
     * @returns {Array} Selected object Ids.
     */
    getSelection: function() {
        return this.modelManager.sceneState.getSelection();
    },

    /**
     * Set override material color for selected object.
     *
     * @param color {Integer} - color value, for example: 0xffffff
     */
    setSelectionColor: function(color) {
        this.modelManager.sceneState.setSelectionColor(color);
    },

    /*=====================  API for selection End =======================*/

    /**
     * 根据客户坐标点，模拟点击操作得到选中构件，返回选中信息,包括：
     *  meshId ：选中构件的Id
     *  worldPosition : 选中构件被选中的点的世界坐标
     *  worldBoundingBox : 选中构件的包围盒
     *  faceIndex : 选中构件被选中的面
     *
     *
     * @param {Object} point - 客户坐标点({x:0, y: 0})
     * @returns {Object} - 选中构件信息,如果没有构件选中，返回null
     */
    pickByPoint: function (point) {

        var cameraControl = this.cameraControl;

        if (cameraControl.enabled === false)
            return false;

        var clientPos = new THREE.Vector2(point.x, point.y);
        var pickContext = cameraControl.getIntersectContext(clientPos);

        var intersect = cameraControl.intersector.pick(pickContext);

        var scene = this.getScene();

        if (intersect) {
            // 将位置和包围转换到世界系
            scene.intersectToWorld(intersect);

            var pickInfo = {};
            pickInfo["faceIndex"] = intersect.faceIndex;
            pickInfo["meshId"] = intersect.userId;
            pickInfo["worldPosition"] = intersect.worldPosition;
            pickInfo["worldBoundingBox"] = intersect.worldBoundingBox;

            return pickInfo;
        }

        return null;
    },

    /**
     * 沿选中构件点所在的三角面对应的法线方向求两个pick点
     *
     * @param {Object} point - 客户坐标点({x:0, y: 0})
     * @returns {Array} 构件对象数组或者null
     */
    pickByPointWithNormal: function (point) {

        var scene = this.getScene();
        var cameraControl = this.cameraControl;

        if (cameraControl.enabled === false) {
            return null;
        }

        var clientPos = new THREE.Vector2(point.x, point.y);
        var pickContext = cameraControl.getIntersectContext(clientPos);
        var intersect = cameraControl.intersector.pick(pickContext);

        if (!intersect) {
            return null;
        }

        // 将位置和包围转换到世界系
        scene.intersectToWorld(intersect);

        intersect.cx = clientPos.x;
        intersect.cy = clientPos.y;

        var intersects = [];
        intersects.push(intersect);

        // 计算第二个构件
        var sceneMatrix = scene.getMatrixGlobal();
        var direction = intersect.face.normal.clone();
        var origin = intersect.worldPosition.clone();
        var ray = new THREE.Ray(origin, direction);

        ray.applyMatrix4(sceneMatrix);

        var intersectEnd = cameraControl.intersector.getIntersectByRay(pickContext, ray);

        if (intersectEnd) {
            // 将位置和包围转换到世界系
            scene.intersectToWorld(intersectEnd);
            intersects.push(intersectEnd);
        }

        return intersects;
    },

    /**
     * 切换到正交投影相机
     *
     * @param {Boolean} refresh - 是否需要刷新场景, 默认刷新
     */
    toDefaultOrthographicCamera: function (refresh) {

        this.switchToCamera("orth");

        if (refresh || refresh === undefined) {
            this.render();
        }

    },

    /**
     * 切换到透视投影相机
     *
     * @param {Boolean} refresh - 是否需要刷新场景, 默认刷新
     */
    toDefaultPerspectiveCamera: function (refresh) {

        this.switchToCamera("persp");

        if (refresh || refresh === undefined) {
            this.render();
        }

    },

    /**
     * get camera (default and customized) name list
     *
     */
    getCameraNameList : function() {
        var defaultList = ["pesp", "orth"];

        return defaultList.concat(this.modelManager.getCameraNameList());
    },

    switchToCamera : function(cameraName) {
        var found = true;

        if (cameraName === "persp") {
            this.camera = this.defaultCamera;
            this.camera.toPerspective();
        }
        else if (cameraName === "orth") {
            this.camera = this.defaultCamera;
            this.camera.toOrthographic();
        }
        else {
            var camera = this.modelManager.getCamera(cameraName);
            if (camera) {
                this.camera = camera;
            }
            else {
                console.log("Fail to switch because not found camera '" + cameraName + "'");
                found = false;
            }
        }

        if (found) {
            this.cameraControl.setCamera(this.camera)
        }

        return found;
    },

    /**
     * Return the number of elements of all loaded models
     */
    getNumOfElements: function() {
        return this.modelManager.getNumOfElements();
    },
    /**
     * Return the number of renderables of all loaded models
     */
    getNumOfRenderables: function() {
        return this.modelManager.getNumOfRenderables();
    },
    /**
     * Return the number of triangles of all loaded models
     */
    getNumOfTriangles: function() {
        return this.modelManager.getNumOfTriangles();
    },

    setLightPreset: function (value) {

        CLOUD.GlobalData.LightPreset = value;
        this.getScene().lightPreset();
        this.setRenderStateChanged(true);

    },

    getLightPreset: function () {
        return CLOUD.GlobalData.LightPreset;
    },

    setAmbientLightIntensity: function (value) {
        var ambientLight = this.getScene().ambientLight;
        if (ambientLight) {
            ambientLight.intensity = value;
            this.setRenderStateChanged(true);
        }
    },

    getAmbientLightIntensity: function () {
        var ambientLight = this.getScene().ambientLight;
        if (ambientLight) {
            return ambientLight.intensity;
        }
        else {
            return undefined;
        }
    },

    /**
     * 锁定行走高度
     *
     * @param {Boolean} lock - 是否锁定
     */
    setWalkHeightLocked : function (lock) {

        var editor = this.editorManager.getCurrentEditor();

        if (editor && (editor.name === CLOUD.EditorMode.WALK)) {
            editor.setHeightLocked(lock);
        }

    },

    /**
     * 鼠标按下行走观察
     *
     * @param {Boolean} press - 是否按下
     */
    setWalkLookMousePressed: function (press) {

        var editor = this.editorManager.getCurrentEditor();

        if (editor && (editor.name === CLOUD.EditorMode.WALK)) {
            editor.setDragLook(press);
        }

    },

    /**
     * 设置行走倍率
     *
     * @param {Number} rate - 倍率
     */
    setWalkSpeedRate : function (rate) {

        var editor = this.editorManager.getCurrentEditor();

        if (editor && (editor.name === CLOUD.EditorMode.WALK)) {
            // editor.setSpeedRate(rate);
            CLOUD.EditorConfig.WalkSpeedRate = rate;
        }
    },

    /**
     * 设置绘制风格
     *
     * @param {Number} style - CLOUD.DrawingStyle.SHADING：模型绘制风格
                             CLOUD.DrawingStyle.BOARDLINE：线框绘制风格
                             CLOUD.DrawingStyle.SHADINGWITHLINE： 带线框的模型绘制风格
     */
    setDrawingStyle: function(style) {
        CLOUD.GlobalData.DrawingStyle = style;
        this.setRenderStateChanged(true);
    },

    /**
     * 设置线框颜色
     *
     * @param {Object} color - 默认为 0x000000;
     */
    setWireframeColor: function(color, opacity) {

        var modelManager = this.modelManager;
        for (var name in modelManager.models) {
            modelManager.models[name].wireframeMaterial.color = new THREE.Color(color);
            modelManager.models[name].wireframeMaterial.opacity = opacity;
            modelManager.models[name].wireframeMaterial.transparent = opacity == 1.0 ? false : true;

            modelManager.models[name].instanceWireframeMaterial.color = new THREE.Color(color);
            modelManager.models[name].instanceWireframeMaterial.opacity = opacity;
            modelManager.models[name].instanceWireframeMaterial.transparent = opacity == 1.0 ? false : true;
        }

        this.setRenderStateChanged(true);

    },

    setInstanceMode: function (flag) {

        if (!CLOUD.GlobalData.Instance === flag) {

            CLOUD.GlobalData.Instance = flag;
            if (flag) {

                var instanceGeometryGroup = this.getScene().getOrCreateObjectGroup(CLOUD.ObjectGroupType.INSTANCEGEOMETRY, {globalSpace: true});
                instanceGeometryGroup.visible = true;

            }
            else {

                var instanceGeometryGroup = this.getScene().getOrCreateObjectGroup(CLOUD.ObjectGroupType.INSTANCEGEOMETRY, {globalSpace: true});
                instanceGeometryGroup.visible = false;

            }

            this.setRenderStateChanged(true);

        }

    },

    /**
     * 设置是否启用转场动画
     *
     * @param {Boolean} enable - 是否启动
     */
    setTransitionAnimationState: function (enable) {
        this.transitionAnimationState = enable;
    },

    /**
     * 返回是否启用转场动画的状态
     *
     */
    getTransitionAnimationState: function(){
        return this.transitionAnimationState;
    },

    /**
     * 返回点是否被裁剪
     * @param {Object} point - 判断是否被裁剪的三维点
     */
    clipPoint: function (point) {

        var clipPlanes = this.renderer.clippingPlanes;
        if (clipPlanes && clipPlanes.length > 0){

            for (var i = 0 ; i < clipPlanes.length; ++i) {

                var plane = clipPlanes[i];
                var normal = plane.normal;
                if (point.dot(normal) < -plane.constant) {
                    return true;
                }

            }

        }

        return false;

    },

    /**
     * 设置按需加载条件
     *
     * @param {Array} conditions - 条件对象数组 [{floor: xxx, specialty:xxx},{floor: xxx, specialty:xxx}]
     * @param {Boolean} immediateLoad - 立即加载数据(默认 true)
     * @param {Function} progressCallback(doingCount, itemCount) - 数据加载过程中的回调
     * @param {Function} finishCallback() -  数据加载完成后的回调
     */
    setConditionsOnDemandLoad: function (conditions, immediateLoad, progressCallback, finishCallback) {
        immediateLoad = immediateLoad || true;
        this.modelManager.setConditionsOnDemandLoad(conditions);
        if(immediateLoad){
            this.modelManager.loadMpkOnDemand(progressCallback, finishCallback);
        }
    },

    /**
     * 按需加载mpk
     *
     * @param {Array} conditions - 条件对象数组 [{floor: xxx, specialty:xxx},{floor: xxx, specialty:xxx}]
     * @param {Function} progressCallback(doingCount, itemCount) - 数据加载过程中的回调
     * @param {Function} finishCallback() -  数据加载完成后的回调
     */
    loadMpkOnDemand: function (conditions, progressCallback, finishCallback) {
        this.modelManager.setConditionsOnDemandLoad(conditions);
        this.modelManager.loadMpkOnDemand(progressCallback, finishCallback);
    },

    /**
     * 获得按需加载包围盒
     *
     * @returns {THREE.Box3}
     */
    getBoundingBoxOnDemand: function () {
        return this.modelManager.getBoundingBoxOnDemand();
    },

    /**
     * 设置曝光
     *
     * @param {Number} shift - 取值范围[-1, 1]
     */
    setExposureShift: function (value) {

        CLOUD.GlobalData.ToneMapping = 1;
        // maping shift from [-1, 0] to [4.5, 0.5], [0,1] to [0.5, 0.1]
        var shift = (value > 0) ? (-0.4 * value + 0.5) : (-4 * value + 0.5);
        this.modelManager.updateMaterialsValue('shift', shift);
        this.setRenderStateChanged(true);
    },

    setRenderStateChanged: function (change) {
        this._renderStateChanged = change;
    },

    isRenderStateChanged: function () {
        return this._renderStateChanged;
    },

    isDesktop:function() {
        var ua = navigator.userAgent,
            isWindowsPhone = /(?:Windows Phone)/.test(ua),
            isSymbian = /(?:SymbianOS)/.test(ua) || isWindowsPhone,
            isAndroid = /(?:Android)/.test(ua),
            isFireFox = /(?:Firefox)/.test(ua),
            isChrome = /(?:Chrome|CriOS)/.test(ua),
            isTablet = /(?:iPad|PlayBook)/.test(ua) || (isAndroid && !/(?:Mobile)/.test(ua)) || (isFireFox && /(?:Tablet)/.test(ua)),
            isPhone = /(?:iPhone)/.test(ua) && !isTablet,
            isPc = !isPhone && !isAndroid && !isSymbian && !isTablet;
        return isPc;
    },

    getComponentInfoByUserId: function (uid) {
        var nodeInfos = this.modelManager.getNodeInfosByUserId(uid);
        if (nodeInfos && nodeInfos.length > 0) {
            var box = new THREE.Box3();
            var materials = [];
            for (var i = 0, len = nodeInfos.length; i < len; i++) {
                box.union(nodeInfos[i].boundingBox);
                if (materials.indexOf(nodeInfos[i].materialId) === -1) {
                    materials.push(nodeInfos[i].materialId);
                }
            }
            return {
                userId: uid,
                state: 0,
                materials: materials,
                boundingBox: box,
                userData: nodeInfos[0].userData
            };
        }
        return null;
    },

    getBoundingBoxByIds: function (ids) {

        if (CLOUD.GlobalData.BatchMergeEnabled) {
            var box = new THREE.Box3();
            for (var id in ids) {
                if (this.modelManager.isHiddenUserId(id)) {
                    continue;
                }
                var nodeInfo = this.getComponentInfoByUserId(id);
                if (nodeInfo) {
                    box.union(nodeInfo.boundingBox);
                }
            }
            if (!box.isEmpty()) {
                box.applyMatrix4(this.getScene().getMatrixGlobal());
            }
            return box;
        }

        return this.getScene().getBoundingBoxOfGeometries(ids);
    },

    // getComponentInfoByUserId: function (uid) {
    //     var nodeInfo = this.modelManager.getNodeInfosByUserId(uid);
    //     if (nodeInfo) {
    //         return {
    //             userId: nodeInfo.userId,
    //             boundingBox: nodeInfo.boundingBox,
    //             userData: nodeInfo.userData,
    //             state: nodeInfo.state,
    //             material:nodeInfo.material
    //         };
    //     }
    //     return null;
    // },


    /**
     * 将老版本批注信息转换成V3版
     *
     * @param {String} jsonStr - 批注信息字符串表示
     */
    convertAnnotationsToV3: function (jsonStr) {

        var jsonObj = JSON.parse(jsonStr);

        function convertCamera(camera, matrixTransform, matrixScene) {

            var newCamera;

            if ("string" === typeof camera) {
                newCamera = JSON.parse(window.atob(camera));
            } else {
                newCamera = {
                    position: {x: camera.position.x, y: camera.position.y, z: camera.position.z},
                    target: {x: camera.target.x, y: camera.target.y, z: camera.target.z},
                    up: {x: camera.up.x, y: camera.up.y, z: camera.up.z}
                };
            }

            var position = new THREE.Vector3(newCamera.position.x, newCamera.position.y, newCamera.position.z);
            var target = new THREE.Vector3(newCamera.target.x, newCamera.target.y, newCamera.target.z);
            var up = new THREE.Vector3(newCamera.up.x, newCamera.up.y, newCamera.up.z);

            // CameraInfo结构变化，需要name参数
            var cameraInfo = new CLOUD.CameraInfo("persp",position, target, up);
            cameraInfo = CLOUD.Camera.drawingToWorld(cameraInfo, matrixTransform);
            cameraInfo = new CLOUD.CameraInfo("persp",cameraInfo.position, cameraInfo.target, cameraInfo.up);
            cameraInfo = CLOUD.Camera.worldToDrawing(cameraInfo, matrixScene);

            newCamera.position.x = cameraInfo.position.x;
            newCamera.position.y = cameraInfo.position.y;
            newCamera.position.z = cameraInfo.position.z;

            newCamera.target.x = cameraInfo.target.x;
            newCamera.target.y = cameraInfo.target.y;
            newCamera.target.z = cameraInfo.target.z;

            newCamera.up.x = cameraInfo.up.x;
            newCamera.up.y = cameraInfo.up.y;
            newCamera.up.z = cameraInfo.up.z;

            if ("string" === typeof camera) {
                newCamera = window.btoa(JSON.stringify(newCamera));
            }

            return newCamera;

        }

        // 只能根据过滤器中的标志来判断版本信息
        if (jsonObj.filter) {

            var jsonFilter = JSON.parse(jsonObj.filter);

            if (jsonFilter.filter || jsonFilter.basicIds) {

                var scene = this.getScene();
                var matrixTransform = scene.getTransformMatrixGlobal();
                var matrixTransformInv = new THREE.Matrix4();
                matrixTransformInv.getInverse(matrixTransform);

                var matrixScene = scene.getMatrixGlobal();
                var matrixSceneInv = new THREE.Matrix4();
                matrixSceneInv.getInverse(matrixScene);

                // camera 不做变换，批注使用保存的camera信息，否则批注对象的转换相当复杂而且容易出错
                // json.camera = convertCamera(json.camera, matrixTransform, matrixScene);

                // 处理批注
                // if (json.obj) {
                //
                //     var annotationInfoList = json.obj;
                //
                //     for (var i = 0, len = annotationInfoList.length; i < len; i++) {
                //
                //         var info = annotationInfoList[i];
                //         var newPosition = new THREE.Vector3(info.position.x, info.position.y, info.position.z);
                //         newPosition.applyMatrix4(matrixTransformInv).applyMatrix4(matrixScene);
                //
                //         var lt = new THREE.Vector3(info.position.x - 0.5 * info.size.width, info.position.y - 0.5 * info.size.height, info.position.z);
                //         var rb = new THREE.Vector3(info.position.x + 0.5 * info.size.width, info.position.y + 0.5 * info.size.height, info.position.z);
                //         lt.applyMatrix4(matrixTransformInv).applyMatrix4(matrixScene);
                //         rb.applyMatrix4(matrixTransformInv).applyMatrix4(matrixScene);
                //
                //         info.position.x = newPosition.x;
                //         info.position.y = newPosition.y;
                //         info.position.z = newPosition.z;
                //
                //         info.size.width = Math.abs(rb.x - lt.x);
                //         info.size.height = Math.abs(rb.y - lt.y);
                //
                //         if (info.originSize) {
                //
                //             var ltOrigin = new THREE.Vector3(info.position.x - 0.5 * info.originSize.width, info.position.y - 0.5 * info.originSize.height, info.position.z);
                //             var rbOrigin = new THREE.Vector3(info.position.x + 0.5 * info.originSize.width, info.position.y + 0.5 * info.originSize.height, info.position.z);
                //
                //             ltOrigin.applyMatrix4(matrixTransformInv).applyMatrix4(matrixScene);
                //             rbOrigin.applyMatrix4(matrixTransformInv).applyMatrix4(matrixScene);
                //
                //             info.originSize.width = Math.abs(rbOrigin.x - ltOrigin.x);
                //             info.originSize.height = Math.abs(rbOrigin.y - ltOrigin.y);
                //         }
                //
                //     }
                //
                // }

                var enumFilterType = this.getFilter().getFilterType();
                var objFilter = {};
                objFilter.state = {};

                // v1 - > v3
                if (jsonFilter.filter) {

                    if (jsonFilter.fileFilter) {
                        objFilter.state[enumFilterType.FILE_HIDDEN] = jsonFilter.fileFilter;
                    }

                    if (jsonFilter.selectionSet) {
                        objFilter.state[enumFilterType.SELECTED] = jsonFilter.selectionSet;
                    }

                    if (jsonFilter.filter.visibleIds) {
                        objFilter.state[enumFilterType.VISIBLE] = jsonFilter.filter.visibleIds;
                    }

                    if (jsonFilter.filter.invisibleIds) {
                        objFilter.state[enumFilterType.HIDDEN] = jsonFilter.filter.invisibleIds;
                    }

                    if (jsonFilter.filter.conditions) {
                        objFilter.state[enumFilterType.CONDITION_HIDDEN_OTHERS] = jsonFilter.filter.conditions;
                    }

                    if (jsonFilter.filter.filters) {
                        objFilter.state[enumFilterType.USER_HIDDEN] = jsonFilter.filter.filters;
                    }

                    if (jsonFilter.frozenSet) {
                        objFilter.state[enumFilterType.FROZENFILTER] = jsonFilter.frozenSet;
                    }

                    if (jsonFilter.isolateSet) {
                        objFilter.state[enumFilterType.ISOLATE_HIDDEN_OTHERS] = jsonFilter.isolateSet;
                    }

                    if (jsonFilter.overriderByIds) {
                        objFilter.state[enumFilterType.OVERRIDEFILTER] = jsonFilter.overriderByIds;
                    }

                    if (jsonFilter.overriderByData) {
                        objFilter.state[enumFilterType.USER_OVERRIDE] = jsonFilter.overriderByData;
                    }

                    if (jsonFilter.overriderCondition) {
                        objFilter.state[enumFilterType.CONDITION_OVERRIDE] = jsonFilter.overriderCondition;
                    }

                    if (jsonFilter.isolateCondition) {
                        objFilter.state[enumFilterType.ISOLATE_CONDITION_HIDDEN_OTHERS] = jsonFilter.isolateCondition;
                    }

                    objFilter.state.sceneState = jsonFilter.overriderByScene;

                }
                else if (jsonFilter.basicIds) {// v2 - > v3

                    if (jsonFilter.basicIds[1]) {
                        objFilter.state[enumFilterType.FILE_HIDDEN] = jsonFilter.basicIds[1];
                    }

                    if (jsonFilter.basicIds[2]) {
                        objFilter.state[enumFilterType.SELECTED] = jsonFilter.basicIds[2];
                    }

                    if (jsonFilter.basicIds[3]) {
                        objFilter.state[enumFilterType.VISIBLE] = jsonFilter.basicIds[3];
                    }

                    if (jsonFilter.basicIds[4]) {
                        objFilter.state[enumFilterType.HIDDEN] = jsonFilter.basicIds[4];
                    }

                    if (jsonFilter.conditions[0]) {
                        objFilter.state[enumFilterType.CONDITION_HIDDEN_OTHERS] = jsonFilter.conditions[0];
                    }

                    if (jsonFilter.userHiddenIds) {
                        objFilter.state[enumFilterType.USER_HIDDEN] = jsonFilter.userHiddenIds;
                    }

                    if (jsonFilter.frozenIds) {
                        objFilter.state[enumFilterType.FROZENFILTER] = jsonFilter.frozenIds;
                    }

                    if (jsonFilter.isolateIds) {
                        objFilter.state[enumFilterType.ISOLATE_HIDDEN_OTHERS] = jsonFilter.isolateIds;
                    }

                    if (jsonFilter.overrideByIds) {
                        objFilter.state[enumFilterType.OVERRIDEFILTER] = jsonFilter.overrideByIds;
                    }

                    if (jsonFilter.overrideByData) {
                        objFilter.state[enumFilterType.USER_OVERRIDE] = jsonFilter.overrideByData;
                    }

                    if (jsonFilter.conditions[2]) {
                        objFilter.state[enumFilterType.CONDITION_OVERRIDE] = jsonFilter.conditions[2];
                    }

                    if (jsonFilter.isolateConditions) {

                        if (jsonFilter.isolateConditions[0]) {
                            objFilter.state[enumFilterType.ISOLATE_CONDITION_HIDDEN] = jsonFilter.isolateConditions[0];
                        }

                        if (jsonFilter.isolateConditions[1]) {
                            objFilter.state[enumFilterType.ISOLATE_CONDITION_HIDDEN_OTHERS] = jsonFilter.isolateConditions[1];
                        }

                        if (jsonFilter.isolateConditions[2]) {
                            objFilter.state[enumFilterType.ISOLATE_CONDITION_TRANSLUCENT] = jsonFilter.isolateConditions[2];
                        }

                        if (jsonFilter.isolateConditions[3]) {
                            objFilter.state[enumFilterType.ISOLATE_CONDITION_TRANSLUCENT_OTHERS] = jsonFilter.isolateConditions[3];
                        }
                    }

                    objFilter.state.sceneState = jsonFilter.sceneState;
                }

                if (jsonFilter.camera) {
                    objFilter.camera = convertCamera(jsonFilter.camera, matrixTransform, matrixScene);
                } else {
                    objFilter.camera = convertCamera(jsonObj.camera, matrixTransform, matrixScene);
                }

                jsonFilter = objFilter;

                jsonObj.filter = JSON.stringify(jsonFilter);

            }

        }

        return jsonObj;
    }
};
