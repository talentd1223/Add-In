//CLOUD.CombinedCamera = function (width, height, fov, near, far) {
CLOUD.CombinedCamera = function (type, params) {

    THREE.Camera.call(this);

    this.target = new THREE.Vector3();

    this.name = params.name || "";
    this.near = params.near;
    this.far = params.far;

    if (type === CLOUD.CAMERATYPE.PERSPECTIVE) {

        this.aspect = params.width / params.height;
        this.fov = params.fov;

        this.left = -params.width / 2;
        this.right = params.width / 2;
        this.top = params.height / 2;
        this.bottom = -params.height / 2;

        this.perspectiveCamera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far);
        this.orthoCamera = null;

        this.toPerspective();
    }
    else {
        this.left = params.left;
        this.right = params.right;
        this.top = params.top;
        this.bottom = params.bottom;
        this.fov = 45;
        this.aspect = (this.right - this.left) / (this.top - this.bottom);

        this.orthoCamera = new THREE.OrthographicCamera(this.left, this.right, this.top, this.bottom, this.near, this.far);
        this.perspectiveCamera = null;

        this.orthoCamera.updateProjectionMatrix();
        this.projectionMatrix = this.orthoCamera.projectionMatrix;
        this.isPerspective = false;
    }

    this.zoom = params.zoom || 1;

};

CLOUD.CombinedCamera.prototype = Object.create(THREE.Camera.prototype);
CLOUD.CombinedCamera.prototype.constructor = CLOUD.CombinedCamera;

CLOUD.CombinedCamera.prototype.toPerspective = function () {

    if (this.perspectiveCamera === null) {
        Console.log("Can not convert to perspective camera because the camera original type is orthographic.");
        return;
    }

    this.perspectiveCamera.aspect = this.aspect;
    this.perspectiveCamera.near = this.near;
    this.perspectiveCamera.far = this.far;
    // this.perspectiveCamera.fov = this.fov / this.zoom;
    this.perspectiveCamera.fov = this.fov;
    this.perspectiveCamera.updateProjectionMatrix();
    this.projectionMatrix = this.perspectiveCamera.projectionMatrix;
    this.isPerspective = true;
    this.dirty = true;
};

// TODO: toOrthographic() and toPerspective() is always called when setNearFar()
//        because we support user cameras which do not support to swith the orthographic/perspective mode,
//        we should not use the combined camera to represent them. Refactor the camera class.
//
CLOUD.CombinedCamera.prototype.toOrthographic = function () {

    if (this.orthoCamera === null) {
        this.orthoCamera = new THREE.OrthographicCamera(this.left, this.right, this.top, this.bottom, this.near, this.far);
    }

    var fov = this.fov;

    // near,far会变化，position和target距离大部分情况下不会发生变化（zoomToBox调用下会变）
    // var hyperFocus = ( this.near + this.far ) / 2;
    var hyperFocus = this.target.clone().sub(this.position).length();
    var halfHeight = Math.tan(fov * Math.PI / 180 / 2) * hyperFocus;
    var halfWidth = halfHeight * this.aspect;

    halfHeight /= this.zoom;
    halfWidth /= this.zoom;

    this.left = this.orthoCamera.left = -halfWidth;
    this.right = this.orthoCamera.right = halfWidth;
    this.top = this.orthoCamera.top = halfHeight;
    this.bottom = this.orthoCamera.bottom = -halfHeight;

    this.orthoCamera.near = this.near;
    this.orthoCamera.far = this.far;
    this.orthoCamera.updateProjectionMatrix();
    this.projectionMatrix = this.orthoCamera.projectionMatrix;
    this.isPerspective = false;
    this.dirty = true;
};


CLOUD.CombinedCamera.prototype.setSize = function (width, height) {

    this.left = -width / 2;
    this.right = width / 2;
    this.top = height / 2;
    this.bottom = -height / 2;
    this.aspect = width / height;
    this.dirty = true;
};

CLOUD.CombinedCamera.prototype.setFov = function (fov) {

    this.fov = fov;
    this.dirty = true;
    this.updateProjectionMatrix();

};

CLOUD.CombinedCamera.prototype.setNearFar = function (near, far) {

    this.near = near;
    this.far = far;
    this.dirty = true;
    this.updateProjectionMatrix();

};

// For mantaining similar API with PerspectiveCamera
CLOUD.CombinedCamera.prototype.updateProjectionMatrix = function () {

    if (this.isPerspective) {

        this.toPerspective();

    } else {

        this.toOrthographic();

    }

};

/*
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (fullframe) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */
CLOUD.CombinedCamera.prototype.setLens = function (focalLength, frameHeight) {

    if (frameHeight === undefined) frameHeight = 24;

    var fov = 2 * THREE.Math.radToDeg(Math.atan(frameHeight / ( focalLength * 2 )));

    this.setFov(fov);
    this.dirty = true;
    return fov;
};


CLOUD.CombinedCamera.prototype.setZoom = function (zoom) {

    this.zoom = zoom;
    this.dirty = true;
    this.updateProjectionMatrix();

};

CLOUD.CombinedCamera.prototype.copy = function (source) {

    THREE.Camera.prototype.copy.call( this, source );

    this.target.copy(source.target);

    this.aspect = source.aspect;
    this.fov = source.fov;
    this.near = source.near;
    this.far = source.far;

    this.left =source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;

    this.zoom = source.zoom;
    this.isPerspective = source.isPerspective;

    this.orthoCamera.copy(source.orthoCamera);
    this.perspectiveCamera.copy(source.perspectiveCamera);

};