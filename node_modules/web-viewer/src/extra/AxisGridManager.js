class AxisGridManager extends CLOUD.ObjectGroup{

	constructor(){
		super(CLOUD.ObjectGroupType.AXISGRIDMANAGER, {priority: 20});
		this.globalSpace = true;
		this.materialMap = {};
	}
	
	addLinesNode(linesBuffer, material){
		var bufferGeometry = new THREE.BufferGeometry();
		bufferGeometry.addAttribute('position',new THREE.Float32BufferAttribute(linesBuffer, 3));

		var mesh = new THREE.Line(bufferGeometry, material);
		mesh.renderOrder = -1;
		this.add(mesh);

		this.updateMatrixWorld(true);
	}

	addTrianglesNode(bufferData, material){
		var bufferGeometry = new THREE.BufferGeometry();
		bufferGeometry.setIndex(bufferData.indexArray);
		bufferGeometry.addAttribute('position',new THREE.Float32BufferAttribute(bufferData.vertexArray, 3));
		bufferGeometry.addAttribute('normal', new THREE.Float32BufferAttribute(bufferData.normalArray, 3));

		var mesh= new THREE.Mesh(bufferGeometry, material);
		mesh.renderOrder = -1;
		this.add(mesh);

		this.updateMatrixWorld(true);
	}

	createMaterial(materialParameter){
		if(this.materialMap[materialParameter.color]){
			return  this.materialMap[materialParameter.color];
		}
		this.materialMap[materialParameter.color] = CLOUD.MaterialUtil.createStandardMaterial(materialParameter);
		return this.materialMap[materialParameter.color];
	}
	
	loadAxisGrid(axisGridPath,gridIndex,loadFinishedCallback){
		var self = this;
		var loader = new THREE.FileLoader();

		loader.load(axisGridPath,function (text) {
			var gridsJson = JSON.parse(text);
			var gridIdx = 0;

			//add grid
			if(gridIndex&&gridIndex>=0){
				if(gridIndex<gridsJson.grids.length){
					gridIdx = gridIndex;
				}
				else{
					console.log("Input grid index is invalid.");
					return;
				}
			}
			var gridlines = gridsJson.grids[gridIdx].gridLines;
			for(var i = 0;i<gridlines.length;++i){
				var lineSegments = gridlines[i].lines;
				var lineColor = gridlines[i].color&0xFFFFFF;

				var material = self.createMaterial({color:lineColor, side: THREE.DoubleSide} );
				var linesBuffer = self.prepareLinesBuffer(lineSegments);
				self.addLinesNode(linesBuffer,material);
			}

			//add texts
			var texts = gridsJson.grids[gridIdx].texts;
			for(var j = 0; j < texts.length; ++j) {
				var text = texts[j];
				var textColor = text.color&0xFFFFFF;

				var material = self.createMaterial({color:textColor, side: THREE.DoubleSide} );
				var bufferData = self.prepareTrianglesBuffer(text.indexs,text.vertexs);
				self.addTrianglesNode(bufferData,material);
			}

			//异步加载完成后执行callback
			loadFinishedCallback&&loadFinishedCallback();
		});
	}

	prepareLinesBuffer(lines){
		var lineArray = [];
		for(var i = 0; i < lines.length; ++i) {
			var line = lines[i];
			lineArray.push(line[0], line[1], line[2]);
			lineArray.push(line[3], line[4], line[5]);
		}
		return lineArray;
	}

	prepareTrianglesBuffer(indexs,vertexs){
		var vertexArray = [],normalArray = [];
		for(var i=0;i<vertexs.length;++i){
			var vertex = vertexs[i];
			if(vertex==undefined || vertex[0]==undefined || vertex[1]==undefined || vertex[2]==undefined){
				console.log("Contains invalid vertex.");
				break;
			}
			vertexArray.push(vertex[0],vertex[1],vertex[2]);
			normalArray.push(0,0,1,0,0,1,0,0,1);
		}
		return {"indexArray":indexs,
				"vertexArray":vertexArray,
				"normalArray":normalArray};
	}

}

CLOUD.AxisGridManager = AxisGridManager;
