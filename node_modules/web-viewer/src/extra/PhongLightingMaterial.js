/**
 * Created by liuyt-d on 2017/5/17 0017.
 */

CLOUD.PhongLightingMaterial = function (parameters) {

    THREE.ShaderMaterial.call(this);

    this.type = 'PhoneLightingMaterial';

    this.color = new THREE.Color(0xffffff); // diffuse
    this.specular = new THREE.Color(0x111111);
    this.shininess = 30;
    this.emissive = new THREE.Color(0x000000);

    this.defines = {};
    this.uniforms = THREE.UniformsUtils.merge( [

        THREE.UniformsLib[ "lights" ],
        {
            diffuse: {value: new THREE.Color(0xFF0000)},
            opacity: {value: 1.0},

            specular: { value: new THREE.Color( 0x111111 ) },
            shininess: { value: 30 },
            emissive: { value: new THREE.Color( 0x000000 ) }
        }

    ] );

    this.vertexShader = [
        "varying vec3 vViewPosition;",
        "varying vec3 vNormal;",
        "void main() {",
        "   #include <begin_vertex>",
        "   #include <project_vertex>",
        "   #include <beginnormal_vertex>",
        "   #include <defaultnormal_vertex>",
        "   vNormal = normalize( transformedNormal );",
        "   vViewPosition = - mvPosition.xyz;",
        "}"
    ].join("\n");

    this.fragmentShader = [
        "uniform vec3 diffuse;",
        "uniform float opacity;",
        "uniform vec3 specular;",
        "uniform float shininess;",
        "uniform vec3 emissive;",
        "#include <common>",
        "#include <packing>",
        "#include <bsdfs>",
        "#include <lights_pars>",
        "#include <lights_phong_pars_fragment>",
        "#include <specularmap_pars_fragment>",
        "void main() {",
        "   vec4 diffuseColor = vec4( diffuse, opacity );",
        "   ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
        "   vec3 totalEmissiveRadiance = emissive;",
        "   float specularStrength = 1.0;",
        "   #include <normal_flip>",
        "   #include <normal_fragment>",
        "   #include <lights_phong_fragment>",
        "   #include <lights_template>",
        "   vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;",
        "   gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
        "   #if defined( TONE_MAPPING )",
        "       gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );",
        "   #endif",
        "   gl_FragColor = linearToOutputTexel( gl_FragColor );",
        "}"
    ].join("\n");

    this.lights = true; // set to use scene lights

    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    this.defaultAttributeValues = {
        'color': [1, 1, 1],
        'uv': [0, 0],
        'uv2': [0, 0]
    };

    if (parameters !== undefined) {

        if (parameters.attributes !== undefined) {

            console.error('PhoneLightingMaterial: attributes should now be defined in THREE.BufferGeometry instead.');

        }

        this.setValues(parameters);

    }

    this.refreshUniforms();
}

//CLOUD.PhongLightingMaterial.prototype = new THREE.ShaderMaterial;
CLOUD.PhongLightingMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype);
CLOUD.PhongLightingMaterial.prototype.constructor = CLOUD.PhongLightingMaterial;

CLOUD.PhongLightingMaterial.prototype.isShaderMaterial = true;

CLOUD.PhongLightingMaterial.prototype.copy = function (source) {

    THREE.ShaderMaterial.prototype.copy.call(this, source);

    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.emissive.copy(source.emissive);

    return this;

};

CLOUD.PhongLightingMaterial.prototype.refreshUniforms = function () {
    this.uniforms.diffuse.value.set(this.color);
    this.uniforms.opacity.value = this.opacity;

    this.uniforms.specular.value.set(this.specular);
    this.uniforms.shininess.value = this.shininess;
    this.uniforms.emissive.value.set(this.emissive);
};