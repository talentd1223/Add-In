var cloudStandardVertex = [

    "#define PHYSICAL",
    "varying vec3 vViewPosition;",
    "#ifndef FLAT_SHADED",
        "varying vec3 vNormal;",
    "#endif",

    "#ifdef USE_INSTANCE",
    "   attribute float vState;",
    "   varying float fState;",
    "   attribute vec4 aColor;",
    "   varying vec4 vaColor;",
    "   attribute vec3 mcol0;",
    "   attribute vec3 mcol1;",
    "   attribute vec3 mcol2;",
    "   attribute vec3 mcol3;",
    "   #if defined(USE_MAP) && defined(USE_INSTANCE_MUVCOL)",
    "       attribute vec2 muvCol0;",
    "       attribute vec2 muvCol1;",
    "       attribute vec2 muvCol2;",
    "   #endif",

    "#endif"

].join('\n') +
CLOUD.IdTargetUtil.idVarOfVertexShader() + [

    "#include <common>",
    "#include <uv_pars_vertex>",
    "#include <uv2_pars_vertex>",
    "#include <displacementmap_pars_vertex>",
    "#include <color_pars_vertex>",
    "#include <fog_pars_vertex>",
    "#include <morphtarget_pars_vertex>",
    "#include <skinning_pars_vertex>",
    "#include <shadowmap_pars_vertex>",
    "#include <specularmap_pars_fragment>",
    "#include <logdepthbuf_pars_vertex>",
    "#include <clipping_planes_pars_vertex>",

    "mat3 inverse_mat3(in mat3 m)",
    "{",
    "   float determinant =",
    "    m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])",
    "    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])",
    "    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);",
    "    mat3 inverse;",
    "    inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]);",
    "    inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]);",
    "    inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]);",
    "    inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]);",
    "    inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]);",
    "    inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]);",
    "    inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]);",
    "    inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]);",
    "    inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]);",
    "    inverse /= determinant;",
    "    return inverse;",
    "}",

    "mat3 transpose_mat3( in mat3 m ) {",
    "    mat3 tmp;",
    "    tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );",
    "    tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );",
    "    tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );",
    "    return tmp;",
    "}",
    
    "void main() {",

        "#include <uv_vertex>",
        "#include <uv2_vertex>",
        "#include <color_vertex>",

        "#include <beginnormal_vertex>",
        "#include <morphnormal_vertex>",
        "#include <skinbase_vertex>",
        "#include <skinnormal_vertex>",
        "#include <defaultnormal_vertex>",

        // "#ifndef FLAT_SHADED",
        //     "vNormal = normalize( transformedNormal );",
        // "#endif",

        "#if defined(USE_MAP) && defined(USE_INSTANCE) && defined(USE_INSTANCE_MUVCOL) ",
        "   vUv = vec2(mat3(vec3(muvCol0, 0.0),",
        "                   vec3(muvCol1, 0.0),",
        "                   vec3(muvCol2, 1.0)) * vec3(vUv, 1.0));",
        "#endif",

        "vec3 transformed = vec3( position );",
        "#ifdef USE_INSTANCE",
        "vaColor = aColor;",
        "fState = vState;",
        "transformed = vec3(mat4(vec4(mcol0, 0.0),",
        "                   vec4(mcol1, 0.0),",
        "                   vec4(mcol2, 0.0),",
        "                   vec4(mcol3, 1.0)) * vec4(transformed, 1.0));",

        "#ifdef USE_INSTANCE_NORMAL",
        "    mat3 normalMat = mat3(mcol0, mcol1, mcol2);",
        "    normalMat = inverse_mat3(normalMat);",
        "    normalMat = transpose_mat3(normalMat);",
        "    transformedNormal = normalMat * objectNormal;",
        "    transformedNormal = normalMatrix * transformedNormal;",
        "#ifdef FLIP_SIDED",
        "   transformedNormal = - transformedNormal;",
        "#endif",
        "    transformedNormal = normalize( transformedNormal );",
        "#endif",

        "#endif",

        "#ifndef FLAT_SHADED",
        "vNormal = normalize( transformedNormal );",
        "#endif",

        "#include <displacementmap_vertex>",
        "#include <morphtarget_vertex>",
        "#include <skinning_vertex>",
        "#include <project_vertex>",
        "#include <logdepthbuf_vertex>",
        "#include <clipping_planes_vertex>",

        "vViewPosition = - mvPosition.xyz;",

        "#include <worldpos_vertex>",
        "#include <shadowmap_vertex>",
        "#include <fog_vertex>"

].join('\n') +
CLOUD.IdTargetUtil.passIdInVertexShader() +
    "}";


var cloudStandardFragment = [

    "#define PHYSICAL",

    "uniform vec3 diffuse;",
    "uniform vec3 emissive;",
    "uniform float roughness;",
    "uniform float metalness;",
    "uniform float opacity;",

    "#ifndef STANDARD",
        "uniform float clearCoat;",
        "uniform float clearCoatRoughness;",
    "#endif",

        "varying vec3 vViewPosition;",

    "#ifndef FLAT_SHADED",
        "varying vec3 vNormal;",
    "#endif",

    "#ifdef USE_INSTANCE",
    "   varying vec4 vaColor;",
    "   varying float fState;",
    "#endif",

    "uniform float shift;",
    "uniform float A;",
    "uniform float B;",
    "uniform float C;",
    "uniform float D;",
    "uniform float E;",
    "uniform float F;",
    "uniform float scale;",

    "vec3 toneMapCanonFilmic(vec3 color)",
    "{",
    "    color *= (1.0 / shift);",
    "    return (((color * (A * color + C * B)) / (color * (A * color + B) + D * F))) * (1.0 / scale);",
    "}",

].join('\n') +
CLOUD.IdTargetUtil.idVarOfFragShader() + [

    "#include <common>",
    "#include <packing>",
    "#include <dithering_pars_fragment>",
    "#include <color_pars_fragment>",
    "#include <uv_pars_fragment>",
    "#include <uv2_pars_fragment>",
    "#include <map_pars_fragment>",
    "#include <alphamap_pars_fragment>",
    "#include <aomap_pars_fragment>",
    "#include <lightmap_pars_fragment>",
    "#include <emissivemap_pars_fragment>",
    "#include <envmap_pars_fragment>",
    "#include <fog_pars_fragment>",
    "#include <bsdfs>",
    "#include <cube_uv_reflection_fragment>",
    "#include <lights_pars>",
    "#include <lights_physical_pars_fragment>",
    "#include <shadowmap_pars_fragment>",
    "#include <bumpmap_pars_fragment>",
    "#include <normalmap_pars_fragment>",
    "#include <roughnessmap_pars_fragment>",
    "#include <metalnessmap_pars_fragment>",
    "#include <logdepthbuf_pars_fragment>",
    "#include <clipping_planes_pars_fragment>",

    "void main() {",

        "#include <clipping_planes_fragment>",

        "vec4 diffuseColor = vec4( diffuse, opacity );",
        "#ifdef USE_INSTANCE",
        "   if (fState <= 0.01 && fState >= -0.01) ",
        "       diffuseColor = diffuseColor;",
        "   else if (fState <= -0.99 && fState >= -1.01) ",
        "       discard;",
        "   else",
        "       diffuseColor= vec4(vaColor);",
        "#endif",

        "diffuseColor.rgb = pow(diffuseColor.rgb, vec3(GAMMA_FACTOR));",

        "   #ifdef USE_INSTANCE",
        "       vec4 selectedColor  = diffuseColor ;",
        "   #endif",

        "ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
        "vec3 totalEmissiveRadiance = emissive;",

        "#include <logdepthbuf_fragment>",
        // "#include <map_fragment>",

        "#ifdef USE_MAP",

        "   vec4 texelColor = texture2D( map, vUv );",
        "   texelColor = mapTexelToLinear( texelColor );",
        "   diffuseColor = vec4(texelColor.rgb, opacity);",
        "   #ifdef USE_INSTANCE",
        "       if (fState >= 0.01 || fState <= -0.01) ",//fState!=0;after showAll, it returns its own color. 
        "           diffuseColor.a = vaColor.a;",
        "   #endif",

        "#endif",

        "#include <color_fragment>",
        "#include <alphamap_fragment>",
        "#include <alphatest_fragment>",
        "#include <specularmap_fragment>",
        "#include <roughnessmap_fragment>",
        "#include <metalnessmap_fragment>",
        "#include <normal_flip>",
        "#include <normal_fragment>",
        "#include <emissivemap_fragment>",

        // "#ifdef USE_INSTANCE",
        // "   if (fState <= 0.01 && fState >= -0.01) ",
        // "       diffuseColor = diffuseColor;",
        // "   else if (fState <= -0.99 && fState >= -1.01) ",
        // "       discard;",
        // "   else",
        // "       diffuseColor= vec4(vaColor);",
        // "#endif",

        "#include <lights_physical_fragment>",
        "#include <lights_template>",

        "#include <aomap_fragment>",

        "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;",
        "gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

        "#ifdef USE_INSTANCE",
        "       if (fState <= 2.01 && fState >= 1.99)",//if seleted, all are the same color;
        "           gl_FragColor = selectedColor;",
        "    #ifdef USE_MAP",
        "         if (fState <= 3.01 && fState >= 2.99)",//after transparented, its map should not be kept on
        "             gl_FragColor = vaColor;",
        "    #endif",
        "#endif",

        "#if defined( TONE_MAPPING )",
        "   gl_FragColor.rgb = toneMapCanonFilmic( gl_FragColor.rgb );",
        "#endif",

        // "#include <tonemapping_fragment>",

        "#include <encodings_fragment>",
        "#include <fog_fragment>",
        "#include <premultiplied_alpha_fragment>",
        "#include <dithering_fragment>"

].join('\n') +
    CLOUD.IdTargetUtil.writeIdInFragShader() +
    "}";