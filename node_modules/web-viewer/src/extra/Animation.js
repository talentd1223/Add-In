CLOUD.Animation = function () {

    var _scope = this;
    var _object = null;
    var _valuesStart = {};
    var _valuesEnd = {};
    var _duration = 1000;
    var _startTime = null;
    //var _isPlaying = false;
    var _timerId = null;
    var _tolerance = 0.9995;
    var _interpolationFunction = null;

    var _onStartCallbackFired = false;
    var _onStartCallback = null;
    var _onUpdateCallback = null;
    var _onCompleteCallback = null;

    this.from = function(properties){

        _object = properties;

        // 保存开始值
        for (var field in _object) {
            _valuesStart[field] = _object[field];
        }

        return this;
    };

    this.to = function(properties, duration) {

        if (duration !== undefined) {
            _duration = duration;
        }

        _valuesEnd = properties;
        return this;
    };

    this.onStart = function (callback) {

        _onStartCallback = callback;
        return this;
    };

    this.onUpdate = function (callback) {

        _onUpdateCallback = callback;
        return this;
    };

    this.onComplete = function (callback) {

        _onCompleteCallback = callback;
        return this;
    };

    this.start = function( frameTime ) {

        _onStartCallbackFired = false;

        // 连续点击，会生成很多id
        // 先清除之前的id
        if (_timerId) {
            cancelAnimationFrame(_timerId);
        }

        //_startTime = window.performance.now();
        _startTime = Date.now();

        _interpolationFunction = this.interpolate;

        function animate() {

            var elapsed;
            var start = _valuesStart;
            var end = _valuesEnd;
            //var time = window.performance.now();
            var time = Date.now();

            if (_onStartCallbackFired === false) {

                if (_onStartCallback !== null) {
                    _onStartCallback.call(_object);
                }

                _onStartCallbackFired = true;
            }

            elapsed = (time - _startTime) / _duration;
            elapsed = elapsed > 1 ? 1 : elapsed;

            _object = _interpolationFunction(start, end, elapsed);

            if (elapsed === 1) {

                // 清除计时器
                cancelAnimationFrame(_timerId);

                if (_onCompleteCallback !== null) {
                    _onCompleteCallback.call(_object);
                }
            } else {
                requestAnimationFrame(animate, frameTime)
                if (_onUpdateCallback !== null) {
                    _onUpdateCallback.call(_object, elapsed);
                }
            }
        };

        // 启动计时器
        _timerId = requestAnimationFrame(animate, frameTime);
    };

    //判断两向量角度是否大于180°，大于180°返回真，否则返回假
    this.isAngleGreaterThanPi = function(start, end, up){

        // 根据混合积来判断角度
        var dir = new THREE.Vector3();
        dir.crossVectors(start, end);

        var volume = dir.dot(up);

        //dir 与 up 同向 - 小于 180°
        if (volume >= 0) {
            return false;
        }

        return true;
    };

    // 圆弧插值
    this.conicInterpolate = function(start, end, interp, percentage) {

        var totalAngle = end.angleTo(start);
        var angle = -totalAngle * percentage;

        var axis = new THREE.Vector3();
        axis.crossVectors(end, start).normalize();

        var quat = new THREE.Quaternion();
        quat.setFromAxisAngle(axis, angle);

        interp.copy(start);
        interp.applyQuaternion(quat);
    };

    this.quaternionInterpolate = function(start, end, up, interp, percentage){

        var startQuaternion = new THREE.Quaternion(start.x, start.y, start.z, 1).normalize();
        var endQuaternion = new THREE.Quaternion(end.x, end.y, end.z, 1).normalize();
        var midQuaternion = new THREE.Quaternion(0, 0, 0 ,1);
        var slerpQuaternion = new THREE.Quaternion(0, 0, 0 ,1);
        var middle = new THREE.Vector3(); // 中间量
        middle.crossVectors(start , up).normalize();

        // 中间量四元数
        midQuaternion.set(middle.x, middle.y, middle.z, 1).normalize();

        var step = 0;
        if (percentage < 0.5) {
            step = percentage * 2;
            THREE.Quaternion.slerp(startQuaternion, midQuaternion, slerpQuaternion, step);
            interp.set(slerpQuaternion.x, slerpQuaternion.y, slerpQuaternion.z);
        } else {
            step = (percentage - 0.5) * 2;
            THREE.Quaternion.slerp(midQuaternion, endQuaternion, slerpQuaternion, step);
            interp.set(slerpQuaternion.x, slerpQuaternion.y, slerpQuaternion.z);
        }

    }

    // 球形插值
    this.slerpInterpolate = function(start, end, up, interp, percentage, tolerance) {

        var cosTheta = start.dot(end);
        
        if (tolerance < cosTheta){ // start == end (0度)
            interp.copy(end);
        } 
        else  if (tolerance < Math.abs(cosTheta)) {// start == -end (180度)

           this.quaternionInterpolate(start, end, up, interp, percentage)

        } else { // start != abs(end)

            this.conicInterpolate(start, end, interp, percentage);

        }

        interp.normalize();
    };

    // 线性插值
    this.linearInterpolate = function(start, end, interp, percentage, tolerance) {

        if(start.equals(end)){
            interp.copy(end);
            return;
        }

        var unitX = new THREE.Vector3( 1, 0 , 0 );
        var unitZ = new THREE.Vector3( 0, 0 , 1);
        var middle = new THREE.Vector3(); // 中间量
        var step = 0;
        var cosTheta = start.dot(end);

        // start == end (0度)
        if (tolerance < cosTheta){
            interp.copy(end);
        } else if (tolerance < -cosTheta) {// start == -end (180度)

            if ( tolerance > Math.abs( start.dot( unitZ )) ) {
                middle.crossVectors(start, unitZ).normalize();
            } else {
                middle.crossVectors(start, unitX).normalize();
            }

            // 非均匀插值，每段变化角度不一样
            if (percentage < 0.5) {
                step = percentage * 2;
                interp.lerpVectors(start, middle, step);
            } else {
                step = (percentage - 0.5) * 2;
                interp.lerpVectors(middle, end, step);
            }

        }else { // start != abs(end)
            interp.lerpVectors(start, end, percentage);
        }

        interp.normalize();
    };

    // 线性插值
    this.linearInterpolatePosition = function(start, end, interp, percentage) {

        interp.lerpVectors(start, end, percentage); 
    };

    // 插值处理
    this.interpolate = function (valuesStart, valuesEnd, percentage) {

        // 插值结果
        var interpDir = new THREE.Vector3();
        var interpUp = new THREE.Vector3();
        var interpTarget = new THREE.Vector3();
        var interpFocal = new THREE.Vector3();

        var startTarget = valuesStart.animTarget;
        var startDir = valuesStart.animDir;
        var startUp = valuesStart.animUp;
        var startFocal = valuesStart.animFocal;
        var endTarget = valuesEnd.animTarget;
        var endDir = valuesEnd.animDir;
        var endUp = valuesEnd.animUp;
        var endFocal = valuesEnd.animFocal;

        // 计算插值量 - dir
        _scope.slerpInterpolate(startDir, endDir, startUp, interpDir, percentage, _tolerance);

        // 计算插值量 - up
        _scope.linearInterpolate(startUp, endUp, interpUp, percentage, _tolerance);

        // 计算插值量 - target
        _scope.linearInterpolatePosition(startTarget, endTarget, interpTarget, percentage);

        // 计算插值量 - Focal
        _scope.linearInterpolatePosition(startFocal, endFocal, interpFocal, percentage);

        return {
            animDir: interpDir,
            animUp: interpUp,
            animTarget: interpTarget,
            animFocal: interpFocal
        };
    };
   

};