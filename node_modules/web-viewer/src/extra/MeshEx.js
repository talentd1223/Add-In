/**
 * The object to be held within the Object Pool.
 *
 * @class  CLOUD.MeshEx
 */
CLOUD.MeshEx = function (geometry, material) {

    THREE.Mesh.call(this, geometry, material);

    this.type = 'MeshEx';

    this.matrixAutoUpdate = false; // disable auto update
    this.alive = false; // 是否激活, 默认不激活

    this.geometry = geometry ? geometry : CLOUD.GeomUtil.EmptyGeometry;
    this.material = material ? material : CLOUD.MaterialUtil.DefaultMaterial;

    this.originalId = undefined;

};

CLOUD.MeshEx.prototype = Object.create(THREE.Mesh.prototype);
CLOUD.MeshEx.prototype.constructor = CLOUD.MeshEx;

/**
 * Sets an object not in use to default values
 */
CLOUD.MeshEx.prototype.init = function (parameters) {

    if (parameters && parameters.parent) {
        parameters.parent.add(this);
    }

};

/**
 * destroy the object
 */
CLOUD.MeshEx.prototype.destroy = function () {

    if (this.parent) {
        this.parent.remove(this);
    }

    if (this.userData) {
        this.userData = null;
    }

    this.geometry = null;
    this.material = null;
};

/**
 * Spawn an object
 */
CLOUD.MeshEx.prototype.spawn = function (parameters) {

    if (parameters.userId !== undefined) {
        this.name = parameters.userId;
    } else if (parameters.nodeId !== undefined) {
        this.name = parameters.nodeId;
    }

    if (parameters.geometry) {
        this.geometry = parameters.geometry;
    }

    if (parameters.material) {
        this.material = parameters.material;
    }

    if (parameters.matrix) {
        this.matrix.copy(parameters.matrix);
        this.updateMatrixWorld(true);//  this.matrixAutoUpdate = false;需要强制更新
    } else {
        this.matrix.identity();
        this.updateMatrixWorld(true);//  this.matrixAutoUpdate = false;需要强制更新
    }

    if (parameters.databagId) {
        this.databagId = parameters.databagId;
    } else {
        this.databagId = "";
    }

    if (parameters.userData) {
        this.userData = parameters.userData;
    } else {
        if (this.userData) {
            this.userData = null;
        }
    }

    if (parameters.originalId) {
        this.originalId = parameters.originalId;
    }

    if (parameters.visible != undefined) {
        this.visible = parameters.visible;
    }

    this.renderOrder = parameters.renderOrder||0;
    
    this.alive = true;
   
    // 适配Three.js
    this.frustumCulled = false;
    this.material.visible = true;
};

/**
 * Resets the object values to default
 */
CLOUD.MeshEx.prototype.clear = function () {

    this.geometry = CLOUD.GeomUtil.EmptyGeometry;
    this.material = CLOUD.MaterialUtil.DefaultMaterial;
    this.alive = false;
    this.visible = true; // 每次重置为true，以防止隐藏过构件
    // 适配Three.js
    this.frustumCulled = true;
    this.material.visible = false;
};

// why need alive flag???
CLOUD.MeshEx.prototype.isVisible = function() {
    return this.visible && this.alive;
}

/**
 * Intersect the mesh boundbox with ray, return the near distance from
 * ray to bounding box.
 * If not intersect, return -1.
 */
CLOUD.MeshEx.prototype.intersectBoxWithDistance = (function () {
    var bbox = new THREE.Box3();

    return function (raycaster) {
        var geometry = this.geometry;
        var material = this.material;
        var matrixWorld = this.matrixWorld;

        if (material === undefined)
            return -1;

        // Checking boundingSphere distance to ray
        if (!geometry.boundingBox) geometry.computeBoundingBox();

        bbox.copy(geometry.boundingBox);
        bbox.applyMatrix4(matrixWorld);

        return raycaster.ray.intersectBoxWithDistance(bbox);
    }
}());


CLOUD.MeshEx.prototype.intersectBoxWithDistanceByIndices = function (raycaster, indexInfo) {

    var matrixWorld = this.matrixWorld;
    var box = this.computeBoundingBox(indexInfo);
    box.applyMatrix4(matrixWorld);

    return raycaster.ray.intersectBoxWithDistance(box);
};

CLOUD.MeshEx.prototype.raycastByIndices = ( function () {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();

    var vA = new THREE.Vector3();
    var vB = new THREE.Vector3();
    var vC = new THREE.Vector3();

    var uvA = new THREE.Vector2();
    var uvB = new THREE.Vector2();
    var uvC = new THREE.Vector2();

    var barycoord = new THREE.Vector3();

    var intersectionPoint = new THREE.Vector3();
    var intersectionPointWorld = new THREE.Vector3();

    function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

        THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

        uv1.multiplyScalar( barycoord.x );
        uv2.multiplyScalar( barycoord.y );
        uv3.multiplyScalar( barycoord.z );

        uv1.add( uv2 ).add( uv3 );

        return uv1.clone();

    }

    function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {

        var intersect;
        var material = object.material;

        if ( material.side === THREE.BackSide ) {

            intersect = ray.intersectTriangle( pC, pB, pA, true, point );

        } else {

            intersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );

        }

        if ( intersect === null ) return null;

        intersectionPointWorld.copy( point );
        intersectionPointWorld.applyMatrix4( object.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

        if ( distance < raycaster.near || distance > raycaster.far ) return null;

        return {
            distance: distance,
            point: intersectionPointWorld.clone(),
            object: object
        };

    }

    function checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {

        vA.fromBufferAttribute( position, a );
        vB.fromBufferAttribute( position, b );
        vC.fromBufferAttribute( position, c );

        var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

        if ( intersection ) {

            if ( uv ) {

                uvA.fromBufferAttribute( uv, a );
                uvB.fromBufferAttribute( uv, b );
                uvC.fromBufferAttribute( uv, c );

                intersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

            }

            intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );
            intersection.faceIndex = a;

        }

        return intersection;

    }

    return function raycast( raycaster, intersects , indexInfo) {

        var geometry = this.geometry;
        var material = this.material;
        var matrixWorld = this.matrixWorld;

        if ( material === undefined ) return;

        sphere.copy( this.computeBoundingSphere(indexInfo) );
        sphere.applyMatrix4( matrixWorld );

        if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

        //

        inverseMatrix.getInverse( matrixWorld );
        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

        // Check boundingBox before continuing

        var boundingBox = this.computeBoundingBox(indexInfo);

        if ( ray.intersectsBox( boundingBox ) === false ) return;

        var intersection;

        var a, b, c;
        var position = geometry.attributes.position;
        var uv = geometry.attributes.uv;
        var i, len;

        var beginIndex = indexInfo.indexStart;
        var endIndex = indexInfo.indexStart + indexInfo.indexCount;

        var indexArray = geometry.getIndex().array;
        //var indexArray = geometry.getIndex().array.slice(beginIndex, endIndex);

        // indexed buffer geometry

        // for ( i = 0, len = indexArray.length; i < len; i += 3 )
        for ( i = beginIndex, len = endIndex; i < len; i += 3 ) {

            a = indexArray[i];
            b = indexArray[i + 1];
            c = indexArray[ i + 2 ];

            intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

            if ( intersection ) {

                intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
                intersects.push( intersection );

            }

        }

    };

}() );

CLOUD.MeshEx.prototype.computeBoundingBox = function (indexInfo) {

    var bbox = new THREE.Box3();
    var geometry = this.geometry;
    var positionArray = geometry.attributes.position.array;
    // var positionArray = geometry.attributes.position.array.slice(begin, end);
    // bbox.setFromArray( positionArray );

    var begin, end;
    if (indexInfo) {
        begin = indexInfo.positionStart;
        end = indexInfo.positionStart + indexInfo.positionCount;
    } else {
        begin = 0;
        end = positionArray.length;
    }

    this.setBoundingBoxFromArray(bbox, positionArray, begin, end);

    return bbox;
};

CLOUD.MeshEx.prototype.computeBoundingSphere = function (indexInfo) {

    var box = new THREE.Box3();
    var vector = new THREE.Vector3();
    var geometry = this.geometry;
    //var positionArray = geometry.attributes.position.array.slice(begin, end);
    var positionArray = geometry.attributes.position.array;

    var begin, end;
    if (indexInfo) {
        begin = indexInfo.positionStart;
        end = indexInfo.positionStart + indexInfo.positionCount;
    } else {
        begin = 0;
        end = positionArray.length;
    }

    var boundingSphere = new THREE.Sphere();
    var center = boundingSphere.center;
    // box.setFromArray(positionArray);
    this.setBoundingBoxFromArray(box, positionArray, begin, end);
    box.getCenter(center);

    var maxRadiusSq = 0;
    for (var i = begin, il = end; i < il; i += 3) {
        vector.x = positionArray[i];
        vector.y = positionArray[i + 1];
        vector.z = positionArray[i + 2];
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
    }
    boundingSphere.radius = Math.sqrt(maxRadiusSq);

    return boundingSphere;
};

CLOUD.MeshEx.prototype.setBoundingBoxFromArray = function (boudingBox, array, begin, end) {

    var minX = + Infinity;
    var minY = + Infinity;
    var minZ = + Infinity;

    var maxX = - Infinity;
    var maxY = - Infinity;
    var maxZ = - Infinity;

    for ( var i = begin, len = end; i < len; i += 3 ) {

        var x = array[ i ];
        var y = array[ i + 1 ];
        var z = array[ i + 2 ];

        if ( x < minX ) minX = x;
        if ( y < minY ) minY = y;
        if ( z < minZ ) minZ = z;

        if ( x > maxX ) maxX = x;
        if ( y > maxY ) maxY = y;
        if ( z > maxZ ) maxZ = z;

    }

    boudingBox.min.set( minX, minY, minZ );
    boudingBox.max.set( maxX, maxY, maxZ );
};
