CLOUD.PointsEx = function (geometry, material) {

    THREE.Points.call(this, geometry, material);

    this.pointIds = [];

};

CLOUD.PointsEx.prototype = Object.create(THREE.Points.prototype);
CLOUD.PointsEx.prototype.constructor = CLOUD.PointsEx;

CLOUD.PointsEx.prototype.raycast = ( function () {

    var inverseMatrix = new THREE.Matrix4();
    var ray = new THREE.Ray();
    var sphere = new THREE.Sphere();

    return function raycast(raycaster, intersects) {

        var object = this;
        var geometry = this.geometry;
        var matrixWorld = this.matrixWorld;
        var maxPixelSize = this.size;
        var camera = raycaster.camera; // 置入camera属性
        var viewportHeight = raycaster.viewportSize.height; // 置入viewportSize
        var pointIds = this.pointIds;

        inverseMatrix.getInverse(matrixWorld);

        // 计算偏移yOffset像素之后的位置
        function calcPositionAfterYOffset(position, yOffset) {

            var newPosition = position.clone();
            newPosition.applyMatrix4(matrixWorld);
            newPosition.project(camera);
            newPosition.y += yOffset / viewportHeight;
            newPosition.unproject(camera);
            newPosition.applyMatrix4(inverseMatrix);
            return newPosition;

        }

        // Checking boundingSphere distance to ray

        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

        sphere.copy(geometry.boundingSphere);

        var sphereCenter = sphere.center;
        var newSphereCenter = calcPositionAfterYOffset(sphereCenter, maxPixelSize);
        var threshold = newSphereCenter.distanceToSquared(sphereCenter);

        sphere.radius += threshold;
        sphere.center.copy(newSphereCenter);
        sphere.applyMatrix4(matrixWorld);

        if (raycaster.ray.intersectsSphere(sphere) === false) return;

        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

        var position = new THREE.Vector3();
        var pixelSize = maxPixelSize;

        function testPoint(point, size, index) {

            var newPoint = calcPositionAfterYOffset(point, size);
            var localThresholdSq = newPoint.distanceToSquared(point);
            var rayPointDistanceSq = ray.distanceSqToPoint(newPoint);

            if (rayPointDistanceSq < localThresholdSq) {

                var intersectPoint = ray.closestPointToPoint(newPoint);
                intersectPoint.applyMatrix4(matrixWorld);

                var distance = raycaster.ray.origin.distanceTo(intersectPoint);

                if (distance < raycaster.near || distance > raycaster.far) return;

                intersects.push({

                    id: pointIds[index], // add
                    distance: distance,
                    distanceToRay: Math.sqrt(rayPointDistanceSq),
                    point: intersectPoint.clone(),
                    index: index,
                    face: null,
                    object: object

                });

            }

        }

        if (geometry.isBufferGeometry) {

            var index = geometry.index;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;

            var hasAttrSize = false;
            var sizes;

            if (attributes.attrSize) {
                hasAttrSize = true;
                sizes = attributes.attrSize.array;
            }

            if (index !== null) {

                var indices = index.array;

                for (var i = 0, il = indices.length; i < il; i++) {

                    var a = indices[i];

                    position.fromArray(positions, a * 3);

                    if (hasAttrSize) {
                        pixelSize = sizes[a];
                    }

                    testPoint(position, pixelSize, a);

                }

            } else {

                for (var i = 0, l = positions.length / 3; i < l; i++) {

                    position.fromArray(positions, i * 3);

                    if (hasAttrSize) {
                        pixelSize = sizes[i];
                    }

                    testPoint(position, pixelSize, i);

                }

            }

        } else {

            var vertices = geometry.vertices;

            for (var i = 0, l = vertices.length; i < l; i++) {

                testPoint(vertices[i], pixelSize, i);

            }

        }

    };

}() );

CLOUD.PointsEx.prototype.setAttributeSize = function (idx, size) {

    var attributes = this.geometry.attributes;

    if (attributes.attrSize) {

        attributes.attrSize.array[ idx ] = size;
        attributes.attrSize.needsUpdate = true;
    }

};

CLOUD.PointsEx.prototype.getAttributeSize = function (idx) {

    var attributes = this.geometry.attributes;
    var size = this.size;

    if (attributes.attrSize) {
        size = attributes.attrSize.array[idx];
    }

    return size;

};
