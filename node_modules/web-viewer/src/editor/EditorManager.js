


CLOUD.EditorManager = function () {

    this.editor = null;
	// TODO: do we need to keep the editor list? To keep their state? But what state do we should keep?
    this.editors = {};
	// edit tools list
	this.tools = [];
	
	this.domElement = null;
	
	// TODO: only mouse operation is disabled if interactive state is false; Do we need to disable all
	//       kinds of operation, for example, key operation?
	this.enabled = true;  // 是否允许交互
    this.isUpdateRenderList = true; // 是否更新渲染列表

    this.movePad = null;

    var _mousePressed = false; // 鼠标是否按下，以便于判断现在鼠标是hover操作还是move操作
	
	var scope = this;

    function onMouseDown(event) {

        // 每次按下鼠标激活canvas
        setFocuse();

        _mousePressed = true;
        scope.isUpdateRenderList = false;

        scope.editor.processMouseDown(event);
    }

    function onMouseMove(event) {
        if(_mousePressed) {
            scope.isUpdateRenderList = false;
            scope.cameraChange = true;
            scope.editor.processMouseMove(event);
        }
        else {
            scope.editor.processHover(event);
        }
    }

    function onMouseUp(event) {

        // 只要存在up事件，允许更新渲染列表
        scope.isUpdateRenderList = true;
        // this.cameraChange = false;

        if (_mousePressed) {
            scope.editor.processMouseUp(event);
            _mousePressed = false;
        }
    }
	
	function onEvent(event) {
		if (!scope.enabled) {
			scope.cameraChange = false;
			return;
		}
		
		var tools = scope.tools;
		
		// handle the event by tools at first
		// the last enalbed tool has higher priority
		for (var i = tools.length - 1; i >= 0; i--) {
			if (tools[i].onEvent(event)) {
                switch(event.type) {
                    case 'mouseup':
                        _mousePressed = false; // we must reset mousePress state
                        break;
                }
				// if the tool can handle the event, not process this event further
				return;
			}
		}			
		
		// if no tool process the event, let the editor process it
		switch(event.type) {
			case 'touchmove':
				scope.editor.processTouchmove(event);
				break;
			case 'touchstart':
				scope.editor.processTouchstart(event);
				break;
			case 'touchend':
				scope.editor.processTouchend(event);
			case 'keydown':
				scope.editor.processKeyDown(event);
				break;
			case 'keyup':
				scope.editor.processKeyUp(event);
				break;
			case 'mousewheel':
			case 'DOMMouseScroll':
				scope.cameraChange = true;
				scope.editor.processMouseWheel(event);
				break;
			case 'mousedown':
				onMouseDown(event);
				break;
			case 'mousemove':
				onMouseMove(event);
				break;
			case 'mouseup':
				onMouseUp(event);
				break;
			
			case 'dblclick':
				scope.editor.processMouseDoubleClick(event);
				break;
		}
	}

    function setFocuse() {
        // 设置焦点
        if (scope.domElement) {
            var canvas = scope.domElement.querySelector("#cloud-main-canvas");
            if (canvas && canvas.focus)
                canvas.focus();
        }
    }
	
    this.registerDomEventListeners = function (domElement) {
		
		this.domElement = domElement;

        // BIMFACEDM-4169: 长期方案应当将Mobile与PC事件分别注册并响应。
        // 但是，Pick的行为在移动端也实现在mouse事件响应函数内了，这个做法不妥，应当在touch里响应。
        // 为缩小代码改动影响，仅在测量工具中做相应的处理避免测量问题。
        //if(CLOUD.GlobalData.IsMobile) {
            domElement.addEventListener('touchstart', onEvent, false);
            domElement.addEventListener('touchend', onEvent, false);
            domElement.addEventListener('touchmove', onEvent, false);
        //}else {
            domElement.addEventListener('contextmenu', function (event) {
                event.preventDefault();
            }, false);
            domElement.addEventListener('mousedown', onEvent, false);
            domElement.addEventListener('mousewheel', onEvent, false);
            domElement.addEventListener('DOMMouseScroll', onEvent, false); // firefox
            domElement.addEventListener('dblclick', onEvent, false);

            // 注册在document上会影响dbgUI的resize事件
            window.addEventListener('mousemove', onEvent, false);
            window.addEventListener('mouseup', onEvent, false);

            //window.addEventListener( 'keydown', onKeyDown, false );
            //window.addEventListener( 'keyup', onKeyUp, false );
            domElement.addEventListener('keydown', onEvent, false);
            domElement.addEventListener('keyup', onEvent, false);
        //}

        setFocuse();
    };

    this.unregisterDomEventListeners = function (domElement) {

        //if(CLOUD.GlobalData.IsMobile) {
            domElement.removeEventListener('touchstart', onEvent, false);
            domElement.removeEventListener('touchend', onEvent, false);
            domElement.removeEventListener('touchmove', onEvent, false);
        //} else {
            domElement.removeEventListener('contextmenu', function (event) {
                event.preventDefault();
            }, false);
            domElement.removeEventListener('mousedown', onEvent, false);
            domElement.removeEventListener('mousewheel', onEvent, false);
            domElement.removeEventListener('DOMMouseScroll', onEvent, false); // firefox
            domElement.removeEventListener('dblclick', onEvent, false);

            // 注册在document上会影响dbgUI的resize事件
            window.removeEventListener('mousemove', onEvent, false);
            window.removeEventListener('mouseup', onEvent, false);

            //window.removeEventListener( 'keydown', onKeyDown, false );
            //window.removeEventListener( 'keyup', onKeyUp, false );
            domElement.removeEventListener('keydown', onEvent, false);
            domElement.removeEventListener('keyup', onEvent, false);
        //}
    };

};


CLOUD.EditorManager.prototype = {

    constructor: CLOUD.EditorManager,

    destroy: function () {

        this.editor = null;

        for (var name in this.editors) {
            var editor = this.editors[name];
            editor.destroy();
        }

        this.editors = {};
        this.movePad = null;
		
    },

    getCurrentEditorName: function () {
        return this.editor ? this.editor.name : "";
    },

    _getEditorByName: function (viewer, name) {

        var editor = this.editors[name];

        if (editor) {
            return editor;
        }

        var editorMode = CLOUD.EditorMode;
        var cameraControl = viewer.cameraControl;
        var scene = viewer.getScene();
        var domElement = viewer.domElement;

        switch (name) {

            case editorMode.ORBIT:
                editor = new CLOUD.OrbitEditor(cameraControl);
                break;

            case editorMode.PICK:
                editor = new CLOUD.PickEditor(cameraControl);
                break;

            case editorMode.PAN:
                editor = new CLOUD.PanEditor(cameraControl);
                break;

            case editorMode.ZOOM:
                editor = new CLOUD.ZoomEditor(cameraControl);
                break;

            case editorMode.FLY:
                editor = new CLOUD.FlyEditor(cameraControl);
                break;

            case editorMode.WALK:
                editor = new CLOUD.WalkEditor(cameraControl);
                break;

            default:
                editor = null;
                console.error("invalid editor name");
                break;
        }

        if (editor) {
            editor.name = name;
            this.editors[name] = editor;
        }

        return editor;
    },

    getCurrentEditor: function () {

        return this.editor;
    },

    setEditorMode: function (viewer, name) {

        var editor = this._getEditorByName(viewer, name);

        if (editor) {

            if (this.editor !== editor) {

                if (this.editor !== null) {

                    this.editor.dispatchEvent({type: CLOUD.EVENTS.ON_EDITOR_EXIST, name: this.editor.getName()});
                    this.editor.onExit();
                }

                this.editor = editor;
                this.editor.onEnter();
                this.editor.dispatchEvent({type: CLOUD.EVENTS.ON_EDITOR_ENTER, name: this.editor.getName()});

            }

        }

    },

    getToolByName: function(toolName) {

        var length = this.tools.length;
        for (var i = 0; i < length; ++i) {

            if (this.tools[i].name == toolName)
                return this.tools[i];

        }

        return;

    },

    // enable edit tool by creating the tool and insert to tool array
    // if the tool has been enabled, do nothing
    //
	enableTool: function(viewer, toolName) {
		var toolMode = CLOUD.EditToolMode;
		var tools = this.tools;
		
		// check if the tool has been enable. if has been enabled, skip it
		for (var i = 0, len = tools.length; i < len; i++) {
			if (tools[i].name == toolName) {
				// TODO: report message that the tool has been enabled
				
				return;
			}
		}
		
		// create new tool
		var newTool = null;
		switch(toolName) {
            case toolMode.PICK_BY_RECT:
                newTool = new CLOUD.RectPickTool(viewer);
                break;

            case toolMode.ZOOM_BY_RECT:
                newTool = new CLOUD.RectZoomTool(viewer);
                break;
				
            case toolMode.CLIP_BY_BOX:
                newTool = new CLOUD.ClipPlanesTool(viewer);
                break;

            case toolMode.CLIP_FILL:
                newTool = new CLOUD.FillClipPlaneTool(viewer);
                break;

            case toolMode.PICK_BY_MEASURE:
                newTool = new CLOUD.MeasureTool(viewer);
                break;
		}
		
		// add it to tool list
		if (newTool) {
			tools.push(newTool);
		}
	},

    // disable tool by destroying it and remove from tool array
    //
	disableTool: function(toolName) {
		var tools = this.tools;
		
		// remove the tool from tool list
		for (var i = 0, len = tools.length; i < len; i++) {
			if (tools[i].name == toolName) {
			    tools[i].onExit(); // do some clean work
				tools.splice(i, 1);
				break;
			}
		}
		// TODO: give message if the tool is not enabled before
	},
	
	/** 
	 * set the global status if interactive operation is allowed
	 */
	setInteractiveState: function(state) {
		this.enabled = state;
	}
};