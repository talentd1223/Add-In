/**
 * Edit tool for zooming scene to objects picked by mouse rectangle operation
 *
 */
CLOUD.RectZoomTool = function (viewer) {
    
    CLOUD.RectOpTool.call(this, CLOUD.EditToolMode.ZOOM_BY_RECT, viewer.cameraControl, viewer.modelManager);
	
	this.scene = viewer.getScene();
	
    this.activateZoom = false;
};

CLOUD.RectZoomTool.prototype = Object.create(CLOUD.RectOpTool.prototype);
CLOUD.RectZoomTool.prototype.constructor = CLOUD.RectZoomTool;

CLOUD.RectZoomTool.prototype.processMouseDown = function(event) {

	// Why do below setting?
    //event.preventDefault();
    //event.stopPropagation();

    if (event.button === THREE.MOUSE.LEFT) {

        this.startPt.set(event.clientX, event.clientY);
        this.activateZoom = true;
		
		return true;
    }

    return CLOUD.RectOpTool.prototype.processMouseDown.call(this, event);
};

CLOUD.RectZoomTool.prototype.processMouseMove = function(event) {

    //event.preventDefault();

    if (this.activateZoom) {

        this.endPt.set(event.clientX, event.clientY);
		
        this.updateFrustum(false, true);
		
        return true;
    }

    return CLOUD.RectOpTool.prototype.processMouseMove.call(this, event);
};

CLOUD.RectZoomTool.prototype.processMouseUp = function(event) {

    //event.preventDefault();
    //event.stopPropagation();
	
	if (this.activateZoom) {

		this.activateZoom = false;
        this.onUpdateUI({visible: false});

		this.endPt.set(event.clientX, event.clientY);

		if (this.updateFrustum(true, false)) {
			this.zoomToRectangle();
		}
			
		return true;
	}

    return CLOUD.RectOpTool.prototype.processMouseUp.call(this, event);
};

CLOUD.RectZoomTool.prototype.zoomToRectangle = function () {
    var camera = this.cameraControl.camera;
    var target = this.cameraControl.camera.target;
    var zNear = camera.near;

    var canvasBounds = this.cameraControl.getContainerDimensions();
    // var startX = this.startPt.x - canvasBounds.left;
    // var startY = this.startPt.y - canvasBounds.top;
    // var endX = this.endPt.x - canvasBounds.left;
    // var endY = this.endPt.y - canvasBounds.top;

    var startX = this.startPt.x;
    var startY = this.startPt.y;
    var endX = this.endPt.x;
    var endY = this.endPt.y;
    var rectWidth = Math.abs(endX - startX);
    var rectHeight = Math.abs(startY - endY);

    if (rectWidth === 0 || rectHeight === 0)  return;

    var rectCenter = new THREE.Vector2((startX + endX) / 2, (startY + endY) / 2);

    var eye = camera.position.clone();
    var dirEyeToTarget = target.clone().sub(eye);
    var distEyeToTarget = dirEyeToTarget.length();

    var dirZoom;

	var intersectContext = this.cameraControl.getIntersectContext(rectCenter);

    var pivot = this.cameraControl.intersector.hitTest(intersectContext);

    if (pivot) {

        var scaleFactor = rectWidth / rectHeight > canvasBounds.width / canvasBounds.height ? rectWidth / canvasBounds.width : rectHeight / canvasBounds.height;
        var distEyeToPivot = pivot.distanceTo(eye);
        var distZoom = distEyeToPivot * scaleFactor;

        dirEyeToTarget.normalize();
        //dirZoom = eye.clone().sub(pivot).normalize().multiplyScalar(zoomDist);
        dirZoom = dirEyeToTarget.clone().negate().multiplyScalar(distZoom);

    } else {

        var rcZoom = {};
        rcZoom.left = Math.min(startX, endX);
        rcZoom.top = Math.min(startY, endY);
        rcZoom.right = Math.max(startX, endX);
        rcZoom.bottom = Math.max(startY, endY);

        var closeDepth = this.scene.getNearDepthByRect(this.frustum, camera);

        if (closeDepth !== Infinity){

            var rCenter = new THREE.Vector3((startX + endX) / 2, (startY + endY) / 2, closeDepth);
            var rCorner = new THREE.Vector3(rcZoom.left, rcZoom.top, closeDepth);
            var wCenter = this.clientToWorld(rCenter);
            var wCorner = this.clientToWorld(rCorner);
            var distZoom = wCenter.clone().sub(wCorner).length();

            //if (distZoom < zNear) {
            //    //CLOUD.Logger.log("new dist", [newDist, near]);
            //    distZoom = zNear;
            //}

            pivot = wCenter.clone();
            dirEyeToTarget.normalize();
            dirZoom = dirEyeToTarget.clone().negate().multiplyScalar(distZoom);

        } else {

            return;
            /*
            // below code cannot work well. When near is small, the camera will be moved largely and cannot zoom back
            // see BIMFACEDM-1957
            var halfFrustumHeight = zNear * Math.tan(THREE.Math.degToRad(camera.fov * 0.5));
            var halfFrustumWidth = halfFrustumHeight * camera.aspect;
            var rightWidth = rectCenter.x * 2 * halfFrustumWidth / canvasBounds.width;
            var distCenterToRight = rightWidth - halfFrustumWidth;
            var upHeight = rectCenter.y * 2 * halfFrustumHeight / canvasBounds.height;
            var distCenterToUp = upHeight - halfFrustumHeight;
            var dirRight = this.cameraControl.getWorldRight();
            var dirUp = this.cameraControl.getWorldUp();

            dirRight.normalize().multiplyScalar(distCenterToRight);
            dirUp.multiplyScalar(distCenterToUp);

            var dirRay = dirEyeToTarget.clone().add(dirUp).add(dirRight);

            pivot = eye.clone().add(dirRay);

            var scaleFactor = rectWidth / rectHeight > canvasBounds.width / canvasBounds.height ? rectWidth / canvasBounds.width : rectHeight / canvasBounds.height;
            var distEyeToPivot = pivot.distanceTo(eye);
            var distZoom = distEyeToPivot * scaleFactor;

            dirEyeToTarget.normalize();
            //dirZoom = eye.clone().sub(pivot).normalize().multiplyScalar(zoomDist);
            dirZoom = dirEyeToTarget.clone().negate().multiplyScalar(distZoom);
            */
        }

    }

    eye = pivot.clone().add(dirZoom);
    camera.position.copy(eye);
    target.copy(eye).sub(dirZoom.clone().normalize().multiplyScalar(distEyeToTarget));
    this.cameraControl.updateView(true);
};


// TODO: 和Viewer里的方法同名，是否功能一样？
CLOUD.RectZoomTool.prototype.worldToClient = function (wPoint) {

    var camera = this.cameraControl.camera;
    var result = new THREE.Vector3(wPoint.x, wPoint.y, wPoint.z);

    result.project(camera);

    return result;
};

// TODO: 和Viewer里的方法同名，是否功能一样？
CLOUD.RectZoomTool.prototype.clientToWorld = function (cPoint) {

    var rect = this.cameraControl.getContainerDimensions();
    var camera = this.cameraControl.camera;
    var result = new THREE.Vector3();

    result.x = cPoint.x / rect.width * 2 - 1;
    result.y = -cPoint.y / rect.height * 2 + 1;
    result.z = cPoint.z;

    result.unproject(camera);

    return result;
};