CLOUD.PickHelper = function (cameraControl) {

    this.cameraControl = cameraControl;
    this.scene = cameraControl.scene;

    this.timerId = null;

    this.lastIntersected = null;
};

CLOUD.PickHelper.prototype = {

    constructor: CLOUD.PickHelper,

    destroy: function () {
        this.cameraControl = null;
        this.scene = null;
    },

    click: function (event, preIntersect) {

        var scope = this;

        function handleClick() {

            // BIMFACEDM-3672 pick by ignoring transparent object
            if(preIntersect && preIntersect.pickable === false ){
                preIntersect = null;
            }
            scope.handleMousePick(event, false, preIntersect);
        }

        if (this.timerId) {
            clearTimeout(this.timerId);
        }

        // 延迟300ms以判断是否单击
        this.timerId = setTimeout(handleClick, 300);
    },

    doubleClick: function (event) {

        event.preventDefault();

        if (this.timerId) {
            clearTimeout(this.timerId);
        }

        this.handleMousePick(event, true, null);
    },

    handleMousePick: function (event, isDoubleClick, preIntersect) {

        if (!this._canPick()) {
            return;
        }

        var scope = this;
        var cameraControl = this.cameraControl;
        var sceneState = cameraControl.viewer.modelManager.sceneState;
        var screenPos = new THREE.Vector2(event.clientX, event.clientY);
        var canvasXY = cameraControl.screenToCanvas(event.clientX, event.clientY);
        var modelManager = cameraControl.viewer.modelManager;

        function dispatchPickEvent(intersect, selectable) {

            // 外部需要获得event的一些状态，需要得到canvas坐标，屏幕坐标没用处
            modelManager.dispatchEvent({
                type: CLOUD.EVENTS.ON_CLICK_PICK,
                event: event, // add
                doubleClick: isDoubleClick, // add
                canvasPos: {x : canvasXY.x, y: canvasXY.y}, // adjust
                intersectInfo: intersect ? {
                        selectedObjectId: intersect.userId,
                        objectType: intersect.objectType,
                        selectable: selectable,
                        modelId: intersect.databagId,
                        worldPosition: intersect.worldPosition,
                        worldBoundingBox: intersect.worldBoundingBox,
                        point: intersect.point,
                        innnerDebugging: intersect.innnerDebugging
                    } : null
            });
        }

        var intersect = null;

        if (preIntersect) {
            // when mouse down, we pick object no matter if the object is selectable.
            // if previous picked object is not selectable, pick nothing
            if (preIntersect.pickable) {
                intersect = preIntersect.intersect;
            }
        } else {

            //var intersects = [];

            var intersectContext = cameraControl.getIntersectContext(screenPos);
            intersect = cameraControl.intersector.pick(intersectContext, null);

        }

        if (!intersect) {
            var oldSelection = sceneState.getSelection();

            if (oldSelection.length > 0) {
                sceneState.clearSelection();
                cameraControl.updateView(true);
            }
            scope.lastPickedUserId = undefined;

            if (preIntersect && !preIntersect.pickable) {
                // click on an unselectable object, trigger the click event with the object
                intersect = preIntersect.intersect;
                intersect.cx = screenPos.x;
                intersect.cy = screenPos.y;
                dispatchPickEvent(intersect, false);
            }
            else {
                dispatchPickEvent(null);
            }

            return;
        }

        var userId = intersect.userId;

        // scope.lastPickedUserId = userId;

        if (CLOUD.Utils.isMobileDevice()) {
            cameraControl.pivot = intersect.point;
        }

        // 将位置和包围转换到世界系
        scope.scene.intersectToWorld(intersect);

        intersect.innnerDebugging = event.altKey;
        intersect.cx = screenPos.x;
        intersect.cy = screenPos.y;

        if(Object.keys(modelManager.sceneState.selectionSet).length == 0) 
            scope.lastPickedUserId = null;
            
        if (userId !== scope.lastPickedUserId) {
            scope.lastPickedUserId = userId;

            // 双击构件
            if (isDoubleClick) {

                if (CLOUD.GlobalData.EnableDemolishByDClick) {
                    sceneState.addSelection([userId]);
                    dispatchPickEvent(intersect, true);
                    cameraControl.updateView(true);
                } else {
                    sceneState.setSelection([userId]);
                    cameraControl.fitAndRotateBySelection();
                    dispatchPickEvent(intersect, true);
                }

            } else {

                if (!event.ctrlKey) {
                    sceneState.setSelection([userId]);
                }
                else {
                    sceneState.addSelection([userId]);
                }
                dispatchPickEvent(intersect, true);
                cameraControl.updateView(true);
            }
        } else {
             //允许同一个构件也发送消息
            dispatchPickEvent(intersect, true);
        }
    },

    handleShiftMeasure: function (event, pick, lastPickPoint) {

        if (!this._canPick()) {
            return;
        }

        var cameraControl = this.cameraControl;
        var screenPos = new THREE.Vector2(event.clientX, event.clientY);
        var intersectContext = cameraControl.getIntersectContext(screenPos);

        function dispatchMeasureEvent(point, line, plane) {

            var modelManager = cameraControl.viewer.modelManager;
            if (point != null) {
                var worldPosition = cameraControl.scene.drawingToWorld(point);
                point.copy(worldPosition);
            }
            if (line != null) {
                var pointA = cameraControl.scene.drawingToWorld(line[0]);
                var pointB = cameraControl.scene.drawingToWorld(line[1]);
                line[0].copy(pointA);
                line[1].copy(pointB);
            }

            modelManager.dispatchEvent({
                type: CLOUD.EVENTS.ON_MEASURE_PICK,
                event: event, // add
                pick: pick,
                pickPoint: point,
                pickLine: line,
                pickPlane: plane
            });

        }

        cameraControl.intersector.pick(intersectContext, function (intersect) {

            if (intersect) {

                var direction = new THREE.Vector3();
                direction.subVectors(intersect.point, lastPickPoint);
                direction.normalize();

                var xAxis = new THREE.Vector3(1.0, 0.0, 0.0);
                var yAxis = new THREE.Vector3(0.0, 1.0, 0.0);
                var zAxis = new THREE.Vector3(0.0, 0.0, 1.0);

                var xdot = xAxis.dot(direction);
                var ydot = yAxis.dot(direction);
                var zdot = zAxis.dot(direction);

                var point = new THREE.Vector3();
                point.copy(lastPickPoint);

                if (Math.abs(ydot) >= 0.707) {
                    point.y = intersect.point.y;
                }
                else if (Math.abs(zdot) >= Math.abs(xdot)) {
                    point.z = intersect.point.z;
                }
                else {
                    point.x = intersect.point.x;
                }

                if (pick) {
                    lastPickPoint.copy(point);
                }
                dispatchMeasureEvent(point, null, false);

            }
            else {
                
                dispatchMeasureEvent(null, null, false);
            }

        });

    },

    handleMouseMeasure: function (event, pick, pickPointOut) {

        if (!this._canPick()) {
            return;
        }

        var cameraControl = this.cameraControl;
        var scene = cameraControl.scene;
        var screenPos = new THREE.Vector2(event.clientX, event.clientY);
        var intersectContext = cameraControl.getIntersectContext(screenPos);

        function dispatchMeasureEvent(point, line, plane) {

            var modelManager = cameraControl.viewer.modelManager;
            if (point != null) {
                var worldPosition = cameraControl.scene.drawingToWorld(point);
                point.copy(worldPosition);
            }
            if (line != null) {
                var pointA = cameraControl.scene.drawingToWorld(line[0]);
                var pointB = cameraControl.scene.drawingToWorld(line[1]);
                line[0].copy(pointA);
                line[1].copy(pointB);
            }

            modelManager.dispatchEvent({
                type: CLOUD.EVENTS.ON_MEASURE_PICK,
                event: event, // add
                pick: pick,
                pickPoint: point,
                pickLine: line,
                pickPlane: plane
            });

        }

        cameraControl.intersector.pick(intersectContext, function (intersect) {
            
            if (intersect) {

                var intersectPosition = intersect.point;
                var geometry = intersect.object.geometry;
                var matrix = intersect.object.matrixWorld;
                var projScreenMatrix = cameraControl.camera.projScreenMatrix;
                var mouse = intersectContext.mouse;
                var viewportSize = intersectContext.viewportSize;
                //有indexInfo表示是batchMerge的非instance构件，太大需特殊处理
                //解决BIMFACE-587：批次合并打开测量卡顿
                var indexInfo ;
                if(intersect.indexInfo !== undefined)
                    indexInfo = intersect.indexInfo;

                var positions = geometry.attributes.position.array;
                var normals = geometry.attributes.normal.array;
                
                var indices = [];
                var beginIndex = 0;
                var endIndex = 0;
                if(indexInfo)
                {
                    indices = geometry.index.array;
                    beginIndex = indexInfo.indexStart;
                    endIndex = indexInfo.indexStart + indexInfo.indexCount;
                }
                else
                {
                    indices = CLOUD.RemoveDuplicateVertex(geometry.attributes.position.array, geometry.index.array);
                    endIndex = indices.length;
                } 

                
                var distance = Infinity;
                var point = new THREE.Vector3();  


                var positionsArray = [];
                var indicesArray = [];
                for (var i = beginIndex; i < endIndex; ++i) {

                    var position = new THREE.Vector3(positions[indices[i] * 3], positions[indices[i] * 3 + 1], positions[indices[i] * 3 + 2]);
                    position.applyMatrix4(matrix);

                    var screenPos = position.clone();
                    screenPos.applyMatrix4(projScreenMatrix);

                    var dx = (screenPos.x - mouse.x) * 0.5 * viewportSize.width;
                    var dy = (screenPos.y - mouse.y) * 0.5 * viewportSize.height;

                    var length = Math.sqrt(dx * dx + dy * dy);
                    if (length < distance) {
                        distance = length;
                        point.copy(position);
                    }
                    if(indexInfo)
                    {
                        indicesArray.push(indices[i] - indices[beginIndex]);
                    }
                        
                }
                
                var pickPoint = intersectPosition.clone();
                var pickLine = null;
                var pickPlane = false;
                if (distance < 5.0) {

                    if (scene.hasObjectGroup(CLOUD.ObjectGroupType.MEASUREPICKPLANE)) {
                        scene.removeObjectGroupByName(CLOUD.ObjectGroupType.MEASUREPICKPLANE);
                    }
                    pickPoint = point.clone();

                }
                else {

                    function pointToLine(pointA, pointB, point) {

                        var ab = new THREE.Vector3();
                        ab.subVectors(pointB, pointA);

                        var ac = new THREE.Vector3();
                        ac.subVectors(point, pointA);

                        var f = ab.dot(ac);
                        if (f < 0) return pointA;

                        var d = ab.dot(ab);
                        if (f > d) return pointB;

                        f = f / d;
                        var pointD = pointA.clone();
                        pointD.addScaledVector(ab, f);
                        return pointD;

                    }

                    var distance = Infinity;
                    var pointA = new THREE.Vector3();
                    var pointB = new THREE.Vector3();
                    var point = new THREE.Vector3();                   
                    var edgeIndex = [];
                    if(indexInfo)
                    {
                        positionsArray = positions.slice(indexInfo.positionStart,indexInfo.positionStart + indexInfo.positionCount);
                        edgeIndex= CLOUD.BuildEdge(positionsArray, indicesArray);
                    }
                    else
                    {
                        positionsArray = positions ;
                        edgeIndex = CLOUD.BuildEdge(geometry.attributes.position.array, geometry.index.array);
                    }
                    for (var i = 0; i < edgeIndex.length; i += 2) {

                        var _pointA = new THREE.Vector3(positionsArray[edgeIndex[i] * 3], positionsArray[edgeIndex[i] * 3 + 1], positionsArray[edgeIndex[i] * 3 + 2]);
                        _pointA.applyMatrix4(matrix);

                        var _pointB = new THREE.Vector3(positionsArray[edgeIndex[i + 1] * 3], positionsArray[edgeIndex[i + 1] * 3 + 1], positionsArray[edgeIndex[i + 1] * 3 + 2]);
                        _pointB.applyMatrix4(matrix);

                        var _point = pointToLine(_pointA, _pointB, intersectPosition);
                        var screenPos = _point.clone();
                        screenPos.applyMatrix4(projScreenMatrix);

                        var dx = (screenPos.x - mouse.x) * 0.5 * viewportSize.width;
                        var dy = (screenPos.y - mouse.y) * 0.5 * viewportSize.height;

                        var length = Math.sqrt(dx * dx + dy * dy);
                        if (length < distance) {
                            distance = length;
                            pointA.copy(_pointA);
                            pointB.copy(_pointB);
                            point.copy(_point);
                        }

                    }
                    positionsArray = null;
                    indicesArray = null;

                    if (distance < 5.0) {

                        if (scene.hasObjectGroup(CLOUD.ObjectGroupType.MEASUREPICKPLANE)) {
                            scene.removeObjectGroupByName(CLOUD.ObjectGroupType.MEASUREPICKPLANE);
                        }
                        pickLine = new Array();
                        pickLine.push(pointA);
                        pickLine.push(pointB);

                        pickPoint = point.clone();

                    }
                    else {

                        if (CLOUD.GlobalData.MeasureHighlightPlane) {

                            indices = geometry.index.array;

                            var inverseMatrix = new THREE.Matrix4();
                            inverseMatrix.getInverse(matrix);
                            var worldPosition = new THREE.Vector3(intersectPosition.x, intersectPosition.y, intersectPosition.z);
                            worldPosition.applyMatrix4(inverseMatrix);

                            var faceIndex = CLOUD.GetFaceIndex(positions, normals, indices, worldPosition, intersect.face.normal);

                            var faceGeometry = new THREE.BufferGeometry();
                            faceGeometry.setIndex(faceIndex);
                            faceGeometry.addAttribute('position', geometry.attributes.position, 3);
                            faceGeometry.addAttribute('normal', geometry.attributes.normal, 3);

                            var wireframeIndex = CLOUD.BuildEdge(positions, faceIndex);
                            var wireframeGeometry = new THREE.BufferGeometry();
                            wireframeGeometry.setIndex(wireframeIndex);
                            wireframeGeometry.addAttribute('position', geometry.attributes.position, 3);

                            if (scene.hasObjectGroup(CLOUD.ObjectGroupType.MEASUREPICKPLANE)) {
                                scene.removeObjectGroupByName(CLOUD.ObjectGroupType.MEASUREPICKPLANE);
                            }

                            var group = scene.getOrCreateObjectGroup(CLOUD.ObjectGroupType.MEASUREPICKPLANE, {priority: 1, globalSpace: true});
                            var faceMesh = new THREE.Mesh(faceGeometry, new THREE.MeshBasicMaterial( {color: 0x11DAB7, opacity: 0.1, transparent: true} ));
                            faceMesh.applyMatrix(intersect.object.matrix);
                            group.add(faceMesh);

                            var lineMesh = new THREE.LineSegments(wireframeGeometry, new THREE.LineBasicMaterial( {color: 0x11DAB7} ));
                            lineMesh.applyMatrix(intersect.object.matrix);
                            group.add(lineMesh);

                            group.updateMatrixWorld(true);

                            cameraControl.updateHighlight();
                            
                        }
                        
                        pickPlane = true;

                    }

                }
                
                if (pick) {
                    pickPointOut.copy(pickPoint);
                }
                dispatchMeasureEvent(pickPoint, pickLine, pickPlane);

            }
            else {
                
                if (scene.hasObjectGroup(CLOUD.ObjectGroupType.MEASUREPICKPLANE)) {
                    scene.removeObjectGroupByName(CLOUD.ObjectGroupType.MEASUREPICKPLANE);
                }
                
                dispatchMeasureEvent(null, null, false);
            }

        });

    },

    handleMouseHover: function (event) {

        if (!this._canPick()) {
            return;
        }

        var cameraControl = this.cameraControl;
        var sceneState = cameraControl.viewer.modelManager.sceneState;
        var scope = this;

        // No global hover and no 3d markup, don't do hover test
        if((!CLOUD.GlobalData.Hover) &&
            !(scope.scene.hasObjectGroup(CLOUD.ObjectGroupType.MARKER3D))) {
            return;
        }

        var canvasXY = cameraControl.screenToCanvas(event.clientX, event.clientY);

        function dispatchHoverEvent(intersect, selectable) {
            var modelManager = cameraControl.viewer.modelManager;

            if (intersect != null) {
                scope.scene.intersectToWorld(intersect);
            }

            modelManager.dispatchEvent({
                type: CLOUD.EVENTS.ON_HOVER_PICK,
                event: event, // add
                canvasPos: {x: canvasXY.x, y: canvasXY.y}, // adjust
                intersectInfo: intersect ? {
                    selectedObjectId: intersect.userId,
                    objectType: intersect.objectType,
                    selectable: selectable,
                    modelId: intersect.databagId,
                    worldPosition: intersect.worldPosition,
                    worldBoundingBox: intersect.worldBoundingBox,
                    point: intersect.point,
                    innnerDebugging: intersect.innnerDebugging
                } : null
            });
        }

        var screenPos = new THREE.Vector2(event.clientX, event.clientY);
        var intersectContext = cameraControl.getIntersectContext(screenPos);

        // 如果禁用了全局hover，其实只需要遍历hover group，现在的方案，每次鼠标滑动都pick会影响效率！
        cameraControl.intersector.pick(intersectContext, function (intersect) {

            // 取消 hover
            function hoverOff(intersect) {

                switch (intersect.objectType) {

                    case CLOUD.PICKABLETYPE.Marker3d:
                        intersect.object.setAttributeSize(intersect.index, intersect.currentSize);
                        break;
                    default:
                        sceneState.clearHover();
                        break;

                }

            }

            // hover 构件
            function hoverOver(intersect) {

                switch (intersect.objectType) {

                    case CLOUD.PICKABLETYPE.Marker3d:
                        var node = intersect.object;
                        intersect.currentSize = node.getAttributeSize(intersect.index);
                        node.setAttributeSize(intersect.index, Math.floor(intersect.currentSize * 1.5));
                        break;
                    default:

                        if (CLOUD.GlobalData.EnableRenderPass) {
                            sceneState.setHoverId(intersect.object.originalId);
                        }
                        else {
                            sceneState.setHoverId(intersect.userId);
                        }
                        break;

                }

            }

            if (intersect) {

                // BIMFACEDM-3331: 将构件Hover与三维标签Hover独立控制
                var hover = CLOUD.GlobalData.Hover || intersect.hoverEnabled;

                if (scope.lastIntersected) {

                    if (scope.lastIntersected.userId != intersect.userId) 
                        hoverOff(scope.lastIntersected);

                    // TODO: refector hover among different drawable (3d markup, 3d elements ...)
                    // Defect tmp fix: hover from markup to 3d primitives,
                    // while the primitives hover is off. the markup's tool tip
                    // does not disappear.
                    if(scope.lastIntersected.hoverEnabled) {
                        dispatchHoverEvent(null);
                    }

                }

                if (hover) {

                    if (!scope.lastIntersected || scope.lastIntersected.userId != intersect.userId) {
                        hoverOver(intersect);
                        scope.lastIntersected = intersect;
                    }
                    dispatchHoverEvent(intersect, true);

                }

                cameraControl.updateHighlight();   // 名字不太合适

            }
            else {

                if (scope.lastIntersected) {

                    hoverOff(scope.lastIntersected);
                    scope.lastIntersected = null;

                    dispatchHoverEvent(null);
                    cameraControl.updateHighlight();

                }

            }

        });

    },

    _canPick: function () {

        // 数据没有准备好，不能pick
        if (this.cameraControl.viewer.modelManager.hasModelDataReady()) {
            return true;
        }

        return false;
    }
};



