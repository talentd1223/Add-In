CLOUD.NormalEditor = function (name, cameraControl) {
	
    CLOUD.BaseEditor.call(this, name, cameraControl);

    this.oldMouseX = -1;
    this.oldMouseY = -1;

    this.rotatePivot = null;

	this._rotateStart = new THREE.Vector2();
    this._rotateEnd = new THREE.Vector2();
    this._rotateDelta = new THREE.Vector2();
	this._lastTrackingPoint = null;
	
	this.rotateSpeed = 1.0;
	
	this._dollyStart = new THREE.Vector2();
    this._dollyEnd = new THREE.Vector2();
    this._dollyDelta = new THREE.Vector2();
    this._dollyCenter = new THREE.Vector2();
	
	this.zoomSpeed = Math.pow(0.95, 0.2);
	
	this._panStart = new THREE.Vector2();
    this._panEnd = new THREE.Vector2();
    this._panDelta = new THREE.Vector2();
    this._pan = new THREE.Vector3(); // tmp
    this._worldDimension = new THREE.Vector2();

    this.pickHelper = new CLOUD.PickHelper(cameraControl);
    this.intersectOfMouseDown = null;

    this.timeId = null;
    this.longTapFlag = false;

    if (CLOUD.Utils.isMobileDevice()) {
        this.selectPad = new CLOUD.SelectPad(this);
    } else {
        this.selectPad = null;
    }

    this.startPt = new THREE.Vector2();
    
    var scope = this;
    this.longTap = function () {
        scope.longTapFlag = true;
        CLOUD.Logger.log("long tap");

        if (scope.selectPad) {
            scope.selectPad.showOverlay(scope.startPt);
        }
    };

    this._reqid = 0;
    this._animateBinded = this._animate.bind(this);
    this._clock = new THREE.Clock();

    this._moving = false;
};

CLOUD.NormalEditor.prototype = Object.create(CLOUD.BaseEditor.prototype);
CLOUD.NormalEditor.prototype.constructor = CLOUD.NormalEditor;

CLOUD.NormalEditor.prototype.destroy = function (){

    CLOUD.BaseEditor.prototype.destroy.call(this);

    this.pickHelper.destroy();
    this.pickHelper = null;

    this.intersectOfMouseDown = null;

    if (this.selectPad) {
        this.selectPad = null;
    }

    this.timeId = null;

};

CLOUD.NormalEditor.prototype.beginPan = function (cx, cy) {
	this._panStart.set(cx, cy);

	// 根据当前鼠标点获得世界坐标系中的宽高
	this._worldDimension = this.getWorldDimension(cx, cy);
};

CLOUD.NormalEditor.prototype.processMouseDown = function (event) {

    this.oldMouseX = event.clientX;
    this.oldMouseY = event.clientY;

    var cameraControl = this.cameraControl;

    this.intersectOfMouseDown = null;
    event.preventDefault();

    var editorMode = "";
    if (event.button === this.mouseButtons.ORBIT) {

        if (CLOUD.EditorConfig.NoRotate)
            return;

        this.rotatePivot = cameraControl.calculatePivot(CLOUD.EditorConfig.RotatePivotMode, {x:event.clientX, y: event.clientY});
        //cameraControl.beginRotate(event.clientX, event.clientY);
		
		this.state = this.StateType.ROTATE;
        this._rotateStart.set(event.clientX, event.clientY);

        // 获得追踪点
        this._lastTrackingPoint = null;
        editorMode = CLOUD.EditorMode.ORBIT;

    } else if (event.button === this.mouseButtons.ZOOM) {

        if (CLOUD.EditorConfig.NoZoom) {
            return;
        }

        //cameraControl.beginZoom(event.clientX, event.clientY);
		this.state = this.StateType.DOLLY;
        this._dollyStart.set(event.clientX, event.clientY);

        editorMode = CLOUD.EditorMode.ZOOM;

    } else if (event.button === this.mouseButtons.PAN || event.button === this.mouseButtons.PAN2) {

        if (CLOUD.EditorConfig.NoPan) {
            return;
        }

        //cameraControl.beginPan(event.clientX, event.clientY);
        this._panStart.set(event.clientX, event.clientY);

        // 根据当前鼠标点获得世界坐标系中的宽高
        this._worldDimension = cameraControl.getWorldDimension(event.clientX, event.clientY);

        this.state = this.StateType.PAN;

        this.intersectOfMouseDown = cameraControl.getLastIntersect();
        editorMode = CLOUD.EditorMode.PAN;
    }
    // Application is listening and want some UI icon updating.
    this.dispatchEvent({type: CLOUD.EVENTS.ON_EDITOR_BEGIN, name: editorMode, editor: this.name});
};

CLOUD.NormalEditor.prototype.processMouseMove = function (event) {

    var cameraControl = this.cameraControl;

    event.preventDefault();

    //CLOUD.Logger.log("[CloudOrbitEditor.onMouseMove][mouse.clientXY(" + event.clientX + "," + event.clientY + "),mouse.offsetXY(" + event.offsetX + "," + event.offsetY + ")]");

    // 当鼠标移动到其他元素上时，event.offsetX, event.offsetY获得的是鼠标在其他元素区域里的相对坐标，
    // 会造成模型跳变，所以传入event.clientX, event.clientY，根据当前父元素节点位置计算鼠标的真实偏移量
    //cameraControl.process(event.clientX, event.clientY, true);

    switch (this.state) {
        case this.StateType.ROTATE:
            this._rotateEnd.set(event.clientX, event.clientY);
            this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart);

            if (this._rotateDelta.x == 0 && this._rotateDelta.y == 0)
                return;

            this._rotateStart.copy(this._rotateEnd);

            cameraControl.processRotate(this._rotateDelta, this.rotatePivot);

            break;
        case  this.StateType.DOLLY:
            this._dollyEnd.set(event.clientX, event.clientY);
            this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);
            if (this._dollyDelta.x === 0 && this._dollyDelta.y === 0)
                return;

            var scale;
            if (this._dollyDelta.y > 0) {
                //CLOUD.Logger.log("dollyOut");
                //_scope.dollyOut();
                scale = this.zoomSpeed;
            } else {
                //CLOUD.Logger.log("dollyIn");
                //_scope.dollyIn();
                scale = 1.0 / this.zoomSpeed;
            }

            //_scope.dollyByCenter();
			this.cameraControl.adjustCameraForDolly(scale, null);

            this._dollyStart.copy(this._dollyEnd);

            break;
        case this.StateType.PAN:

            this._panEnd.set(event.clientX, event.clientY);
            this._panDelta.subVectors(this._panEnd, this._panStart);
            if (this._panDelta.x == 0 && this._panDelta.y == 0)
                return;

            this.cameraControl.panOnWorld(this._panStart, this._panEnd, this._pan, this._worldDimension);
            //scope.pan( panDelta.x, panDelta.y );

            this.cameraControl.adjustCameraForPan(this._pan);
            this._panStart.copy(this._panEnd);

            break;
        case this.StateType.NONE:
        default:
            break;
    }

    if (this.state !== this.StateType.NONE)
        this.cameraControl.update(true);

};

CLOUD.NormalEditor.prototype.processMouseUp = function (event) {

    if (this.state === this.StateType.NONE) {
        return false;
    }
	
    this.intersectOfMouseDown = null;

    var cameraControl = this.cameraControl;
	
	// TODO: FIXME: should still process operation, otherwise the last operation is skipped
	//

    // 直接使用up来模拟click
    if (this.oldMouseX !== event.clientX || this.oldMouseY !== event.clientY) {
        cameraControl.update(true);
    } // else we think this is a click event, why not update the view? wun-c

	this.state = this.StateType.NONE;
    this.rotatePivot = null;
	
	cameraControl.endOperation();

    // Application is listening and want some UI icon updating.
    var editorMode = "";
    if (event.button === this.mouseButtons.ORBIT) {
        editorMode = CLOUD.EditorMode.ORBIT;
    }else if (event.button === this.mouseButtons.ZOOM) {
        editorMode = CLOUD.EditorMode.ZOOM;
    }else if (event.button === this.mouseButtons.PAN || event.button === this.mouseButtons.PAN2) {
        editorMode = CLOUD.EditorMode.PAN;
    }
    this.dispatchEvent({type: CLOUD.EVENTS.ON_EDITOR_END, name: editorMode , editor: this.name});
    return true;
};

// TODO: refactor this method. All there kinds of Editor have similar code
CLOUD.NormalEditor.prototype.processMouseWheel = function (event) {

    var cameraControl = this.cameraControl;

    if (CLOUD.EditorConfig.NoZoom)
        return;

    event.preventDefault();
    event.stopPropagation();

    //滚轮操作在浏览器中要考虑兼容性
    // 五大浏览器（IE、Opera、Safari、Firefox、Chrome）中Firefox 使用detail，其余四类使用wheelDelta；
    var delta = 0;

    if (event.wheelDelta) {
        delta = event.wheelDelta;
    } else if (event.detail) {
        delta = -event.detail * 40;
    }

    if (Math.abs(delta) > 720) delta = delta > 0 ? 720 : -720;

    delta *= this.wheelZoomFactor; // 0.0005

    if (CLOUD.EditorConfig.ReverseWheelDirection) {
        delta *= -1;
    }

    cameraControl.zoom(delta, event.clientX, event.clientY);
    cameraControl.delayHandle();
};

CLOUD.NormalEditor.prototype.processKeyDown = function (event) {

    if (CLOUD.EditorConfig.NoKey || CLOUD.EditorConfig.NoPan)
        return;

    var cameraControl = this.cameraControl;
    // cameraControl.delayHandle();

    var immediateUpdating;
    if (CLOUD.GlobalData.BatchMergeEnabled) {
        if (!this.animationStarted) {
            this.animationStarted = true;
            this._start();
        }
        immediateUpdating = false;
    } else {
        immediateUpdating = true;
        cameraControl.delayHandle();
    }

    this._moving = true;

    var needUpdate = false;
    var movementSpeed = this.movementSpeed * CLOUD.EditorConfig.MovementSpeedRate;
    var keyPanSpeed = this.keyPanSpeed * CLOUD.EditorConfig.MovementSpeedRate;

    switch (event.keyCode) {
        case CLOUD.Keys.ZERO:
            this.keyPanSpeed = cameraControl.defaultKeyPanSpeed;
            this.movementSpeed = cameraControl.defaultMovementSpeed;
            break;

        case CLOUD.Keys.PLUS:
            this.keyPanSpeed *= 1.1;
            this.movementSpeed *= 1.1;
            break;

        case CLOUD.Keys.SUB:
            this.keyPanSpeed *= 0.9;

            if (this.keyPanSpeed < this.minKeyPanSpeed) {
                this.keyPanSpeed = this.minKeyPanSpeed;
            }

            this.movementSpeed *= 0.9;

            if (this.movementSpeed < this.minMovementSpeed) {
                this.movementSpeed = this.minMovementSpeed;
            }
            break;

        case CLOUD.Keys.Q:
            cameraControl.pan(0, keyPanSpeed);
            needUpdate = true;
            break;

        case CLOUD.Keys.E:
            cameraControl.pan(0, -keyPanSpeed);
            needUpdate = true;
            break;

        case CLOUD.Keys.LEFT:
        case CLOUD.Keys.A:
            cameraControl.pan(keyPanSpeed, 0);
            needUpdate = true;
            break;

        case CLOUD.Keys.RIGHT:
        case CLOUD.Keys.D:
            cameraControl.pan(-keyPanSpeed, 0);
            needUpdate = true;
            break;

        case CLOUD.Keys.UP:
        case CLOUD.Keys.W:
            cameraControl.moveStraight(movementSpeed, !event.shiftKey);
            needUpdate = true;
            break;

        case CLOUD.Keys.DOWN:
        case CLOUD.Keys.S:
            cameraControl.moveStraight(-movementSpeed, !event.shiftKey);
            needUpdate = true;
            break;
    }

    if (needUpdate && immediateUpdating) {
        cameraControl.update(true);
    }
};

CLOUD.NormalEditor.prototype.processKeyUp = function (event) {

    if (CLOUD.EditorConfig.NoKey || CLOUD.EditorConfig.NoPan ) return;

    switch (event.keyCode) {
        case CLOUD.Keys.ESC:
            // TODO: move sceneState to Scene class
            // 层次太深了！！！
            this.cameraControl.viewer.modelManager.sceneState.clearSelection();
            this.pickHelper.lastPickedUserId = undefined;
            this.cameraControl.updateView(true);  
            break;
        default :
            break
    }
};

CLOUD.NormalEditor.prototype.processTouchstart = function (event) {

    this.startPt.set(event.touches[0].clientX, event.touches[0].clientY);

    if (this.timeId) {
        clearTimeout(this.timeId);
    }

    var scope = this;
    scope.timeId = setTimeout(scope.longTap, 400);

    if (this.selectPad) {
        this.selectPad.hideOverlay();
    }

    switch (event.touches.length) {

        case 1:    // one-fingered touch: rotate
            if (CLOUD.EditorConfig.NoRotate)
                return;
            //handleTouchStartRotate(event);
            this._rotateStart.set(event.touches[0].clientX, event.touches[0].clientY);
            this.state = this.StateType.ROTATE;

            break;

        case 2:    // two-fingered touch: dolly and pan
            if (!CLOUD.EditorConfig.NoZoom) {
                //handleTouchStartDolly(event);
                var dx = event.touches[0].clientX - event.touches[1].clientX;
                var dy = event.touches[0].clientY - event.touches[1].clientY;

                this._dollyStart.set(0, Math.sqrt(dx * dx + dy * dy));
            }

            if (!CLOUD.EditorConfig.NoPan){
                //handleTouchStartPan(event);
                var cx = (event.touches[0].clientX + event.touches[1].clientX) * 0.5;
                var cy = (event.touches[0].clientY + event.touches[1].clientY) * 0.5;
                this._panStart.set(cx, cy);
            }

            break;

        default:
            this.state = this.StateType.NONE;
            break;
    }
};

CLOUD.NormalEditor.prototype.processTouchmove = function (event) {

    if (this.timeId) {
        clearTimeout(this.timeId);
    }

    var cameraControl = this.cameraControl;

    event.preventDefault();
    //event.stopPropagation();

    //cameraControl.touchMoveHandler(event);
    switch (event.touches.length) {
        case 1: // one-fingered touch: rotate

            //handleTouchMoveRotate(event);
			if (CLOUD.EditorConfig.NoRotate)
                return;
			
            this._rotateEnd.set(event.touches[0].clientX, event.touches[0].clientY);
            this._rotateDelta.subVectors(this._rotateStart, this._rotateEnd);

            var clientSize = this.cameraControl.getClientSize();

            var thetaDelta = 2 * Math.PI * this._rotateDelta.x / clientSize.x * this.rotateSpeed;
            var phiDelta = 2 * Math.PI * this._rotateDelta.y / clientSize.y * this.rotateSpeed;

            cameraControl.touchUpdateRotation(thetaDelta, phiDelta);

            this._rotateStart.copy(this._rotateEnd);

            break;

        case 2: // two-fingered touch: dolly or pan

            cameraControl.clearTouchRotateState();

            if (!CLOUD.EditorConfig.NoZoom) {

                var dx = event.touches[0].clientX - event.touches[1].clientX;
                var dy = event.touches[0].clientY - event.touches[1].clientY;

                var distance = Math.sqrt(dx * dx + dy * dy);
                this._dollyEnd.set(0, distance);
                this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);

                if (Math.abs(this._dollyDelta.y) > 3) {

                    var scale;
                    if (this._dollyDelta.y > 0) {
                        scale = 1.0 / Math.pow(this.zoomSpeed, this._dollyDelta.y * 0.5);
                    }
                    else if (this._dollyDelta.y < 0) {
                        scale = Math.pow(this.zoomSpeed, -this._dollyDelta.y * 0.5);
                    }
                    console.log(this._dollyDelta.y);
                    this._dollyStart.copy(this._dollyEnd);

                    var dollyCenterX = (event.touches[0].clientX + event.touches[1].clientX) * 0.5;
                    var dollyCenterY = (event.touches[0].clientY + event.touches[1].clientY) * 0.5;

                    cameraControl.touchDolly(dollyCenterX, dollyCenterY, scale);

                    this.state = this.StateType.DOLLY;
                    
                }

            }
            if (!CLOUD.EditorConfig.NoPan) {

                //handleTouchMovePan(event);
                var cx = (event.touches[0].clientX + event.touches[1].clientX) * 0.5;
                var cy = (event.touches[0].clientY + event.touches[1].clientY) * 0.5;
                this._panEnd.set(cx, cy);
                this._panDelta.subVectors(this._panEnd, this._panStart);

                if (Math.abs(this._panDelta.x) < 3 && Math.abs(this._panDelta.y) < 3) return;

                this._worldDimension = cameraControl.getWorldDimension(cx, cy);
                cameraControl.panOnWorld(this._panStart, this._panEnd, this._pan, this._worldDimension);
                cameraControl.adjustCameraForPan(this._pan);

                this._panStart.copy(this._panEnd);

                this.state = this.StateType.PAN;

            }

            break;

        default:
            break;
    }

    cameraControl.touchUpdate();
};

CLOUD.NormalEditor.prototype.processTouchend = function (event) {

    if (this.timeId) {
        clearTimeout(this.timeId);
    }

    if (this.longTapFlag) {
        this.longTapFlag = false;
        event.preventDefault();
    }

    var cameraControl = this.cameraControl;
    switch (event.touches.length) {
        case 0:
            this.state = this.StateType.NONE;
            cameraControl.touchEndHandler(event);
            break;

        case 1:
            if (CLOUD.EditorConfig.NoRotate)
                return;

            this._rotateStart.set(event.touches[0].clientX, event.touches[0].clientY);
            this.state = this.StateType.ROTATE;
            break;

        default:
            break;
    }

};

CLOUD.NormalEditor.prototype.processHover = function (event) {

    this.pickHelper.handleMouseHover(event);

};

CLOUD.NormalEditor.prototype.moveTo = function (direction) {

    if (direction === undefined) {
        return;
    }

    var cameraControl = this.cameraControl;

    if (CLOUD.EditorConfig.NoKey || CLOUD.EditorConfig.NoPan) return;

    var movementSpeed = this.movementSpeed * CLOUD.EditorConfig.MovementSpeedRate;
    var keyPanSpeed = this.keyPanSpeed * CLOUD.EditorConfig.MovementSpeedRate;

    var enumMoveDirection = CLOUD.MoveDirection;

    switch (direction) {

        case enumMoveDirection.FORWARD:
            cameraControl.moveForward(movementSpeed, true);
            break;
        case enumMoveDirection.BACK:
            cameraControl.moveBackward(movementSpeed, true);
            break;

        case enumMoveDirection.LEFT:
            cameraControl.pan(keyPanSpeed, 0);
            break;

        case enumMoveDirection.RIGHT:
            cameraControl.pan(-keyPanSpeed, 0);
            break;

        case enumMoveDirection.UP:
            cameraControl.pan(0, keyPanSpeed);
            break;

        case enumMoveDirection.DOWN:
            cameraControl.pan(0, -keyPanSpeed);
            break;
        default:
            direction = enumMoveDirection.NONE;
            break;

    }

    if (direction !== enumMoveDirection.NONE) {
        cameraControl.update(true, true);
    }

};

// 批次合并在移动中存在卡顿，采用动画可以改善体验
CLOUD.NormalEditor.prototype._updateMove = function () {
    if (this._moving) {
        this._moving = false;
        this.cameraControl.update(true);
    }
};

CLOUD.NormalEditor.prototype._animate = function () {
    this._reqid = requestAnimationFrame(this._animateBinded);
    this._updateMove();
};

CLOUD.NormalEditor.prototype._start = function () {
    this._animate();
};

CLOUD.NormalEditor.prototype._stop = function () {
    cancelAnimationFrame(this._reqid);
};

// Editor 模式可能在批次合并策略和增量策略选择前就设置好了，
// CLOUD.GlobalData.BatchMergeEnabled状态还未确定，这里启动动画会无效
// CLOUD.NormalEditor.prototype.onEnter = function () {
//     if (CLOUD.GlobalData.BatchMergeEnabled) {
//         this._start();
//     }
// };

CLOUD.NormalEditor.prototype.onExit = function () {
    if (CLOUD.GlobalData.BatchMergeEnabled) {
        if (this.animationStarted) {
            this._stop();
            this.animationStarted = false;
        }

    }
};
