CLOUD.FillClipPlaneTool = function (viewer) {

    CLOUD.EditTool.call(this, CLOUD.EditToolMode.CLIP_FILL);

    this.viewer = viewer;
	this.scene = viewer.getScene();
    this.enablePick = false;
    this.rotX = true;

    this.cameraControl = viewer.cameraControl;

    this.startPt = new THREE.Vector2();


    var fillClipPlane = this.scene.getFillClipPlane();
    fillClipPlane.updateClippingParams = function (uniforms) {
        if (uniforms.iClipPlane.value == 0) {
            viewer.renderer.clippingPlanes = Object.freeze([]);
        }
        else {
            var planes = [new THREE.Plane()];
            var v = uniforms.vClipPlane.value[0];
            var plane = planes[0];
            plane.setComponents(-v.x, -v.y, -v.z, -v.w);
            plane.normalize();

            viewer.renderer.clippingPlanes = planes;
        }
    };

    fillClipPlane.init();

    this.planeDistance = 0;

    this.offsetSpeed = 0.02;

    // var scope = this;
    // this.pickHelper = new CLOUD.PickHelper(this.scene, this.cameraControl);

    this.toggle = function (enable, visible) {
        fillClipPlane.enable(enable, visible);
        fillClipPlane.update();
    };

    this.visible = function (enable) {
        fillClipPlane.visible = enable;
        fillClipPlane.update();
    };

    this.rotatable = function (enable) {
        fillClipPlane.rotatable = enable;
        fillClipPlane.update();
    };

    this.hit = function () {
        return fillClipPlane.hit;
    };

    // this.store = function () {
    //     return clipPlanes.store();
    // };

    // this.restore = function (clipPlanesInfo) {
    //     clipPlanes.restore(clipPlanesInfo);
    // };

    // this.reset = function () {
    //     clipPlanes.reset();
    // };

    this.pointToScreen = function (point) {

        var camera = this.cameraControl.camera;
        var viewProjMatrix = new THREE.Matrix4();
        viewProjMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

        var point4 = new THREE.Vector4(point.x, point.y, point.z, 1.0);
        point4.applyMatrix4(viewProjMatrix);

        var screen = new THREE.Vector2();
        screen.x = (point4.x / point4.w + 1.0) / 2;
        screen.y = 1 - (point4.y / point4.w + 1.0) / 2;

        var dim = this.cameraControl.getContainerDimensions();

        screen.x = screen.x * dim.width + dim.left;
        screen.y = screen.y * dim.height + dim.top;

        return screen;
    };

    this.getPlaneDistanceInScreen = function () {

        if (this.selectIndex == null) return null;

        if (this.selectIndex < 2) {
            var right = clipPlanes.center.clone();
            var left = clipPlanes.center.clone();

            right.x -= clipPlanes.cubeSize.x;
            left.x += clipPlanes.cubeSize.x;

            var rightScreen = this.pointToScreen(right);
            var leftScreen = this.pointToScreen(left);

            return rightScreen.x - leftScreen.x;
        }
        else {
            var top = clipPlanes.center.clone();
            var bottom = clipPlanes.center.clone();

            bottom.y -= clipPlanes.cubeSize.y;
            top.y += clipPlanes.cubeSize.y;

            var bottomScreen = this.pointToScreen(bottom);
            var topScreen = this.pointToScreen(top);

            return bottomScreen.y - topScreen.y;
        }
    };

    this.getPickPoint = function (cx, cy) {

        var camera = this.cameraControl.camera;
        var canvasContainer = this.cameraControl.getContainerDimensions();
        // 规范化开始点
        var canvasX = cx - canvasContainer.left;
        var canvasY = cy - canvasContainer.top;
        // 规范化到[-1, 1]
        var normalizedX = (canvasX / canvasContainer.width) * 2.0 - 1.0;
        var normalizedY = ((canvasContainer.height - canvasY) / canvasContainer.height) * 2.0 - 1.0;

        var raycaster = new CLOUD.Raycaster();
        raycaster.setFromCamera(new THREE.Vector2(normalizedX, normalizedY), camera);

        var point = raycaster.ray.intersectPlane(this.plane);
        return point;
    };

    this._isVisible = function () {
        return fillClipPlane.visible;
    };

    this.isRotate = function () {
        return fillClipPlane.rotatable;
    };

    this.offset = function (offset) {
        fillClipPlane.offset(offset);
    };

    //设置切面的偏移量，-250至250，默认为0
    this.setOffset = function (offset) {
        fillClipPlane.setOffset(offset);
    };

    this.rotate = function (cx, cy) {
        if (this.rotX) {
            fillClipPlane.rotX(cy / 180 * Math.PI * 0.1);
        } 
        else {
            fillClipPlane.rotY(cx / 180 * Math.PI * 0.1);
        }
    };

    //设置切面的法线方向，(0, 1, 2, 3, 4, 5)分别对应模型空间(X, -X, Y, -Y, Z, -Z)，默认值为3
    this.changeNormal = function(index) {
        fillClipPlane.changeNormal(index);
    };

    this.update = function (camera) {
        fillClipPlane.update(camera);
    };

    this.cancelHighLight = function () {
        fillClipPlane.cancelHighLight();
    };

    this.highLight = function () {
        fillClipPlane.highLight();
    };

    this.store = function () {
        return fillClipPlane.store();
    };

    this.restore = function (info) {
        fillClipPlane.restore(info);
    };

    this.setProcess = function (process) {
        fillClipPlane.setProcess(process);
    };

    this.getProcess = function () {
        return fillClipPlane.getProcess();
    };
    
};

CLOUD.FillClipPlaneTool.prototype = Object.create(CLOUD.EditTool.prototype);
CLOUD.FillClipPlaneTool.prototype.constructor = CLOUD.FillClipPlaneTool;

CLOUD.FillClipPlaneTool.prototype.destroy = function () {
    this.cameraControl = null;
    this.normal = null;
    this.plane = null;
    this.pickHelper = null;
    this.scene = null;
    this.viewer = null;
};

CLOUD.FillClipPlaneTool.prototype.onExit = function () {
    this.toggle(false,false);
};

CLOUD.FillClipPlaneTool.prototype.processMouseDown = function (event) {

    this.startPt.set(event.clientX, event.clientY);

    if (!this.enablePick && event.button === THREE.MOUSE.LEFT) {
        var ray = this.cameraControl.getRaycaster(event.clientX, event.clientY);
        var fillClipPlane = this.scene.getFillClipPlane();
        fillClipPlane.hitTest(ray);

        if (this.hit()) {
            this.highLight();
            this.cameraControl.needUpdateRenderList(true);
            this.cameraControl.update(true);

            return true;
        }
    }

    return CLOUD.EditTool.prototype.processMouseDown(this, event);
};

CLOUD.FillClipPlaneTool.prototype.processMouseUp = function (event) {
    
    this.planeDistance = 0;

    if (this.enablePick && event.button === THREE.MOUSE.LEFT) {

        if (this.startPt.x == event.clientX && this.startPt.y == event.clientY) {
            this.pickHelper.click(event);
        } else {
            var allowRectPick = event.shiftKey || event.ctrlKey || event.altKey;
            if (allowRectPick) {

                this.endPt.set(event.clientX, event.clientY);

                var state = CLOUD.OPSELECTIONTYPE.Clear;

                if (event.ctrlKey) {
                    state = CLOUD.OPSELECTIONTYPE.Add;
                } else if (event.altKey) {
                    state = CLOUD.OPSELECTIONTYPE.Remove;
                }

                var scope = this;
                this.scene.pickByRect(this.frustum, state, function () {
                    scope.pickHelper.notifySelectionChanged(null, 0, event);
                });
                this.cameraControl.updateView(true);

                return true;
            }
        }
    }

    this.cameraControl.needUpdateRenderList(true);
    this.cancelHighLight();
    this.cameraControl.update(true);

    return CLOUD.EditTool.prototype.processMouseUp(this, event);
};


CLOUD.FillClipPlaneTool.prototype.processMouseMove = function (event) {

    var allowRectPick = event.shiftKey || event.ctrlKey || event.altKey;
    if (allowRectPick && event.button === THREE.MOUSE.LEFT) {
        this.endPt.set(event.clientX, event.clientY);
        this.updateFrustum(true);
        return true;
    }

    if (event.button === THREE.MOUSE.LEFT && this.hit()) {
        if (!this.isRotate()) {

            var equalPt = event.clientX==this.startPt.x && event.clientY==this.startPt.y;
            if(!equalPt){
                var fillClipPlane = this.scene.getFillClipPlane();
                var planeInfo = fillClipPlane.getClipPlane();
                var offset = this.cameraControl.movePlane(planeInfo, event, this.startPt, false);
                if(offset != null){
                    fillClipPlane.offset(offset);
                }    
                this.startPt.set(event.clientX, event.clientY);      
            }
            
        } else {
            this.rotate(event.clientX - this.startPt.x, event.clientY - this.startPt.y);
            this.startPt.set(event.clientX, event.clientY);
        }
        this.cameraControl.update(true);
    }

    return CLOUD.EditTool.prototype.processMouseUp(this, event);
};

CLOUD.FillClipPlaneTool.prototype.processTouchstart = function (event) {

    this.startPt.set(event.touches[0].clientX, event.touches[0].clientY);
    if (!this.enablePick) {
        var ray = this.cameraControl.getRaycaster(event.touches[0].clientX, event.touches[0].clientY);
        var fillClipPlane = this.scene.getFillClipPlane();
        fillClipPlane.hitTest(ray);
    }

    if (this.hit()) {

        this.highLight();
        this.cameraControl.needUpdateRenderList(true);
        this.cameraControl.update(true);
        return true;

    }
    else {
        return CLOUD.EditTool.prototype.processTouchstart(this, event);
    }

};

CLOUD.FillClipPlaneTool.prototype.processTouchmove = function (event) {

    if (this.hit()) {

        if (!this.isRotate()) {

            var delta = 0;
            delta = event.touches[0].clientX - this.startPt.x;
            this.offset(delta * 1);
            this.startPt.set(event.touches[0].clientX, event.touches[0].clientY);

        } 
        else {

            this.rotate(event.touches[0].clientX - this.startPt.x, event.touches[0].clientY - this.startPt.y);
            this.startPt.set(event.touches[0].clientX, event.touches[0].clientY);

        }

        this.cameraControl.update(true);
        return true;

    }
    else {
        return CLOUD.EditTool.prototype.processTouchmove(this, event);
    }
    
};

CLOUD.FillClipPlaneTool.prototype.processTouchend = function (event) {

    if (this.enablePick) {

        this.onUpdateUI({visible: false});

        if (this.startPt.x == event.touches[0].clientX && this.startPt.y == event.touches[0].clientY) {
            this.pickHelper.click(event);
        }
        
    }

    this.cameraControl.needUpdateRenderList(true);
    this.cancelHighLight();
    this.cameraControl.update(true);

    return CLOUD.EditTool.prototype.processTouchmove(this, event);

};