CLOUD.WalkEditor = function (cameraControl) {

    CLOUD.BaseEditor.call(this, CLOUD.EditorMode.WALK, cameraControl);

    this.mouseButtons = {ORBIT: THREE.MOUSE.LEFT, PAN2: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT};

    this.pickHelper = new CLOUD.PickHelper(cameraControl);
    this.lastMousePoint = new THREE.Vector2();// 鼠标位置

    this._reqid = 0;
    this._animateBinded = this._animate.bind(this);
    this._clock = new THREE.Clock();

    this.moveState = {
        up: 0,
        down: 0,
        left: 0,
        right: 0,
        forward: 0,
        back: 0,
        pitchUp: 0,
        pitchDown: 0,
        yawLeft: 0,
        yawRight: 0,
        rollLeft: 0,
        rollRight: 0
    };
    //适配移动端
    this.startPt = new THREE.Vector2();
    this.timeId = null;
    this.rotateSpeed = 1.0;
    this._rotateStart = new THREE.Vector2();
    this._rotateEnd = new THREE.Vector2();
    this._rotateDelta = new THREE.Vector2();
    
    this._dollyStart = new THREE.Vector2();
    this._dollyEnd = new THREE.Vector2();
    this._dollyDelta = new THREE.Vector2();
    this._dollyCenter = new THREE.Vector2();
	
	this.zoomSpeed = Math.pow(0.95, 0.2);
	
	this._panStart = new THREE.Vector2();
    this._panEnd = new THREE.Vector2();
    this._panDelta = new THREE.Vector2();
    this._pan = new THREE.Vector3(); // tmp

    if (CLOUD.Utils.isMobileDevice()) {
        this.selectPad = new CLOUD.SelectPad(this);
    } else {
        this.selectPad = null;
    }
    this.moveVector = new THREE.Vector3(0, 0, 0);
    this.rotationVector = new THREE.Vector3(0, 0, 0);
    this.zoomDelta = 0;

    // 保存旋转点
    this.rotateStart = new THREE.Vector2();
    this.rotateEnd = new THREE.Vector2();
    this.rotateDelta = new THREE.Vector2(); // tmp variable
    this.firstRotate = true;
    this.dragLook = true;

    this.lockHeightEnabled = false; // 是否启用锁定高度
    this.isLockHeight = false;
    this.lockedHeight = 0;

    this.pickEnabled = false; // 是否允许pick

    // remark: 还没有处理其它editor,先在这里设置移动速度, 统一处理后在BaseEditor设置
    this.defaultMovementSpeed = 1500; // 移动速度 1.5m
    this.movementSpeed = this.defaultMovementSpeed;    // can be changed

};

CLOUD.WalkEditor.prototype = Object.create(CLOUD.BaseEditor.prototype);
CLOUD.WalkEditor.prototype.constructor = CLOUD.WalkEditor;

CLOUD.WalkEditor.prototype._animate = function () {

    this._reqid = requestAnimationFrame(this._animateBinded);
    this.updateWalkMove();

};

CLOUD.WalkEditor.prototype._start = function () {

    this._animate();

};

CLOUD.WalkEditor.prototype._stop = function () {

    cancelAnimationFrame(this._reqid);

};

CLOUD.WalkEditor.prototype._updateMovement = function () {

    this.moveVector.x = ( -this.moveState.left + this.moveState.right );

    if (this.isLockHeight) {
        this.moveVector.y = 0;
    } else {
        this.moveVector.y = ( -this.moveState.down + this.moveState.up );
    }

    this.moveVector.z = ( -this.moveState.forward + this.moveState.back );

};

CLOUD.WalkEditor.prototype._updateRotation = function () {

    if (CLOUD.EditorConfig.LockAxisZ) {
        this.rotationVector.x = 0;
    } else {
        this.rotationVector.x = ( -this.moveState.pitchDown + this.moveState.pitchUp );
    }

    this.rotationVector.y = ( -this.moveState.yawRight + this.moveState.yawLeft );
    this.rotationVector.z = ( -this.moveState.rollRight + this.moveState.rollLeft );

};

CLOUD.WalkEditor.prototype._doRotate = function (delta) {

    var container = this.cameraControl.getContainerDimensions();
    var halfWidth = container.width / 2;
    var halfHeight = container.height / 2;

    this.moveState.yawLeft = -delta.x / halfWidth;
    this.moveState.pitchDown = delta.y / halfHeight;

    this._updateRotation();

};

CLOUD.WalkEditor.prototype.destroy = function () {

    CLOUD.BaseEditor.prototype.destroy.call(this);

    this.rotateStart = null;
    this.rotateEnd = null;
    this.rotateDelta = null;

    this.pickHelper.destroy();
    this.pickHelper = null;
    this.lastMousePoint = null;

    this._clock = null;

};

CLOUD.WalkEditor.prototype.processMouseDown = function (event) {

    event.preventDefault();
    event.stopPropagation();

    this.lastMousePoint.set(event.clientX, event.clientY);
    this.firstRotate = false;

    if (event.button === this.mouseButtons.ORBIT) {

        if (CLOUD.EditorConfig.NoRotate) {
            return;
        }

        this.rotateStart.set(event.clientX, event.clientY);
        this.state = this.StateType.ROTATE;
        this.dispatchEvent({type: CLOUD.EVENTS.ON_EDITOR_BEGIN, name: "look", editor: this.name});

    }

};

CLOUD.WalkEditor.prototype.processMouseUp = function (event) {

    event.preventDefault();
    event.stopPropagation();

    if (this.pickEnabled && event.button === THREE.MOUSE.LEFT) {

        if (Math.abs(this.lastMousePoint.x - event.clientX) < 2 && Math.abs(this.lastMousePoint.y - event.clientY) < 2) {
            this.state = this.StateType.NONE;
            this.pickHelper.click(event);
            return;
        }
    }

    if (this.state === this.StateType.ROTATE) {

        this.moveState.yawLeft = this.moveState.pitchDown = 0;
        this.dispatchEvent({type: CLOUD.EVENTS.ON_EDITOR_END, name: "look", editor: this.name});
    }

    this.state = this.StateType.NONE;

    return true;
};

CLOUD.WalkEditor.prototype.processMouseMove = function (event) {

    event.preventDefault();

    if (this.dragLook && this.state === this.StateType.ROTATE) {

        this.rotateEnd.set(event.clientX, event.clientY);
        this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
        this.rotateStart.copy(this.rotateEnd);

        this._doRotate(this.rotateDelta);
    }


};
CLOUD.WalkEditor.prototype.processTouchstart = function (event) {
    
    this.startPt.set(event.touches[0].clientX, event.touches[0].clientY);

    if (this.timeId) {
        clearTimeout(this.timeId);
    }

    var scope = this;
    scope.timeId = setTimeout(scope.longTap, 400);

    if (this.selectPad) {
        this.selectPad.hideOverlay();
    }

    switch (event.touches.length) {

        case 1:    
            if (CLOUD.EditorConfig.NoRotate)
                return;
            this._rotateStart.set(event.touches[0].clientX, event.touches[0].clientY);
            this.state = this.StateType.ROTATE;
            console.log(this._rotateStart);
            break;

        case 2:
        /*    
            if (!CLOUD.EditorConfig.NoZoom) {
                var dx = event.touches[0].clientX - event.touches[1].clientX;
                var dy = event.touches[0].clientY - event.touches[1].clientY;

                this._dollyStart.set(0, Math.sqrt(dx * dx + dy * dy));
            }
            */
            if (!CLOUD.EditorConfig.NoPan){
                var cx = (event.touches[0].clientX + event.touches[1].clientX) * 0.5;
                var cy = (event.touches[0].clientY + event.touches[1].clientY) * 0.5;
                this._panStart.set(cx, cy);
            }
            break;
        default:
            this.state = this.StateType.NONE;
            break;
    }
};

CLOUD.WalkEditor.prototype.processTouchmove = function (event) {
    
    if (this.timeId) {
        clearTimeout(this.timeId);
    }

    var cameraControl = this.cameraControl;

    event.preventDefault();
    
    switch (event.touches.length) {
        case 1: 
			if (CLOUD.EditorConfig.NoRotate)
                return;
			
            this._rotateEnd.set(event.touches[0].clientX, event.touches[0].clientY);
            this._rotateDelta.subVectors(this._rotateStart, this._rotateEnd);
            var clientSize = this.cameraControl.getClientSize();
            var thetaDelta = 2 * Math.PI * this._rotateDelta.x / clientSize.x * this.rotateSpeed;
            var phiDelta = 2 * Math.PI * this._rotateDelta.y / clientSize.y * this.rotateSpeed;

            cameraControl.touchUpdateRotation(thetaDelta, phiDelta);
            this._rotateStart.copy(this._rotateEnd);
            break;
        case 2:

            cameraControl.clearTouchRotateState();
            /*
            if (!CLOUD.EditorConfig.NoZoom) {

                var dx = event.touches[0].clientX - event.touches[1].clientX;
                var dy = event.touches[0].clientY - event.touches[1].clientY;

                var distance = Math.sqrt(dx * dx + dy * dy);
                this._dollyEnd.set(0, distance);
                this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);

                if (Math.abs(this._dollyDelta.y) > 3) {

                    var scale;
                    if (this._dollyDelta.y > 0) {
                        scale = 1.0 / Math.pow(this.zoomSpeed, this._dollyDelta.y * 0.5);
                    }
                    else if (this._dollyDelta.y < 0) {
                        scale = Math.pow(this.zoomSpeed, -this._dollyDelta.y * 0.5);
                    }
                    this._dollyStart.copy(this._dollyEnd);
                    var dollyCenterX = (event.touches[0].clientX + event.touches[1].clientX) * 0.5;
                    var dollyCenterY = (event.touches[0].clientY + event.touches[1].clientY) * 0.5;

                    cameraControl.touchDolly(dollyCenterX, dollyCenterY, scale);

                    this.state = this.StateType.DOLLY;
                }
            }
            */
            if (!CLOUD.EditorConfig.NoPan) {

                //handleTouchMovePan(event);
                var cx = (event.touches[0].clientX + event.touches[1].clientX) * 0.5;
                var cy = (event.touches[0].clientY + event.touches[1].clientY) * 0.5;
                this._panEnd.set(cx, cy);
                this._panDelta.subVectors(this._panEnd, this._panStart);

                if (Math.abs(this._panDelta.x) < 3 && Math.abs(this._panDelta.y) < 3) return;

                this._worldDimension = cameraControl.getWorldDimension(cx, cy);
                cameraControl.panOnWorld(this._panStart, this._panEnd, this._pan, this._worldDimension);
                cameraControl.adjustCameraForPan(this._pan);

                this._panStart.copy(this._panEnd);

                this.state = this.StateType.PAN;

            }
            break;
        default:
            break;
    }
    cameraControl.touchUpdate();
};

CLOUD.WalkEditor.prototype.processTouchend = function (event) {
    
    if (this.timeId) {
        clearTimeout(this.timeId);
    }

    if (this.longTapFlag) {
        this.longTapFlag = false;
        event.preventDefault();
    }

    var cameraControl = this.cameraControl;
    switch (event.touches.length) {
        case 0:
            this.state = this.StateType.NONE;
            cameraControl.touchEndHandler(event);
            break;
        case 1:
            if (CLOUD.EditorConfig.NoRotate)
                return;

            this._rotateStart.set(event.touches[0].clientX, event.touches[0].clientY);
            this.state = this.StateType.ROTATE;
            break;
        default:
            break;
    }
};
CLOUD.WalkEditor.prototype.processHover = function (event) {

    event.preventDefault();

    if (!this.dragLook) {

        // 鼠标直接移动来调整观察方向
        if (this.firstRotate) {

            this.firstRotate = false;
            this.rotateStart.set(event.clientX, event.clientY);
            // this.state = this.StateType.ROTATE;
        }

        this.rotateEnd.set(event.clientX, event.clientY);
        this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
        this.rotateStart.copy(this.rotateEnd);

        this._doRotate(this.rotateDelta);
    }

};
/*
// TODO: refactor this method. All there kinds of Editor have similar code
CLOUD.WalkEditor.prototype.processMouseWheel = function (event) {

    event.preventDefault();
    event.stopPropagation();

    if (CLOUD.EditorConfig.NoZoom) {
        return;
    }

    // 鼠标滚轮缩放

    // TODO: FIXME: should test in FireFox, the wheel code was fixed for OrbitEditor.js,
    //                but not fixed for FlyEditor and WalkEditor - wun-c

    //滚轮操作在浏览器中要考虑兼容性
    // 五大浏览器（IE、Opera、Safari、Firefox、Chrome）中Firefox 使用detail，其余四类使用wheelDelta；
    //两者只在取值上不一致，代表含义一致，detail与wheelDelta只各取两个值，detail只取±3，wheelDelta只取±120，其中正数表示为向上，负数表示向下。
    var delta = 0 || event.wheelDelta || event.detail;
    delta = Math.abs(delta) > 10 ? delta : -delta * 40;
    delta *= this.wheelZoomFactor;

    if (CLOUD.EditorConfig.ReverseWheelDirection) {
        delta *= -1;
    }

    this.zoomDelta = delta;
};
*/

CLOUD.WalkEditor.prototype.processKeyDown = function (event) {

    if (CLOUD.EditorConfig.NoKey)
        return;

    if (event.altKey) {
        return;
    }

    var moveDirection = CLOUD.MoveDirection.NONE;
    var keys = CLOUD.Keys;

    switch (event.keyCode) {
        case keys.ZERO: /* 0 - 恢复速度 */
            this.movementSpeed = this.defaultMovementSpeed;
            break;
        case keys.PLUS: /* 等号&加号 - 加速*/
            this.movementSpeed *= 1.1;
            break;
        case keys.SUB: /* 破折号&减号 - 减速*/
            this.movementSpeed *= 0.9;
            if (this.movementSpeed < this.minMovementSpeed) {
                this.movementSpeed = this.minMovementSpeed;
            }
            break;
        case keys.UP: /*up - 前进*/
        case keys.W: /*W - 前进*/
            moveDirection = CLOUD.MoveDirection.FORWARD;
            this.moveState.forward = 1;
            break;
        case keys.DOWN: /*down - 后退 */
        case keys.S: /*S - 后退*/
            moveDirection = CLOUD.MoveDirection.BACK;
            this.moveState.back = 1;
            break;
        case keys.LEFT: /*left - 左移 */
        case keys.A: /*A - 左移*/
            moveDirection = CLOUD.MoveDirection.LEFT;
            this.moveState.left = 1;
            break;
        case keys.RIGHT: /*right - 右移*/
        case keys.D: /*D - 右移*/
            moveDirection = CLOUD.MoveDirection.RIGHT;
            this.moveState.right = 1;
            break;
        case keys.Q: /*Q - 上移*/
            moveDirection = CLOUD.MoveDirection.UP;
            this.moveState.up = 1;
            break;
        case keys.E: /*E - 下移*/
            moveDirection = CLOUD.MoveDirection.DOWN;
            this.moveState.down = 1;
            break;
        default:
            break;
    }

    this._updateMovement();
    this._updateRotation();

    if (moveDirection !== CLOUD.MoveDirection.NONE) {

        this.dispatchEvent({
            type: CLOUD.EVENTS.ON_EDITOR_KEYDOWN,
            event: event,
            direction: moveDirection,
            editor: this.name
        });
    }
};

CLOUD.WalkEditor.prototype.processKeyUp = function (event) {

    if (CLOUD.EditorConfig.NoKey)
        return;

    var moveDirection = CLOUD.MoveDirection.NONE;
    var keys = CLOUD.Keys;

    switch (event.keyCode) {
        case keys.UP: /*up - 前进*/
        case keys.W: /*W - 前进 */
            moveDirection = CLOUD.MoveDirection.FORWARD;
            this.moveState.forward = 0;
            break;
        case keys.DOWN: /*down - 后退 */
        case keys.S: /*S - 后退 */
            moveDirection = CLOUD.MoveDirection.BACK;
            this.moveState.back = 0;
            break;
        case keys.LEFT: /*left - 左移 */
        case keys.A: /*A - 左移 */
            moveDirection = CLOUD.MoveDirection.LEFT;
            this.moveState.left = 0;
            break;
        case keys.RIGHT: /*right - 右移*/
        case keys.D: /*D - 右移 */
            moveDirection = CLOUD.MoveDirection.RIGHT;
            this.moveState.right = 0;
            break;
        case keys.Q: /*Q - 上移 */
            moveDirection = CLOUD.MoveDirection.UP;
            this.moveState.up = 0;
            break;
        case keys.E: /*E - 下移 */
            moveDirection = CLOUD.MoveDirection.DOWN;
            this.moveState.down = 0;
            break;
    }

    this._updateMovement();
    this._updateRotation();

    if (moveDirection !== CLOUD.MoveDirection.NONE) {

        this.dispatchEvent({
            type: CLOUD.EVENTS.ON_EDITOR_KEYUP,
            event: event,
            direction: moveDirection,
            editor: this.name
        });
    }

};

// TODO: move me to CameraControl
CLOUD.WalkEditor.prototype.updateWalkMove = function () {

    // 漫游使用了定时器，每次调用，定时器都要更新
    var timeDelta = this._clock.getDelta();
    var cameraControl = this.cameraControl;

    // fixed bug BIMFACEDM-3500：【漫游】第一次点击WASD，模型跳动距离不定。
    // 没有行走动作，这里会直接返回，若定时器没有更新的话，下次计时的时间间隔就有问题了
    if (this.moveVector.x === 0 && this.moveVector.y === 0 && this.moveVector.z === 0 &&
        this.rotationVector.x === 0 && this.rotationVector.y === 0 && this.rotationVector.z === 0 &&
        this.zoomDelta === 0 && cameraControl.gravity === 0) {
        return;
    }    

    var moveStep = this.movementSpeed * CLOUD.EditorConfig.WalkSpeedRate * timeDelta;
    

    if(CLOUD.GlobalData.WalkingWithGravity == true){
        //漫游模式下up/down键失效
        this.moveVector.y = 0;
        cameraControl.computeManHeight();
        cameraControl.computeGravity();
      	
    }

    cameraControl.dirtyCamera(true);

    // zoom
    if (this.zoomDelta !== 0) {

        var factor = 1.0 + this.zoomDelta * timeDelta;
        cameraControl.zoomCameraForWalk(factor);
        this.zoomDelta = 0;
    }

    // 平移
    cameraControl.translateCameraForWalk(this.moveVector, moveStep);

    // 旋转
    if (this.dragLook) {
        cameraControl.rotateCameraForWalk(this.rotationVector, 1);
    } else {
        cameraControl.rotateCameraForWalk(this.rotationVector, 2);
    }

    // 刷新
    cameraControl.flyOnWorld();
};

/**
 * 进入行走模式相关处理
 *
 */
CLOUD.WalkEditor.prototype.onEnter = function () {

    var camera = this.cameraControl.getCamera();

    if (!camera.isPerspective) {
        console.log("Current camera is Orthographic");
        // NOTE: if we support customized camera which cannot be switched between
        //        perspective and orthographic freely, how to handle this situation - require design
        camera.toPerspective();
    }

    //BIMFACE-1007 
    if(camera.position.y != camera.target.y){
        var eye = camera.target.clone().sub(camera.position);
        var distance = eye.length();

        var newEye = eye.clone();
        newEye.y = 0;
        newEye.normalize();
        newEye.multiplyScalar(distance);
        camera.target.addVectors(camera.position, newEye);
    }

    this._start();
};

/**
 * 退出行走模式相关处理
 *
 */
CLOUD.WalkEditor.prototype.onExit = function () {
    this._stop();
};

/**
 * 朝指定方向旋转
 *
 * @param {Object} delta 旋转偏移量 ({x: 10, y: 10})
 */
CLOUD.WalkEditor.prototype.rotateTo = function (delta) {
    this._doRotate(delta);
};

/**
 * 朝指定方向移动
 *
 * @param {Number} direction 移动方向 {@link CLOUD.MoveDirection}
 * @param {Number} step 步进大小
 * @param {Boolean} go 是否启动
 */
CLOUD.WalkEditor.prototype.moveTo = function (direction, step, go) {

    if (go === undefined) {
        go = true;
    }

    if (step === undefined) {
        step = 1;
    }

    if (go) {
        switch (direction) {
            case CLOUD.MoveDirection.FORWARD:
                this.moveState.forward = step;
                break;
            case CLOUD.MoveDirection.BACK:
                this.moveState.back = step;
                break;
            case CLOUD.MoveDirection.LEFT:
                this.moveState.left = step;
                break;
            case CLOUD.MoveDirection.RIGHT:
                this.moveState.right = step;
                break;
            case CLOUD.MoveDirection.UP:
                this.moveState.up = step;
                break;
            case CLOUD.MoveDirection.DOWN:
                this.moveState.down = step;
                break;
            default:
                break;
        }
    } else {
        switch (direction) {
            case CLOUD.MoveDirection.FORWARD:
                this.moveState.forward = 0;
                break;
            case CLOUD.MoveDirection.BACK:
                this.moveState.back = 0;
                break;
            case CLOUD.MoveDirection.LEFT:
                this.moveState.left = 0;
                break;
            case CLOUD.MoveDirection.RIGHT:
                this.moveState.right = 0;
                break;
            case CLOUD.MoveDirection.UP:
                this.moveState.up = 0;
                break;
            case CLOUD.MoveDirection.DOWN:
                this.moveState.down = 0;
                break;
        }
    }
    this._updateMovement();
};

/**
 * 锁定行走高度
 *
 * @param {Boolean} lock - 是否锁定
 */
CLOUD.WalkEditor.prototype.setHeightLocked = function (lock) {

    if (this.lockHeightEnabled && this.isLockHeight !== lock) {
        this.isLockHeight = lock;
    }

};

/**
 * 鼠标拖拽行走观察
 *
 * @param {Boolean} drag - 是否拖拽
 */
CLOUD.WalkEditor.prototype.setDragLook = function (drag) {

    if (this.dragLook !== drag) {
        this.firstRotate = true;
        this.dragLook = drag;
    }

};
