CLOUD.FlyEditor = function (cameraControl) {

    CLOUD.BaseEditor.call(this, CLOUD.EditorMode.FLY, cameraControl);

    this.lookSpeed = 0.001; // 相机观察速度

    this.constrainPitch = true; // 是否限制仰角
    // 仰角范围[-85, 175]
    this.pitchMin = THREE.Math.degToRad(5) - 0.5 * Math.PI; // 仰角最小值
    this.pitchMax = 0.5 * Math.PI - this.pitchMin; // 仰角最大值
    this.pitchDeltaTotal = 0;

    this.moveState = CLOUD.MoveDirection.NONE;

    // 保存旋转点
    this.rotateStart = new THREE.Vector2();
    this.rotateEnd = new THREE.Vector2();
    this.rotateDelta = new THREE.Vector2(); // tmp variable

    this._panStart = new THREE.Vector2();
    this._panEnd = new THREE.Vector2();
    this._panDelta = new THREE.Vector2();
    this._pan = new THREE.Vector3();           // tmp
    this._worldDimension = new THREE.Vector2();

    // 鼠标位置
    this.lastMousePoint = new THREE.Vector2();

    this.isLockHeight = false;
    this.lockedHeight = 0;

    this.pickHelper = new CLOUD.PickHelper(cameraControl);
    this.intersectOfMouseDown = null;
};

CLOUD.FlyEditor.prototype = Object.create(CLOUD.BaseEditor.prototype);
CLOUD.FlyEditor.prototype.constructor = CLOUD.FlyEditor;

CLOUD.FlyEditor.prototype.destroy = function () {
    this.cameraControl = null;
    this.scene = null;
};

CLOUD.FlyEditor.prototype.processMouseDown = function (event) {

    event.preventDefault();
    event.stopPropagation();
	
	this.lastMousePoint.set(event.clientX, event.clientY);

    var cameraControl = this.cameraControl;

    this.intersectOfMouseDown = null;

    if (event.button === this.mouseButtons.ORBIT) {
        if (CLOUD.EditorConfig.NoRotate)
            return;

        // 设置旋转起点
        this.rotateStart.set(event.clientX, event.clientY);
        this.state = this.StateType.ROTATE;

        // Can we remove this event??? wun-c
        this.dispatchEvent({type: CLOUD.EVENTS.ON_EDITOR_BEGIN, name: "look", editor: this.name});

    } else if (event.button === this.mouseButtons.PAN || event.button === this.mouseButtons.PAN2) {

        if (CLOUD.EditorConfig.NoPan) {
            return;
        }

        //cameraControl.beginPan(event.clientX, event.clientY);
        this._panStart.set(event.clientX, event.clientY);

        // 根据当前鼠标点获得世界坐标系中的宽高
        this._worldDimension = cameraControl.getWorldDimension(event.clientX, event.clientY);

        this.intersectOfMouseDown = cameraControl.getLastIntersect();

        this.state = this.StateType.PAN;

        if (this.isLockHeight) {
            this.lockedHeight = event.clientY;
        }

    }
};

CLOUD.FlyEditor.prototype.doPan = function(clientX, clientY) {
    var cameraControl = this.cameraControl;

    this._panEnd.set(clientX, this.isLockHeight ? this.lockedHeight : clientY);
    this._panDelta.subVectors(this._panEnd, this._panStart);
    if (this._panDelta.x === 0 && this._panDelta.y === 0)
        return;

    //_scope.panOnWorld();
    //scope.pan( panDelta.x, panDelta.y );
    cameraControl.panOnWorld(this._panStart, this._panEnd, this._pan, this._worldDimension);
    //scope.pan( panDelta.x, panDelta.y );

    cameraControl.adjustCameraForPan(this._pan);

    this._panStart.copy(this._panEnd);

    cameraControl.update(true);
};

CLOUD.FlyEditor.prototype.processMouseMove = function (event) {
	
    var cameraControl = this.cameraControl;

    event.preventDefault();

    if ( this.state === this.StateType.ROTATE) {

        this.rotateEnd.set(event.clientX, event.clientY);
        this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
        this.rotateStart.copy(this.rotateEnd);

        if (this.rotateDelta.x != 0 || this.rotateDelta.y != 0) {

            var deltaYaw = this.rotateDelta.x * this.lookSpeed;
            var deltaPitch = this.rotateDelta.y * this.lookSpeed;

            cameraControl.rotateForFly(deltaYaw, deltaPitch, this.pitchMin, this.pitchMax);
        }

    } else if (this.state === this.StateType.PAN) {

        this.doPan(event.clientX, event.clientY);

    }
};

CLOUD.FlyEditor.prototype.processMouseUp = function (event) {

    event.preventDefault();
    event.stopPropagation();	
	
	if (event.button === THREE.MOUSE.LEFT) {

        // check the location is not enough, also check time
        if ((this.lastMousePoint.x === event.clientX) && (this.lastMousePoint.y === event.clientY)) {
            this.pickHelper.click(event, this.intersectOfMouseDown);
            return;
        }

    }

    this.intersectOfMouseDown = null;

    var cameraControl = this.cameraControl;

    switch (this.state) {
        case this.StateType.ROTATE:
            // TODO: FIXME: not process the last rotation, only reset state
            //
            this.rotateDelta.set(0, 0);
            var deltaYaw = 0;
            var deltaPitch = 0;
            cameraControl.rotateForFly(deltaYaw, deltaPitch, this.pitchMin, this.pitchMax);
            // do we need this event? - wun-c
            this.dispatchEvent({type: CLOUD.EVENTS.ON_EDITOR_END, name: "look", editor: this.name});
            break;

        case this.StateType.PAN:

            this.doPan(event.clientX, event.clientY);

            break;

        default:
            break;
    }
    cameraControl.endOperation();

    this.state = this.StateType.NONE;
};

CLOUD.FlyEditor.prototype.processHover = function (event) {

    this.pickHelper.handleMouseHover(event);

};

// TODO: refactor this method. All there kinds of Editor have similar code
CLOUD.FlyEditor.prototype.processMouseWheel = function (event) {

    event.preventDefault();
    event.stopPropagation();

    var cameraControl = this.cameraControl;

    if ( CLOUD.EditorConfig.NoZoom) {
        return;
    }

    // 鼠标滚轮缩放

    // TODO: FIXME: should test in FireFox, the wheel code was fixed for OrbitEditor.js,
    //                but not fixed for FlyEditor and WalkEditor - wun-c

    //滚轮操作在浏览器中要考虑兼容性
    // 五大浏览器（IE、Opera、Safari、Firefox、Chrome）中Firefox 使用detail，其余四类使用wheelDelta；
    //两者只在取值上不一致，代表含义一致，detail与wheelDelta只各取两个值，detail只取±3，wheelDelta只取±120，其中正数表示为向上，负数表示向下。
    var delta = 0 || event.wheelDelta || event.detail;
    delta = Math.abs(delta) > 10 ? delta : -delta * 40;
    delta *= 0.0005;

    if (CLOUD.EditorConfig.ReverseWheelDirection) {
        delta *= -1;
    }

    this.cameraControl.delayHandle();

    // 以中心为基准缩放
    var rect = cameraControl.getContainerDimensions();
    var clientX = rect.left + 0.5 * rect.width;
    var clientY = rect.top + 0.5 * rect.height;

    cameraControl.zoom(delta, clientX, clientY);
};

CLOUD.FlyEditor.prototype.processKeyDown = function (event) {

    if (CLOUD.EditorConfig.NoKey)
        return;

    if (event.altKey) {
        return;
    }

    var enumMoveDirection = CLOUD.MoveDirection;

    var moveDirection = enumMoveDirection.NONE;
    switch (event.keyCode) {
        case CLOUD.Keys.ZERO: /* 0 - 恢复速度 */
            this.movementSpeed = this.defaultMovementSpeed;
            break;
        case CLOUD.Keys.PLUS: /* 等号&加号 - 加速*/
            this.movementSpeed *= 1.1;
            break;
        case CLOUD.Keys.SUB: /* 破折号&减号 - 减速*/
            this.movementSpeed *= 0.9;
            if (this.movementSpeed < this.minMovementSpeed) {
                this.movementSpeed = this.minMovementSpeed;
            }
            break;
        case CLOUD.Keys.UP: /*up - 前进*/
        case CLOUD.Keys.W: /*W - 前进*/
            moveDirection = enumMoveDirection.FORWARD;
            break;
        case CLOUD.Keys.DOWN: /*down - 后退 */
        case CLOUD.Keys.S: /*S - 后退*/
            moveDirection = enumMoveDirection.BACK;
            break;
        case CLOUD.Keys.LEFT: /*left - 左移 */
        case CLOUD.Keys.A: /*A - 左移*/
            moveDirection = enumMoveDirection.LEFT;
            break;
        case CLOUD.Keys.RIGHT: /*right - 右移*/
        case CLOUD.Keys.D: /*D - 右移*/
            moveDirection = enumMoveDirection.RIGHT;
            break;
        case CLOUD.Keys.Q: /*Q - 上移*/
            moveDirection = enumMoveDirection.UP;
            break;
        case CLOUD.Keys.E: /*E - 下移*/
            moveDirection = enumMoveDirection.DOWN;
            break;
        default:
            break;
    }

    if (moveDirection !== enumMoveDirection.NONE) {
        this.moveState |= moveDirection;
        this.dispatchEvent({
            type: CLOUD.EVENTS.ON_EDITOR_KEYDOWN,
            event: event,
            state: moveDirection,
            direction: enumMoveDirection,
            editor: this.name
        });

        this.cameraControl.delayHandle();

        this.cameraControl.updateFlyMove(this.moveState, this.movementSpeed * CLOUD.EditorConfig.MovementSpeedRate);
    }

};

CLOUD.FlyEditor.prototype.processKeyUp = function (event){

    if (CLOUD.EditorConfig.NoKey)
        return;

    var enumMoveDirection = CLOUD.MoveDirection;
    var moveDirection = enumMoveDirection.NONE;

    switch (event.keyCode) {
        case CLOUD.Keys.UP: /*up - 前进*/
        case CLOUD.Keys.W: /*W - 前进 */
            moveDirection = enumMoveDirection.FORWARD;
            break;
        case CLOUD.Keys.DOWN: /*down - 后退 */
        case CLOUD.Keys.S: /*S - 后退 */
            moveDirection = enumMoveDirection.BACK;
            break;
        case CLOUD.Keys.LEFT: /*left - 左移 */
        case CLOUD.Keys.A: /*A - 左移 */
            moveDirection = enumMoveDirection.LEFT;
            break;
        case CLOUD.Keys.RIGHT: /*right - 右移*/
        case CLOUD.Keys.D: /*D - 右移 */
            moveDirection = enumMoveDirection.RIGHT;
            break;
        case CLOUD.Keys.Q: /*Q - 上移 */
            moveDirection = enumMoveDirection.UP;
            break;
        case CLOUD.Keys.E: /*E - 下移 */
            moveDirection = enumMoveDirection.DOWN;
            break;
    }

    if (moveDirection !== enumMoveDirection.NONE) {

        this.dispatchEvent({
            type: CLOUD.EVENTS.ON_EDITOR_KEYUP,
            event: event,
            state: moveDirection,
            direction: enumMoveDirection,
            editor: this.name
        });
        this.moveState &= ~moveDirection
    }

};

CLOUD.FlyEditor.prototype.moveTo = function (direction) {

    this.cameraControl.updateFlyMove(direction, this.movementSpeed * CLOUD.EditorConfig.MovementSpeedRate);
};
