
ImageBasedLighting.prefilter_vs = [

	"varying vec3 pos;",
	"varying vec3 Normal;",

	"void main() {",
	"	pos = vec3(modelMatrix * vec4(position, 1.0));",
	"	Normal = mat3(modelMatrix) * normal;",
	"	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
	"}"

].join('\n');

ImageBasedLighting.prefilter_fs = [

	"varying vec3 pos;",
	"varying vec3 Normal;",

	"uniform float roughness;",

	"uniform samplerCube environmentMap;",
	"uniform sampler2D HammersleyTable;",

	"const float PI = 3.14159265358979;",
	//"const float INV_PI = 1.0 / PI;",

	"float D_GGX(float NdotH, float roughness)",
	"{",
	"	float alpha = pow(roughness, 2.0);",
	"	float alpha2 = pow(alpha, 2.0);",
	"	return alpha2 / (PI * pow(NdotH * NdotH * (alpha2 - 1.0) + 1.0, 2.0));",
	"}",

	"vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness) ",
	"{",
	"	float a = roughness * roughness;",

	"	float Phi = 2.0 * PI * Xi.x; ",
	"	float CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y)); ",
	"	float SinTheta = sqrt(1.0 - CosTheta * CosTheta);",

	"	vec3 H;",
	"	H.x = SinTheta * cos(Phi); ",
	"	H.y = SinTheta * sin(Phi); ",
	"	H.z = CosTheta;",

	"	vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0); ",
	"	vec3 TangentX = normalize(cross(UpVector, N)); ",
	"	vec3 TangentY = cross(N, TangentX);",

		// Tangent to world space 
	"	return normalize(TangentX * H.x + TangentY * H.y + N * H.z);",
	"}",

	"void main()",
	"{",
	"	vec3 N = normalize(pos);",
	"	vec3 R = N;",
	"	vec3 V = R;",

	"	const int sampleCount = 1024;",

	"	float totalWeight = 0.0;",
	"	vec3 prefilteredColor = vec3(0.0);",

	"	for (int i = 0; i < sampleCount; ++i) {",
	"		float u = float(i) / float(sampleCount);",
	"		vec2 Xi = vec2(u, texture2D(HammersleyTable, vec2(u)).r);",
	"		vec3 H = ImportanceSampleGGX(Xi, N, roughness);",
	"		vec3 L = normalize(2.0 * dot(V, H) * H - V);",

	"		float NdotL = max(dot(N, L), 0.0);",
	"		if(NdotL > 0.0)",
	"		{",
	"			float NdotH = max(dot(N, H), 0.0);",
	"			float D = D_GGX(NdotH, roughness);",

	"			float HdotV = max(dot(H, V), 0.0);",
	"			float pdf = D * NdotH / (4.0 * HdotV);",

	"			float resolution = 2048.0; // resolution of source cubemap (per face)",
	"			float solidAngleTexel= 4.0 * PI / (6.0 * resolution * resolution);",
	"			float solidAngleSample = 1.0 / (float(sampleCount) * pdf);",

	"			float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(solidAngleSample / solidAngleTexel);",

	"			prefilteredColor += textureCube(environmentMap, L, mipLevel).rgb * NdotL;",
	"			totalWeight += NdotL;",
	"		}",
	"	}",

	"	prefilteredColor = prefilteredColor / totalWeight;",
	"	gl_FragColor = vec4(prefilteredColor, 1.0);",
	"}"

].join('\n');

ImageBasedLighting.PrefilterMap = function(envMap, hammersleyTable, resolution, maxMipLevel) {

	this.cubeTexture = null;

	this.resolution = resolution || 128;
	this.maxMipLevel = maxMipLevel || 1;

	this.prefilterMaterial = new THREE.ShaderMaterial({
		vertexShader: ImageBasedLighting.prefilter_vs,
		fragmentShader: ImageBasedLighting.prefilter_fs,
		uniforms: {
			roughness: { value: 0.0 },
			environmentMap: { value: envMap },
			HammersleyTable: {value: hammersleyTable}
		},

		lights:false,
		side: THREE.BackSide
	});

	this.cube = new THREE.Mesh(new THREE.BoxBufferGeometry(2.0, 2.0, 2.0), this.prefilterMaterial);

};

ImageBasedLighting.PrefilterMap.prototype.constructor = ImageBasedLighting.PrefilterMap;

ImageBasedLighting.PrefilterMap.prototype.generateMap = function(renderer, isHDR) {

	var scene = new THREE.Scene();
	scene.add(this.cube);

	var cubecamera = new THREE.CubeCamera(0.1, 10.0, this.resolution);
	if (isHDR) {
		var options = { type: THREE.FloatType, format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };
		cubecamera.renderTarget = new THREE.WebGLRenderTargetCube( this.resolution, this.resolution, options );
	}

	var maxLevel = this.maxMipLevel <= 1.0 ? 1.0 : (this.maxMipLevel - 1.0);
	for (var i = 0; i < this.maxMipLevel; i++) {
		var width = this.resolution * Math.pow(0.5, i);
		cubecamera.renderTarget.width = cubecamera.renderTarget.height = width;

		var roughness = i / maxLevel;
		this.prefilterMaterial.uniforms.roughness.value = roughness;

		cubecamera.renderTarget.activeMipMapLevel = i;
		cubecamera.updateCubeMap(renderer, scene);
	}
	
	this.cubeTexture = cubecamera.renderTarget.texture;
	
};