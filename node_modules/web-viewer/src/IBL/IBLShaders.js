
ImageBasedLighting.IBLVertexShader = [
    "uniform vec4 offsetRepeat;",
    "varying vec2 vUv;",
    "varying vec3 Normal;",
    "varying vec3 Pos;",
    "varying vec3 mvPosition;",
    "varying vec3 mvNormal;"
].join('\n') +
    CLOUD.IdTargetUtil.idVarOfVertexShader() +
    [
    "void main()",
    "{",
    "    vUv = uv * offsetRepeat.zw + offsetRepeat.xy;",
    "    Pos = vec3(modelMatrix * vec4(position, 1.0));",
    "    Normal = normalize(mat3(modelMatrix) * normal);",
    "    mvPosition = vec3(modelViewMatrix * vec4(position, 1.0));",
    "    mvNormal = normalize(normalMatrix * normal);",
    "    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);"
].join('\n') +
    CLOUD.IdTargetUtil.passIdInVertexShader() +
    "}";

ImageBasedLighting.varying_pars = [

    "varying vec2 vUv;",
    "varying vec3 Normal;",
    "varying vec3 Pos;",
    "varying vec3 mvPosition;",
    "varying vec3 mvNormal;"

].join('\n');

ImageBasedLighting.clipping_pars = [

    "#if NUM_CLIPPING_PLANES > 0",
    "    uniform vec4 clippingPlanes[NUM_CLIPPING_PLANES];",
    "#endif"

].join('\n');

ImageBasedLighting.maps_pars = [

    "#ifdef USE_MAP",
    "    uniform sampler2D map;",
    "#endif",

    "#ifdef USE_NORMALMAP",

    "    uniform sampler2D normalMap;",
    "    uniform vec2 normalScale;",
    "vec3 perturbNormal2Arb(vec3 pos, vec3 normal)",
    "{",
    "    vec3 q0 = vec3(dFdx(pos.x), dFdx(pos.y), dFdx(pos.z));",
    "    vec3 q1 = vec3(dFdy(pos.x), dFdy(pos.y), dFdy(pos.z));",
    "    vec2 st0 = dFdx(vUv.st);",
    "    vec2 st1 = dFdy(vUv.st);",
    "    vec3 S = normalize(q0 * st1.t - q1 * st0.t);",
    "    vec3 T = normalize(-q0 * st1.s + q1 * st0.s);",
    "    vec3 N = normalize(normal);",
    "    vec3 mapN = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;",
    "    mapN.xy = normalScale * mapN.xy;",
    "    mat3 tsn = mat3(S, T, N);",
    "    return normalize(tsn * mapN);",
    "}",

    "#endif",

    "#ifdef USE_ROUGHNESSMAP",
    "    uniform sampler2D roughnessMap;",
    "#endif",

    "#ifdef USE_METALNESSMAP",
    "    uniform sampler2D metalnessMap;",
    "#endif",

    "#ifdef USE_AOMAP",
    "    uniform sampler2D aoMap;",
    "    uniform float aoMapIntensity;",
    "#endif"
    
].join('\n');

ImageBasedLighting.iblMaps_pars = [

    "uniform samplerCube irradianceMap;",
    "uniform samplerCube prefilterMap;",
    "uniform sampler2D brdfMap;",

].join('\n');

ImageBasedLighting.lighting_pars = [

    "uniform vec3 ambientLightColor;",

    "#if NUM_DIR_LIGHTS > 0",
    "struct DirectionalLight",
    "{",
    "    vec3 direction;",
    "    vec3 color;",

    "    int shadow;",
    "    float shadowBias;",
    "    float shadowRadius;",
    "    vec2 shadowMapSize;",
    "};",

    "uniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];",
    "#endif",

    "#if NUM_POINT_LIGHTS > 0",
    "struct PointLight",
    "{",
    "    vec3 position;",
    "    vec3 color;",
    "    float distance;",
    "    float decay;",

    "    int shadow;",
    "    float shadowBias;",
    "    float shadowRadius;",
    "    vec2 shadowMapSize;",
    "};",

    "uniform PointLight pointLights[NUM_POINT_LIGHTS];",
    "#endif",

    "#if NUM_SPOT_LIGHTS > 0",
    "struct SpotLight",
    "{",
    "    vec3 position;",
    "    vec3 direction;",
    "    vec3 color;",
    "    float distance;",
    "    float decay;",
    "    float coneCos;",
    "    float penumbraCos;",

    "    int shadow;",
    "    float shadowBias;",
    "    float shadowRadius;",
    "    vec2 shadowMapSize;",
    "};",

    "uniform SpotLight spotLights[NUM_SPOT_LIGHTS];",
    "#endif",

    "float punctualLightIntensityToIrradianceFactor(const in float lightDistance, const in float cutoffDistance, const in float decayExponent)",
    "{",
    "    if(decayExponent > 0.0)",
    "    {",
    "        float distanceFalloff = 1.0 / max(pow(abs(lightDistance), decayExponent), 0.01);",
    "        float maxDistanceCutoffFactor = pow(abs(clamp(1.0 - pow(abs(lightDistance / cutoffDistance), 4.0), 0.0, 1.0)), 2.0);",
    "        return distanceFalloff * maxDistanceCutoffFactor;",
    "    }",

    "    float distanceFalloff = 1.0 / max(pow(abs(lightDistance), 2.0), 0.01);",
    "    return distanceFalloff;",
    "}",

].join('\n');

ImageBasedLighting.toneMap_pars = [

    "uniform float shift;",
    "uniform float A;",
    "uniform float B;",
    "uniform float C;",
    "uniform float D;",
    "uniform float E;",
    "uniform float F;",
    "uniform float scale;",

    "vec3 toneMapCanonFilmic(vec3 color)",
    "{",
    "    color *= (1.0 / shift);",
    "    return (((color * (A * color + C * B)) / (color * (A * color + B) + D * F))) * (1.0 / scale);",
    "}",

].join('\n');

ImageBasedLighting.Uniforms = [

    ImageBasedLighting.varying_pars,
    ImageBasedLighting.clipping_pars,

    "uniform bool IBLEnabled;",
    "uniform int debug;",
    "uniform float gamma;",

    "uniform vec3 albedo;",
    "uniform float metalness;",
    "uniform float roughness;",
    "uniform float opacity;",

    ImageBasedLighting.maps_pars,

    ImageBasedLighting.iblMaps_pars,

    ImageBasedLighting.lighting_pars,

    ImageBasedLighting.toneMap_pars,

].join('\n') +
    CLOUD.IdTargetUtil.idVarOfFragShader();

ImageBasedLighting.IBLFragmentShader = [

    ImageBasedLighting.Uniforms,

    "const float PI = 3.14159265358979;",
    "#include <bumpmap_pars_fragment>",
    "float D_GGX(float NdotH, float roughness)",
    "{",
    "    float alpha = pow(roughness, 2.0);",
    "    float alpha2 = pow(alpha, 2.0);",
    "    return alpha2 / (PI * pow(abs(NdotH * NdotH * (alpha2 - 1.0) + 1.0), 2.0));",
    "}",

    "float GGX_Schlick(float NdotV, float roughness)",
    "{",
    "    float k = (roughness + 1.0) * 0.125;",
    "    return NdotV / (NdotV * (1.0 - k) + k);",
    "}",

    "float G_Smith(float NdotV, float NdotL, float roughness)",
    "{",
    "    return GGX_Schlick(NdotV, roughness) * GGX_Schlick(NdotL, roughness);",
    "}",

    "vec3 F_Schlick(float HdotV, vec3 F0)",
    "{",
    "    return F0 + (vec3(1.0) - F0) * pow((1.0 - HdotV), 5.0);",
    "}",

    "vec3 F_SchlickRoughness(float NdotV, vec3 F0, float roughness)",
    "{",
    "    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - NdotV, 5.0);",
    "}",

    "vec3 postProcessing(vec3 color, bool toneMap)",
    "{",
    "    vec3 result = toneMap ? toneMapCanonFilmic(color) : color;",
    "    result = pow(result, vec3(1.0 / gamma));",
    "    return result;",
    "}",

    "void main()",
    "{",

    "#if NUM_CLIPPING_PLANES > 0",

    "    vec3 vViewPosition = -mvPosition;",
    
    "    for (int i = 0; i < UNION_CLIPPING_PLANES; ++ i)",
    "    {",
    "        vec4 plane = clippingPlanes[ i ];",
    "        if (dot(vViewPosition, plane.xyz) > plane.w) discard;",
    "    }",
            
    "    #if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES",

    "        bool clipped = true;",
    "        for (int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i)",
    "        {",
    "            vec4 plane = clippingPlanes[ i ];",
    "            clipped = (dot(vViewPosition, plane.xyz) > plane.w) && clipped;",
    "        }",
    
    "        if (clipped) discard;",
        
    "    #endif",

    "#endif",

    "    vec3 baseColor = pow(albedo, vec3(gamma));",
    "#ifdef USE_MAP",
    "    baseColor = pow(texture2D(map, vUv).rgb, vec3(gamma));",
    "#endif",


    "#ifdef DOUBLE_SIDED",
    "    float flipNormal = float(gl_FrontFacing) * 2.0 - 1.0;",
    "#else",
    "    float flipNormal = 1.0;",
    "#endif",

    "    vec3 normal = Normal * flipNormal;",
    "    vec3 vNormal = mvNormal * flipNormal;",
    "#ifdef USE_NORMALMAP",
    "    normal = perturbNormal2Arb(Pos, normal);",
    "    vNormal = perturbNormal2Arb(mvPosition, vNormal);",
    "#endif",

    "#ifdef USE_BUMPMAP",

    "    normal = perturbNormalArb( mvPosition, normal, dHdxy_fwd() );",

    "#endif",

    "    float roughnessFactor = roughness;",
    "#ifdef USE_ROUGHNESSMAP",
    "    roughnessFactor = texture2D(roughnessMap, vUv).r;",
    "#endif",

    "    float metalnessFactor = metalness;",
    "#ifdef USE_METALNESSMAP",
    "    metalnessFactor = texture2D(metalnessMap, vUv).r;",
    "#endif",

    "    float aoFactor = 1.0;",
    "#ifdef USE_AOMAP",
    "    aoFactor = texture2D(aoMap, vUv).r;",
    "#endif",

    "    vec3 N = normal;",
    "    vec3 V = normalize(cameraPosition - Pos);",
    "    vec3 R = reflect(-V, N);",

    "    vec3 F0 = vec3(0.04);",
    "    F0 = mix(F0, baseColor, metalnessFactor);",

    "    vec3 totalLightColor = vec3(0.0);",

    "    vec3 viewVector = normalize(-mvPosition);",
    "    vec3 normalVector = normalize(vNormal);",
    "    float NdotV = max(dot(normalVector, viewVector), 0.0);",

    "    totalLightColor += ambientLightColor * baseColor / PI;",

    //Directional Lights
    "#if NUM_DIR_LIGHTS > 0",

    "    vec3 dirColor = vec3(0.0);",

    "    for (int i = 0; i < NUM_DIR_LIGHTS; ++i)",
    "    {",
    "        DirectionalLight directionalLight = directionalLights[i];",
    "        vec3 dirVector = normalize(directionalLight.direction);",
    "        vec3 halfVector = normalize(dirVector + viewVector);",

    "        float NdotL = max(dot(normalVector, dirVector), 0.0);",
    "        float NdotH = max(dot(normalVector, halfVector), 0.0);",
    "        float HdotV = max(dot(halfVector, viewVector), 0.0);",

    "        vec3 F = F_Schlick(HdotV, F0);",
    "        vec3 kS = F;",
    "        vec3 kD = 1.0 - kS;",
    "        kD *= 1.0 - metalnessFactor;",

    "        float D = D_GGX(NdotH, roughnessFactor);",
    "        float G = G_Smith(NdotV, NdotL, roughnessFactor);",
    "        vec3 specular = D * G * F / (4.0 * NdotV * NdotL + 0.001);",

    "        dirColor += (kD * baseColor / PI + specular) * directionalLight.color * NdotL;",
    "    }",

    "    totalLightColor += dirColor;",

    "#endif",

    //Point Lights
    "#if NUM_POINT_LIGHTS > 0",

    "    vec3 pointColor  = vec3(0.0);",

    "    for (int i = 0; i < NUM_POINT_LIGHTS; ++i)",
    "    {",
    "        PointLight pointLight = pointLights[i];",
    "        vec3 dirVector = pointLight.position - mvPosition;",
    "        float distance = length(dirVector);",
    "        dirVector = normalize(dirVector);",
    "        vec3 halfVector = normalize(dirVector + viewVector);",

    "        float NdotL = max(dot(normalVector, dirVector), 0.0);",
    "        float NdotH = max(dot(normalVector, halfVector), 0.0);",
    "        float HdotV = max(dot(halfVector, viewVector), 0.0);",

    "        vec3 F = F_Schlick(HdotV, F0);",
    "        vec3 kS = F;",
    "        vec3 kD = 1.0 - kS;",
    "        kD *= 1.0 - metalnessFactor;",

    "        float D = D_GGX(NdotH, roughnessFactor);",
    "        float G = G_Smith(NdotV, NdotL, roughnessFactor);",
    "        vec3 specular = D * G * F / (4.0 * NdotV * NdotL + 0.001);",

    
    "        pointColor += (kD * baseColor / PI + specular) * pointLight.color * NdotL * punctualLightIntensityToIrradianceFactor(distance, pointLight.distance, pointLight.decay);",
    "    }",

    "    totalLightColor += pointColor;",

    "#endif",

    //Spot Lights
    "#if NUM_SPOT_LIGHTS > 0",

    "    vec3 spotColor  = vec3(0.0);",

    "    for (int i = 0; i < NUM_SPOT_LIGHTS; ++i)",
    "    {",
    "        SpotLight spotLight = spotLights[i];",
    "        vec3 dirVector = spotLight.position - mvPosition;",
    "        float distance = length(dirVector);",
    "        dirVector = normalize(dirVector);",
    "        vec3 halfVector = normalize(dirVector + viewVector);",

    "        float angleCos = dot(dirVector, spotLight.direction);",
    "        if (angleCos > spotLight.coneCos)",
    "        {",
    "            float spotEffect = smoothstep(spotLight.coneCos, spotLight.penumbraCos, angleCos);",
    "            float NdotL = max(dot(normalVector, dirVector), 0.0);",
    "            float NdotH = max(dot(normalVector, halfVector), 0.0);",
    "            float HdotV = max(dot(halfVector, viewVector), 0.0);",

    "            vec3 F = F_Schlick(HdotV, F0);",
    "            vec3 kS = F;",
    "            vec3 kD = 1.0 - kS;",
    "            kD *= 1.0 - metalnessFactor;",

    "            float D = D_GGX(NdotH, roughnessFactor);",
    "            float G = G_Smith(NdotV, NdotL, roughnessFactor);",
    "            vec3 specular = D * G * F / (4.0 * NdotV * NdotL + 0.001);",

    "            spotColor += (kD * baseColor / PI + specular) * spotLights[i].color * spotEffect * NdotL",
    "                * punctualLightIntensityToIrradianceFactor(distance, spotLight.distance, spotLight.decay);",

    "            totalLightColor += spotColor;",
    "        }",
    "    }",

    "#endif",

    "    if (IBLEnabled)",
    "    {",
    "        vec3 F = F_SchlickRoughness(max(dot(N, V), 0.0), F0, roughnessFactor);",

    "        vec3 kS = F;",
    "        vec3 kD = 1.0 - kS;",
    "        kD *= 1.0 - metalnessFactor;",

    "        vec3 irradiance = textureCube(irradianceMap, N, 0.0).rgb;",

    "        vec3 diffuse = irradiance * baseColor;",

    "        const float MAX_REFLECTION_LOD = 1.0;",
    "        vec3 prefilteredColor = textureCube(prefilterMap, R, roughnessFactor * MAX_REFLECTION_LOD).rgb;",

    "        vec2 brdf = texture2D(brdfMap, vec2(max(dot(N, V), 0.0), roughnessFactor)).rg;",
    "        vec3 specular = prefilteredColor * (F * brdf.x + brdf.y);",

    "        vec3 color = (kD * diffuse + specular + totalLightColor) * aoFactor;",
    "        color = postProcessing(color, true);",

    "        if (debug == 1) ",
    "        {",
    "            baseColor = postProcessing(baseColor, false);",
    "            gl_FragColor = vec4(baseColor, opacity);",
    "        }",
    "        else if (debug == 2)",
    "        {",
    "            irradiance = postProcessing(irradiance, true);",
    "            gl_FragColor = vec4(irradiance, opacity);",
    "        }",
    "        else if (debug == 3)",
    "        {",
    "            prefilteredColor = postProcessing(prefilteredColor, true);",
    "            gl_FragColor = vec4(prefilteredColor, opacity);",
    "        }",
    "        else if (debug == 4)",
    "        {",
    "            diffuse = postProcessing(diffuse, true);",
    "            gl_FragColor = vec4(diffuse, opacity);",
    "        }",
    "        else if (debug == 5)",
    "        {",
    "            specular = postProcessing(specular, true);",
    "            gl_FragColor = vec4(specular, opacity);",
    "        }",
    "        else if (debug == 6)",
    "        {",
    "            gl_FragColor = vec4(brdf, 0.0, opacity);",
    "        }",
    "        else if (debug == 7)",
    "        {",
    "            gl_FragColor = vec4(normal, opacity);",
    "        }",
    "        else",
    "        {",
    "            gl_FragColor = vec4(color, opacity);",
    "        }",
    "    }",
    "    else",
    "    {",
    "        totalLightColor = postProcessing(totalLightColor, true);",
    "        gl_FragColor = vec4(totalLightColor, opacity);",
    "    }"
].join('\n') +
    CLOUD.IdTargetUtil.writeIdInFragShader() +
    "}";

ImageBasedLighting.cube_vs = [

    "varying vec3 pos;",

    "void main()",
    "{",
    "    pos = position;",
    "    gl_Position = projectionMatrix * mat4(mat3(viewMatrix)) * modelMatrix * vec4(position, 1.0);",
    "    gl_Position = gl_Position.xyww;",
    "}"

].join('\n');

ImageBasedLighting.cube_fs = [

    "varying vec3 pos;",

    "uniform samplerCube environmentMap;",
    "uniform bool hdr;",

    "uniform float shift;",
    "uniform float A;",
    "uniform float B;",
    "uniform float C;",
    "uniform float D;",
    "uniform float E;",
    "uniform float F;",
    "uniform float scale;",
    
    "vec3 toneMapCanonFilmic(vec3 color)",
    "{",

    "    color *= (1.0 / shift);",
    "    return (((color * (A * color + C * B)) / (color * (A * color + B) + D * F))) * (1.0 / scale);",

    "}",

    "void main()",
    "{",
    "    vec3 envColor = textureCube(environmentMap, pos, 0.0).rgb;",
    "    if (hdr)",
    "    {",
    "        envColor = toneMapCanonFilmic(envColor);",
    "    }",
    "    envColor = pow(envColor, vec3(1.0 / 2.2));",
    "    gl_FragColor = vec4(envColor, 1.0);",
    "}"

].join('\n');