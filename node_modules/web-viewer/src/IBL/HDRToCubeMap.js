ImageBasedLighting.equirectangular_vs = [

	"varying vec3 pos;",

	"void main() {",
	"	pos = vec3(modelMatrix * vec4(position, 1.0));",
	"	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
	"}"
    
].join('\n');

ImageBasedLighting.equirectangular_fs = [

	"varying vec3 pos;",
	"uniform sampler2D map;",

	"const float PI = 3.14159265358979;",
	"const float INV_PI = 1.0 / PI;",

	"vec2 sampleSphericalMap(vec3 v)",
	"{",
	"	vec2 uv = vec2(atan(v.z, v.x), asin(v.y));",
	"	uv *= vec2(INV_PI * 0.5, INV_PI);",
	"	uv += 0.5;",
	"	return uv;",
	"}",

	"void main() {",
	"	vec2 uv = sampleSphericalMap(normalize(pos));",
	"	vec4 color = texture2D(map, uv);",
	"	gl_FragColor = vec4(color.rgb, 1.0);",
	"}"
    
].join('\n');

ImageBasedLighting.EquirectangularMaterial = function (parameters) {

	THREE.ShaderMaterial.call(this);

	this.type = 'EquirectangularMaterial';

	this.map = null;

	this.lights = false;

	this.side = THREE.BackSide;

	this.defines = {};
	this.uniforms = THREE.UniformsUtils.merge( [

		{
			map: { value: null }
		}

	] );

	this.vertexShader = ImageBasedLighting.equirectangular_vs;

	this.fragmentShader = ImageBasedLighting.equirectangular_fs;

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [1, 1, 1],
		'uv': [0, 0],
		'uv2': [0, 0]
	};

	if (parameters !== undefined) {

		if (parameters.attributes !== undefined) {

			console.error('IBLMaterial: attributes should now be defined in THREE.BufferGeometry instead.');

		}

		this.setValues(parameters);

	}

	this.refreshUniforms();

};

ImageBasedLighting.EquirectangularMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
ImageBasedLighting.EquirectangularMaterial.prototype.constructor = ImageBasedLighting.EquirectangularMaterial;

ImageBasedLighting.EquirectangularMaterial.prototype.isShaderMaterial = true;

ImageBasedLighting.EquirectangularMaterial.prototype.copy = function (source) {

	THREE.ShaderMaterial.prototype.copy.call(this, source);

	this.map = source.map;

	return this;

};

ImageBasedLighting.EquirectangularMaterial.prototype.refreshUniforms = function () {

	this.uniforms.map.value = this.map;

};

ImageBasedLighting.HDRToCubeMap = function(map, renderer, isHDR, resolution) {
	var camera = new THREE.CubeCamera(0.1, 10.0, resolution || 512);
	if (isHDR) {
		var options = { type: THREE.FloatType, format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };
		camera.renderTarget = new THREE.WebGLRenderTargetCube( resolution || 512, resolution || 512, options );
	}

	var scene = new THREE.Scene();

	var material = new EquirectangularMaterial( { map: map } );

	var cube = new THREE.Mesh(new THREE.BoxBufferGeometry(2.0, 2.0, 2.0), material);
	scene.add(cube);

	camera.updateCubeMap(renderer, scene);

	return camera.renderTarget.texture;
}