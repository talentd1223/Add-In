"use strict";

ImageBasedLighting.IBLMaterial = function (parameters) {

    THREE.MeshStandardMaterial.call(this);

    this.type = 'IBLMaterial';

    this.IBLEnabled = true;
    this.debug = 0;

    this.gamma = 2.2;

    this.color = new THREE.Color(0xffffff);

    this.roughness = 0.5;
    this.metalness = 0.5;
    this.originRoughness = 0.5;
    this.originMetalness = 0.5;

    this.opacity = 1.0;

    this.aoMap = null;

    this.IBLMaps = null;

    this.shift = 0.18;
    this.A = 0.27;
    this.B = 0.29;
    this.C = 0.052;
    this.D = 0.2;
    this.E = 0.0;
    this.F = 0.18;
    this.scale = 0.897105;

    this.emissive = new THREE.Color();

    this.defines = {};
    this.uniforms = THREE.UniformsUtils.merge( [

        THREE.ShaderLib.standard.uniforms,

        {

            IBLEnabled: { value: true },
            debug: { value: 0 },

            gamma: { value: 2.2 },

            albedo: { value: new THREE.Color(0xffffff) },

            aoMap: { value: null },

            irradianceMap: { value: null },
            prefilterMap: {value: null },
            brdfMap: { value: null },

            shift: { value: 0.18 },
            A: { value: 0.27 },
            B: { value: 0.29 },
            C: { value: 0.052 },
            D: { value: 0.2 },
            E: { value: 0.0 },
            F: { value: 0.18 },
            scale: { value: 0.897105 },
        }

    ] );

    this.lights = true;

    this.vertexShader = ImageBasedLighting.IBLVertexShader;

    this.fragmentShader = ImageBasedLighting.IBLFragmentShader;

    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    this.defaultAttributeValues = {
        'color': [1, 1, 1],
        'uv': [0, 0],
        'uv2': [0, 0]
    };

    if (parameters !== undefined) {

        if (parameters.attributes !== undefined) {

            console.error('IBLMaterial: attributes should now be defined in THREE.BufferGeometry instead.');

        }

        this.setValues(parameters);

    }

    //this.refreshUniforms();

};

ImageBasedLighting.IBLMaterial.prototype = Object.create(THREE.MeshStandardMaterial.prototype);
ImageBasedLighting.IBLMaterial.prototype.constructor = ImageBasedLighting.IBLMaterial;

ImageBasedLighting.IBLMaterial.prototype.copy = function (source) {

    THREE.MeshStandardMaterial.prototype.copy.call(this, source);

    this.IBLEnabled = source.IBLEnabled;
    this.debug = source.debug;

    this.gamma = source.gamma;

    this.color.copy(source.color);

    this.aoMap = source.aoMap;

    this.IBLMaps = source.IBLMaps;

    this.shift = source.shift;
    this.A = source.A;
    this.B = source.B;
    this.C = source.C;
    this.D = source.D;
    this.E = source.E;
    this.F = source.F;
    this.scale = source.scale;

    return this;

};

ImageBasedLighting.IBLMaterial.prototype.refreshUniforms = function () {

    this.uniforms.IBLEnabled.value = this.IBLEnabled;
    this.uniforms.debug.value = this.debug;
    this.uniforms.gamma.value = this.gamma;

    this.uniforms.albedo.value.set(this.color);

    this.uniforms.aoMap.value = this.aoMap;

    if(this.IBLMaps)
    {
        this.uniforms.irradianceMap.value = this.IBLMaps.irradianceMap;
        this.uniforms.prefilterMap.value = this.IBLMaps.prefilterMap;
        this.uniforms.brdfMap.value = this.IBLMaps.brdfMap;
    }


    this.uniforms.shift.value = this.shift;
    this.uniforms.A.value = this.A;
    this.uniforms.B.value = this.B;
    this.uniforms.C.value = this.C;
    this.uniforms.D.value = this.D;
    this.uniforms.E.value = this.E;
    this.uniforms.F.value = this.F;
    this.uniforms.scale.value = this.scale;

};