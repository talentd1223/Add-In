
ImageBasedLighting.irradiance_vs = [

	"varying vec3 pos;",
	//"varying vec3 Normal;",

	"void main() {",
	"	pos = vec3(modelMatrix * vec4(position, 1.0));",
	//"	Normal = mat3(modelMatrix) * normal;",
	"	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
	"}"

].join('\n');

ImageBasedLighting.irradiance_fs = [

	"varying vec3 pos;",
	"uniform samplerCube environmentMap;",
	//"uniform sampler2D HammersleyTable;",

	"const float PI = 3.14159265358979;",
	//"const float INV_PI = 1.0 / PI;",

	"vec3 caluIrradiance(vec3 normal, vec3 up, vec3 right)",
	"{",
	"	vec3 irradiance = vec3(0.0);",

	"	int count = 0;",
	"	const int phiSampleCount = 1024;",
	"	const int thetaSampleCount = phiSampleCount / 4;",
	"	float phiDelta = 2.0 * PI / float(phiSampleCount);",
	"	float thetaDelta = 0.5 * PI / float(thetaSampleCount);",
	"	for(int i = 0; i < phiSampleCount; ++i)",
	"	{",
	"		float phi = float(i) * phiDelta;",
	"		for(int j = 0; j < thetaSampleCount; ++j)",
	"		{",
	"			float theta = float(j) * thetaDelta;",
	"			vec3 tangentSample = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));",
	"			vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal; ",

	"			irradiance += textureCube(environmentMap, sampleVec, 0.0).rgb * cos(theta) * sin(theta);",
	"			++count;",
	"		}",
	"	}",
	"	irradiance = PI * irradiance * (1.0 / float(count));",

	"	return irradiance;",
	"}",

	"void main()",
	"{",
	"	vec3 normal = normalize(pos);",
	"	vec3 up = vec3(0.0, 1.0, 0.0);",
	"	vec3 right = cross(up, normal);",
	"	up = cross(normal, right);",
	"	vec3 irradiance = caluIrradiance(normal, up, right);",

	"	gl_FragColor = vec4(irradiance, 1.0);",
	"}"

].join('\n');

ImageBasedLighting.IrradianceMap = function(envMap, resolution) {

	this.cubeTexture = null;

	this.resolution = resolution || 32;

	this.irradianceMaterial = new THREE.ShaderMaterial({
		vertexShader: ImageBasedLighting.irradiance_vs,
		fragmentShader: ImageBasedLighting.irradiance_fs,
		uniforms: {
			environmentMap: { value: envMap },
		},
		
		lights:false,
		side: THREE.BackSide
	});

	this.cube = new THREE.Mesh(new THREE.BoxBufferGeometry(2.0, 2.0, 2.0), this.irradianceMaterial);

};

ImageBasedLighting.IrradianceMap.prototype.constructor = ImageBasedLighting.IrradianceMap;

ImageBasedLighting.IrradianceMap.prototype.generateMap = function(renderer, isHDR) {

	var scene = new THREE.Scene();
	scene.add(this.cube);

	var cubecamera = new THREE.CubeCamera(0.1, 10.0, this.resolution);
	if (isHDR) {
		var options = { type: THREE.FloatType, format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };
		cubecamera.renderTarget = new THREE.WebGLRenderTargetCube( this.resolution, this.resolution, options );
	}

	cubecamera.updateCubeMap(renderer, scene);
	this.cubeTexture = cubecamera.renderTarget.texture;
	
};