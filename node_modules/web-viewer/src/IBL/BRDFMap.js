
var ImageBasedLighting = ImageBasedLighting || {};

ImageBasedLighting.brdf_vs = [

	"varying vec2 vUV;",

	"void main() {",
	"	vUV = uv;",
	"	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
	"}"

].join('\n');

ImageBasedLighting.brdf_fs = [

	"varying vec2 vUV;",
	"uniform sampler2D HammersleyTable;",

	"const float PI = 3.14159265358979;",

	"float GGX(float NdotV, float alpha)",
	"{",
	"	float alpha2 = pow(alpha, 2.0);",
	"	return 2.0 * NdotV / (NdotV + sqrt(alpha2 + (1.0 - alpha2) * NdotV * NdotV));",
	"}",

	"float G_Smith(float NdotV, float NdotL, float roughness)",
	"{",
	"	float alpha = pow(roughness, 2.0);",
	"	return GGX(NdotV, alpha) * GGX(NdotL, alpha);",
	"}",
	
	"vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)",
	"{",
	"	float a = roughness * roughness;",

	"	float Phi = 2.0 * PI * Xi.x; ",
	"	float CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y)); ",
	"	float SinTheta = sqrt(1.0 - CosTheta * CosTheta);",

	"	vec3 H;",
	"	H.x = SinTheta * cos(Phi); ",
	"	H.y = SinTheta * sin(Phi); ",
	"	H.z = CosTheta;",

	"	vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0); ",
	"	vec3 TangentX = normalize(cross(UpVector, N)); ",
	"	vec3 TangentY = cross(N, TangentX);",

		// Tangent to world space 
	"	return normalize(TangentX * H.x + TangentY * H.y + N * H.z);",
	"}",

	"vec2 IntegrateBRDF(float NdotV, float roughness)",
	"{",
	"	vec3 N = vec3(0.0, 0.0, 1.0);",
	"	vec3 V = vec3(sqrt(1.0 - NdotV * NdotV), 0.0, NdotV);",
	"	vec2 result = vec2(0.0, 0.0);",

	"	const int NumSamples = 1024;",
	"	for (int i = 0; i < NumSamples; i++)",
	"	{",
	"		float u = float(i) / float(NumSamples);",
	"		vec2 Xi = vec2(u, texture2D(HammersleyTable, vec2(u)).r);",
	"		vec3 H = ImportanceSampleGGX(Xi, N, roughness);",
	"		vec3 L = 2.0 * dot(V, H) * H - V;",

	"		float NdotL = saturate(L.z);",
	"		float NdotH = saturate(H.z);",
	"		float VdotH = saturate(dot(V, H));",
	"		float NdotV = saturate(dot(N, V));",
	"		if (NdotL > 0.0)",
	"		{",
	"			float G = G_Smith(NdotV, NdotL, roughness);",
	"			float G_Vis = G * VdotH / (NdotH * NdotV); ",
	"			float F = pow(1.0 - VdotH, 5.0);",
	"			result.x += (1.0 - F) * G_Vis;",
	"			result.y += F * G_Vis;",
	"		}",
	"	}",

	"	return result / float(NumSamples);",
	"}",

	"void main()",
	"{",
	"	vec2 brdf = IntegrateBRDF(vUV.x, vUV.y);",
	"	gl_FragColor = vec4(brdf, 0.0, 1.0);",
	"}"

].join('\n');

ImageBasedLighting.BRDFMap = function(hammersleyTable, resolution) {

	this.texture = null;

	this.resolution = resolution || 512;

	this.brdfMaterial = new THREE.ShaderMaterial({
		vertexShader: ImageBasedLighting.brdf_vs,
		fragmentShader: ImageBasedLighting.brdf_fs,
		uniforms: {
			HammersleyTable: { value: hammersleyTable }
		},
		lights:false
	});

	this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry( window.innerWidth, window.innerHeight), this.brdfMaterial);
	this.quad.position.z = -100;

};

ImageBasedLighting.BRDFMap.prototype.constructor = ImageBasedLighting.BRDFMap;

ImageBasedLighting.BRDFMap.prototype.generateMap = function(renderer) {

	var scene = new THREE.Scene();
	scene.add(this.quad);

	var camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -10000, 10000 );
	camera.position.z = 100;

	var rtt = new THREE.WebGLRenderTarget(this.resolution, this.resolution, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } );
	renderer.render(scene, camera, rtt, true);

	this.texture = rtt.texture;

};