
ImageBasedLighting.HDRTextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	// override in sub classes
	this.hdrLoader = new THREE.RGBELoader();

};

ImageBasedLighting.HDRTextureLoader.prototype.load = function ( url, onLoad, onProgress, onError ) {

    var RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {

		var e = sourceArray[ sourceOffset + 3 ];
		var scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

		destArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;
		destArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;
		destArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;

    };
    
    var texture = new THREE.DataTexture();

    this.hdrLoader.load(url, function(tex, texData){
        tex.flipY = true;
        tex.type = THREE.FloatType;
        tex.format = THREE.RGBFormat;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;

        var RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {

            var e = sourceArray[ sourceOffset + 3 ];
            var scale = Math.pow( 2.0, e - 128.0 ) / 256.0;

            destArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;
            destArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;
            destArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;

        };

        var numElements = tex.image.width * tex.image.height * 3;
        var floatdata = new Float32Array( numElements );

        for ( var j = 0; j < numElements; j ++ ) {

            RGBEByteToRGBFloat( tex.image.data, j * 4, floatdata, j * 3 );

        }

        tex.image.data = floatdata;

        texture = tex;

        if (onLoad) onLoad(texture);

    }, onProgress, onError);

    
    return texture;

};