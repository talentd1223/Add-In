
CLOUD.RenderComposer = function()
{
    var _renderer;

    var _camera;

    var _ssaoPass,
        _fxaaPass,
        _copyPass;

    var _w, _h;

    var _colorTarget = null;
    var _writeTarget = null;


    var _settings = {};

    var _mainSceneRenderFinished = false;
    var _startNewPass = true;
    // in one render process, do we finish all the render pass
    var _renderFinished = true;

    var _sceneNotChanged = false;

    this.init = function (glrenderer, width, height) {

        createRenderPasses();

        if (!glrenderer) {
            console.log("You need a gl context to make a renderer. Things will go downhill from here.");
            return;
        }

        _w = width;
        _h = height;

        _renderer = glrenderer;


        this.setSize(width, height, true);
    };

    function createRenderPasses() {

        function setNoDepthNoBlend(pass) {
            pass.material.blending = THREE.NoBlending;
            pass.material.depthWrite = false;
            pass.material.depthTest = false;
        }

        _fxaaPass = new CLOUD.ShaderPass(FXAAShader);
        setNoDepthNoBlend(_fxaaPass);

        _copyPass = new CLOUD.ShaderPass(CopyShader);
        setNoDepthNoBlend(_copyPass);
    };

    this.cleanup = function () {
        if (_colorTarget) {
            _colorTarget.dispose();
            _colorTarget = null;
        }

        if (_writeTarget) {
            _writeTarget.dispose();
            _writeTarget = null;
        }


    };

    this.setSize = function (w, h, force) {

        _w = w;
        _h = h;

        //Just a way to release the targets in cases when
        //we use a custom render context and don't need this one
        //temporarily
        if ((w === 0 && h === 0) || !_renderer) {
            this.cleanup();
            return;
        }

        var sw = 0 | (w * _renderer.getPixelRatio());
        var sh = 0 | (h * _renderer.getPixelRatio());

        _settings.deviceWidth = sw;
        _settings.deviceHeight = sh;

        var resX = 1.0 / sw;
        var resY = 1.0 / sh;


        //Just the regular color target -- shares depth buffer
        //with the depth target.
        if (force || !_colorTarget || _colorTarget.width != sw || _colorTarget.height != sh) {

            this.cleanup();

            _colorTarget = new THREE.WebGLRenderTarget(sw, sh,
                {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBAFormat,
                    stencilBuffer: false
                });
            _colorTarget.texture.generateMipmaps = false;
            _colorTarget.texture.name = '_color_rt1';

            _writeTarget = _colorTarget.clone();
            _writeTarget.texture.name = '_write_rt1';

        }

        _fxaaPass.uniforms[ 'uResolution' ].value.set(resX, resY);
    };

    // TODO: 需要管理渲染状态，mainscene的渲染是增量式的，其他的渲染是一次性完成的
    //
    this.renderIncrement  = function(mainScene, camera){
        // clear render targets
        if (!_colorTarget && _w) {
            this.setSize();
        } else if (!_colorTarget && !_w) {
            return;
        }

        var enableSSAO = CLOUD.GlobalData.SSAO;
        if (enableSSAO && !_ssaoPass) {
            _ssaoPass = new THREE.SSAOPass(mainScene, camera, _w, _h);
            //_ssaoPass.onlyAO = true;
        }

        _camera = camera;
        if (_startNewPass) {

            if (!_sceneNotChanged) {

                _renderer.resetIncrementRender();

                _renderer.setClearColor(0x000000, 0);
                _renderer.clearTarget(_colorTarget, true, true, false); //clear color and depth buffer
            }
            _startNewPass = false;
            _renderFinished = false;
        }

        _renderer.autoClear = false;

        if (!_mainSceneRenderFinished) {

            _mainSceneRenderFinished = _renderer.render(mainScene, _camera, _colorTarget);
            
            if ( _mainSceneRenderFinished)
            {
                _copyPass.renderToScreen = true;
                _renderer.resetIncrementRender();
                _copyPass.render(_renderer, null, _colorTarget);

                _renderFinished = true;
            }

        }

        return _mainSceneRenderFinished;
    };

    this.render  = function(mainScene, camera) {
        // clear render targets
        if (!_colorTarget && _w) {
            this.setSize();
        } else if (!_colorTarget && !_w) {
            return;
        }

        var enableSSAO = CLOUD.GlobalData.SSAO;
        if (enableSSAO && !_ssaoPass) {
            _ssaoPass = new THREE.SSAOPass(mainScene, camera, _w, _h);
            //_ssaoPass.onlyAO = true;
        }

        _camera = camera;
        if (_startNewPass) {

            if (!_sceneNotChanged) {
                _renderer.setClearColor(0x000000, 0);
                _renderer.clearTarget(_colorTarget, true, true, false); //clear color and depth buffer
            }
            _startNewPass = false;
        }

        _renderer.autoClear = false;

        if (!_sceneNotChanged) {
            _renderer.render(mainScene, _camera, _colorTarget);
        }

        var _renderPass = enableSSAO ? _ssaoPass : _copyPass;
        _renderPass.renderToScreen = true;
        _renderPass.render(_renderer, null, _colorTarget);
    

    };

    // start a full new rendering
    this.restart = function(sceneNotChanged, hoverId) {

        _sceneNotChanged = !!sceneNotChanged;

        _mainSceneRenderFinished = false;
        _startNewPass = true;
    };

    this.finish = function() {
        if (_startNewPass && !_renderFinished) {
            _renderFinished = true;
        }
    }
};

CLOUD._renderComposer = new CLOUD.RenderComposer();