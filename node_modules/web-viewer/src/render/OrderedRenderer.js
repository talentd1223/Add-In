CLOUD.RenderGroup = function () {

    var opaqueObjects = [];
    var transparentObjects = [];

    var opaqueObjectsLastIndex = -1;
    var transparentObjectsLastIndex = -1;

    var renderingIdx = 0;
    var opaqueFinished = false;
    var transparentFinished = false;
    var timeStart = 0;
    var timeEnd = 0;
    var timeElapse = 0;

    this.getOpaqueObjects = function () {
        return opaqueObjects;
    };

    this.getTransparentObjects = function () {
        return transparentObjects;
    };

    function painterSortStable(a, b) {
        if (a.material.id !== b.material.id) {
            return a.material.id - b.material.id;
        } else {
            return a.id - b.id;
        }
    }

    function painterSortStableZ(a, b) {

        if (a.z !== b.z) {
            return a.z - b.z;
        }
        else if (a.material.id !== b.material.id) {
            return a.material.id - b.material.id;
        }
        else {
            return a.id - b.id;
        }
    }

    function reversePainterSortStable(a, b) {
        if (a.z !== b.z) {
            return b.z - a.z;
        } else {
            return a.id - b.id;
        }
    }

    this.destroy = function () {
        opaqueObjects = [];
        transparentObjects = [];
    };

    this.restart = function () {
        renderingIdx = 0;
        opaqueFinished = false;
        transparentFinished = false;
    };

    this.prepare = function () {
        this.restart();
        opaqueObjectsLastIndex = -1;
        transparentObjectsLastIndex = -1;
    };

    this.renderableCount = function () {
        return opaqueObjectsLastIndex + transparentObjectsLastIndex;
    };

    function isFinished() {
        return opaqueFinished && transparentFinished;
    }

    this.pushRenderItem = function (object, geometry, material, z, group) {

        var array, index;
        if (material.transparent) {
            array = transparentObjects;
            index = ++transparentObjectsLastIndex;

        } else {
            array = opaqueObjects;
            index = ++opaqueObjectsLastIndex;
        }

        // recycle existing render item or grow the array
        var renderItem = array[index];
        if (renderItem !== undefined) {

            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.z = z;
            renderItem.group = group;

        } else {
            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                z: z,
                group: group
            };
            // assert( index === array.length );
            //array.push( renderItem );
            array[index] = renderItem;
        }

    };

    this.sortRenderList = function (cullEnd) {

        opaqueObjects.length = opaqueObjectsLastIndex + 1;
        transparentObjects.length = transparentObjectsLastIndex + 1;

        //console.log(opaqueObjects.length + transparentObjects.length);

        if (cullEnd) {
            //console.time("sort");
            opaqueObjects.sort(painterSortStable);
            transparentObjects.sort(reversePainterSortStable);
            //console.timeEnd("sort");
        }
    };

    function renderObjects(renderer, renderList, camera, lights, fog, update) {

        timeStart = Date.now();

        var len = renderList.length;
        var i = renderingIdx;

        for (; i < len; i++) {

            var renderItem = renderList[i];
            var object = renderItem.object;
            var material = renderItem.material;
            var group = renderItem.group;
            var geometry = renderItem.geometry;

            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
            object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

            geometry = renderer.updateObject(object);
            renderer.renderBufferDirect(camera, fog, geometry, material, object, group);

            // if ((i % 5000) === 4999) {
            //
            //     timeEnd = Date.now();
            //     timeElapse = timeEnd - timeStart;
            //
            //     if (timeElapse > CLOUD.GlobalData.LimitFrameTime) {
            //
            //         renderingIdx = i + 1;
            //         return false;
            //     }
            // }

            timeEnd = Date.now();
            timeElapse = timeEnd - timeStart;

            if (timeElapse > CLOUD.GlobalData.LimitFrameTime) {

                //console.log("timeElapse", [timeElapse, i]);

                renderingIdx = i + 1;
                return false;
            }
        }

        renderingIdx = 0;
        return true;
    }

    this.renderOpaqueObjects = function (renderer, camera, lights, fog, update) {

        if (!opaqueFinished) {
            opaqueFinished = renderObjects(renderer, opaqueObjects, camera, lights, fog, update);
        }

        return opaqueFinished;
    };

    this.renderTransparentObjects = function (renderer, camera, lights, fog, update) {

        if (!transparentFinished) {
            transparentFinished = renderObjects(renderer, transparentObjects, camera, lights, fog, update);
        }

        return transparentFinished;
    };
};

CLOUD.OrderedRenderer = function () {

    // increment culling
    var _cullTicket = 0;
    var _isIncrementalCullFinish = false,
        _isIncrementalRenderFinish = false;
    var _countCullingObject = 0;
    var _countScreenCullOff = 0;
    var _timeStartCull = 0;

    var _renderTicket = 0;

    var _renderGroups = [];

    var _frustum = null;
    var _projScreenMatrix = null;

    var _vector3 = new THREE.Vector3();

    var _isUpdateObjectList = true;
    var _dirtyIncrementList = true;

    this.updateObjectList = function (isUpdate) {
        _isUpdateObjectList = isUpdate;
    };

    this.destroy = function () {

        for (var ii = 0, len = _renderGroups.length; ii < len; ++ii) {
            var group = _renderGroups[ii];
            if (group !== undefined) {
                group.destroy();
            }
        }

    };

    this.restart = function () {

        for (var ii = 0, len = _renderGroups.length; ii < len; ++ii) {
            var group = _renderGroups[ii];
            if (group !== undefined) {
                group.restart();
            }
        }

        _countCullingObject = 0;
        _countScreenCullOff = 0;
        _dirtyIncrementList = true;
        _isIncrementalCullFinish = true;
    };

    this.setFilter = function(filter) {
        // do nothing
        // please remove this method after we remove WebGLRendererByIncrement.setFilterObject()
    }

    function prepareNewFrame() {

        ++_cullTicket;
        if (_cullTicket > 100000)
            _cullTicket = 0;

        for (var ii = 0, len = _renderGroups.length; ii < len; ++ii) {
            var group = _renderGroups[ii];
            if (group !== undefined) {
                group.prepare();
            }
        }
    }

    function computeRenderableCount() {

        var totalCount = 0;
        for (var ii = 0, len = _renderGroups.length; ii < len; ++ii) {
            var group = _renderGroups[ii];
            if (group !== undefined) {
                totalCount += group.renderableCount();
            }
        }
        return totalCount;
    }

    function pushRenderItem(object, geometry, material, z) {

        var renderGroup = _renderGroups[object.renderOrder];
        if (renderGroup === undefined) {
            renderGroup = new CLOUD.RenderGroup();
            _renderGroups[object.renderOrder] = renderGroup;
        }

        renderGroup.pushRenderItem(object, geometry, material, z, null);
    }


    function computeObjectCenter(object) {

        object.modelCenter = new THREE.Vector3();

        if (object.boundingBox) {

            object.boundingBox.getCenter(object.modelCenter);
            object.modelCenter.applyMatrix4(object.matrixWorld);

            _vector3.copy(object.boundingBox.min);
            _vector3.applyMatrix4(object.matrixWorld);

            object.radius = object.modelCenter.distanceTo(_vector3);
        }
        else {

            object.modelCenter.setFromMatrixPosition(object.matrixWorld);

        }
    }

    function sortRenderList() {

        for (var ii = 0, len = _renderGroups.length; ii < len; ++ii) {
            var group = _renderGroups[ii];
            if (group !== undefined) {
                group.sortRenderList(_isIncrementalCullFinish);
            }

        }
    }

    function projectObject(object, camera) {

        if (object.visible === false || object.alive === false)
            return true;

        if (object._cullTicket != _cullTicket /*&& (object.channels.mask & camera.channels.mask) !== 0*/) {

            ++_countCullingObject;

            // TODO: incrmental bug fixing
            // if (_countCullingObject % 5000 == 4999) {
                var diff = Date.now() - _timeStartCull;
                if (diff > 30) {
                    return false;
                }

            // }

            object._cullTicket = _cullTicket;

            if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points) {

                if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {

                    var material = object.material;
                    var geometry = object.geometry;
                    if (material.transparent) {
                        _vector3.setFromMatrixPosition(object.matrixWorld);
                        _vector3.applyMatrix4(_projScreenMatrix);
                        pushRenderItem(object, geometry, material, _vector3.z);
                    } else {
                        pushRenderItem(object, geometry, material, 0);
                    }

                }
            }
        }

        var children = object.children;
        if (children) {
            for (var i = 0, l = children.length; i < l; i++) {

                if (!projectObject(children[i], camera))
                    return false;

            }
        }

        return true;
    }

    function projectLights(scene, lights) {

        lights.length = 0;

        var children = scene.children;

        for (var i = 0, l = children.length; i < l; i++) {

            var object = children[i];
            if (object.isLight) {

                lights.push(object);

            }

        }
    }

    function buildObjectList(scene, camera, lights) {

        if (!_isUpdateObjectList) {
            _isIncrementalCullFinish = true;
            return;
        }

        if (_isIncrementalCullFinish) {

            prepareNewFrame();
            projectLights(scene, lights);
        }

        _timeStartCull = Date.now();

        //console.time("projectObject");
        _isIncrementalCullFinish = projectObject(scene, camera);
        //console.timeEnd("projectObject");
        //console.log("screen cull off: " + _screenCullOffCount);
        sortRenderList();
    }

    this.update = function (frustum, projScreenMatrix) {
        _projScreenMatrix = projScreenMatrix;
        _frustum = frustum;
    };

    function updateRenderTicket() {

        if (!_isUpdateObjectList || _dirtyIncrementList) {
            ++_renderTicket;
        }
        //else {
        //    console.log(_renderTicket);
        //}
        if (_renderTicket > 10000)
            _renderTicket = 0;
    }

    this.render = function (renderer, scene, camera, lights, renderTarget, forceClear, state) {

        updateRenderTicket();

        if (_dirtyIncrementList) {

            CLOUD.Logger.time("build object list");
            buildObjectList(scene, camera, lights);
            CLOUD.Logger.timeEnd("build object list");

            if (!_isIncrementalCullFinish)
                return false;
            else {
                forceClear = true;
                _dirtyIncrementList = false;

                //var count = computeRenderableCount();
                //console.log("renderable " + count);
            }

            renderer.setupLights(lights, camera);
            renderer.setRenderTarget(renderTarget);
        }

        CLOUD.Logger.time("increment render object");
        if (renderer.autoClear || forceClear) {
            renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil, _isUpdateObjectList);
        }

        var fog = scene.fog;

        renderer.setRenderTicket(_renderTicket);

        state.setBlending(THREE.NoBlending);

        // TODO: incrmental bug fixing
         //_isIncrementalRenderFinish = true; //

        for (var ii = _renderGroups.length - 1; ii >= 0; --ii) {
            var group = _renderGroups[ii];
            if (group !== undefined) {
                _isIncrementalRenderFinish = group.renderOpaqueObjects(renderer, camera, lights, fog, _isUpdateObjectList);
                if (!_isIncrementalRenderFinish)
                    break;
            }
        }

        if (_isIncrementalRenderFinish) {

            for (var ii = _renderGroups.length - 1; ii >= 0; --ii) {
                var group = _renderGroups[ii];
                if (group !== undefined) {
                    _isIncrementalRenderFinish = group.renderTransparentObjects(renderer, camera, lights, fog);
                    if (!_isIncrementalRenderFinish)
                        break;
                }
            }
        }

        // Ensure depth buffer writing is enabled so it can be cleared on next render
        // state.setDepthTest(true);
        // state.setDepthWrite(true);
        // state.setColorWrite(true);

        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);

        CLOUD.Logger.timeEnd("increment render object");

        return _isIncrementalRenderFinish;

    };
};