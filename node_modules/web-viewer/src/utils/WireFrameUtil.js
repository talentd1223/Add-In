
CLOUD.Edge = function () {

    this.vertexIndex = new Array(2);
    this.faceIndex = new Array(2);
    
};

CLOUD.RemoveDuplicateIndex = function (vertices, indices) {

    var vertexCount = vertices.length / 3;
    var positions = new Array(vertexCount);
    var sortArray = new Array(vertexCount);

    function compareVertex(lhs, rhs) {
        
        var lVertex = positions[lhs];
        var rVertex = positions[rhs];

        return lVertex.x != rVertex.x ? lVertex.x - rVertex.x : 
            lVertex.y != rVertex.y ? lVertex.y - rVertex.y : lVertex.z - rVertex.z;

    }

    function sortFunction(lhs, rhs) {

        var compare = compareVertex(lhs, rhs);
        return compare == 0 ? lhs - rhs : compare;

    }

    for (var i = 0; i < vertexCount; ++i) {

        positions[i] = new THREE.Vector3(vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]);
        sortArray[i] = i;

    }

    sortArray.sort(sortFunction);

    var duplicateMap = {};
    var index = sortArray[0];
    for (var i = 1; i < vertexCount; ++i) {

        if (compareVertex(index, sortArray[i]) == 0) {
            duplicateMap[sortArray[i]] = index;
        }
        else {
            index = sortArray[i];
        }

    }

    var newIndices = new Array(indices.length);
    for (var i = 0; i < indices.length; ++i) {
        
        if (duplicateMap.hasOwnProperty(indices[i])) {
            newIndices[i] = duplicateMap[indices[i]];
        }
        else {
            newIndices[i] = indices[i];
        }

    }

    return newIndices;

}

CLOUD.RemoveDuplicateVertex = function (vertices, indices) {

    function sortFunction(lhs, rhs) {
        return lhs - rhs;
    }

    var newIndices = CLOUD.RemoveDuplicateIndex(vertices, indices);
    newIndices.sort(sortFunction);

    var newVertex = new Array();
    var index = newIndices[0];
    newVertex.push(index);

    for(var i = 1; i < newIndices.length; ++i) {

        if (newIndices[i] != index) {

            index = newIndices[i];
            newVertex.push(index);

        }

    }

    return newVertex.sort(sortFunction);

}

CLOUD.BuildEdge = function (vertices, indices, angelTol) {

    angelTol = (angelTol==undefined? Math.PI/4 : angelTol);

    var duplicateIndices = CLOUD.RemoveDuplicateIndex(vertices, indices);

    var maxEdgeCount = duplicateIndices.length;
    var vertexCount = vertices.length / 3;
    var firstEdge = new Array(vertexCount + maxEdgeCount);
    var nextEdge = vertexCount;
    var triangleCount = duplicateIndices.length / 3;

    for(var i = 0; i < vertexCount; ++i)
        firstEdge[i] = -1;

    var edgeArray = new Array(maxEdgeCount);

    var edgeCount = 0;
    for(var i = 0; i < triangleCount; ++i) {

        var i1 = duplicateIndices[i * 3 + 2];
        for (var j = 0; j < 3; ++j)
        {
            var isSwap = false;
            var i2 = duplicateIndices[i * 3 + j];
            if (i1 > i2)
            {
                isSwap = true;
                var temp = i1;
                i1 = i2;
                i2 = temp;
            }

            var newEdge = new CLOUD.Edge();
            newEdge.vertexIndex[0] = i1;
            newEdge.vertexIndex[1] = i2;
            newEdge.faceIndex[0] = i;
            newEdge.faceIndex[1] = i;

            var edgeIndex = firstEdge[i1];
            if (edgeIndex == -1)
            {
                firstEdge[i1] = edgeCount;
                edgeArray[edgeCount] = newEdge;
                firstEdge[nextEdge + edgeCount] = -1;
                edgeCount++;
            }
            else
            {
                while (true)
                {
                    var edge = edgeArray[edgeIndex];
                    if (edge.vertexIndex[1] == i2)
                    {
                        edge.faceIndex[1] = i;
                        break;
                    }
                    else
                    {
                        var index = firstEdge[nextEdge + edgeIndex];
                        if (index == -1)
                        {
                            firstEdge[nextEdge + edgeIndex] = edgeCount;
                            edgeArray[edgeCount] = newEdge;
                            firstEdge[nextEdge + edgeCount] = -1;
                            edgeCount++;
                            break;
                        }
                        
                        edgeIndex = index;
                    }
                }
            }

            if (!isSwap)
            {
                i1 = i2;
            }
        }

    }

    var edgeIndices = [];
    for (var i = 0; i < edgeCount; ++i) {
        var edge = edgeArray[i];
        if (edge.faceIndex[0] == edge.faceIndex[1]) {
            edgeIndices.push(edge.vertexIndex[0]);
            edgeIndices.push(edge.vertexIndex[1]);
        }
        else {
            var face0 = edge.faceIndex[0];
            var index0 = duplicateIndices[face0 * 3];
            var index1 = duplicateIndices[face0 * 3 + 1];
            var index2 = duplicateIndices[face0 * 3 + 2];

            var pos0 = new THREE.Vector3(vertices[index0 * 3], vertices[index0 * 3 + 1], vertices[index0 * 3 + 2]);
            var pos1 = new THREE.Vector3(vertices[index1 * 3], vertices[index1 * 3 + 1], vertices[index1 * 3 + 2]);
            var pos2 = new THREE.Vector3(vertices[index2 * 3], vertices[index2 * 3 + 1], vertices[index2 * 3 + 2]);

            var dir0 = pos0.sub(pos1);
            var dir1 = pos1.sub(pos2);
            var normal0 = dir0.cross(dir1);
            normal0.normalize();

            var face1 = edge.faceIndex[1];
            index0 = duplicateIndices[face1 * 3];
            index1 = duplicateIndices[face1 * 3 + 1];
            index2 = duplicateIndices[face1 * 3 + 2];

            pos0 = new THREE.Vector3(vertices[index0 * 3], vertices[index0 * 3 + 1], vertices[index0 * 3 + 2]);
            pos1 = new THREE.Vector3(vertices[index1 * 3], vertices[index1 * 3 + 1], vertices[index1 * 3 + 2]);
            pos2 = new THREE.Vector3(vertices[index2 * 3], vertices[index2 * 3 + 1], vertices[index2 * 3 + 2]);

            dir0 = pos0.sub(pos1);
            dir1 = pos1.sub(pos2);
            var normal1 = dir0.cross(dir1);
            normal1.normalize();

            if (Math.abs(normal0.dot(normal1)) < angelTol ) {
                edgeIndices.push(edge.vertexIndex[0]);
                edgeIndices.push(edge.vertexIndex[1]);
            }
        }
    }

    return edgeIndices;

}

CLOUD.GetFaceIndex = function (positions, normals, indices, position, normal) {

    var count = indices.length / 3;
    var indexArray = new Array();
    for (var i = 0 ; i < count; ++i) {

        var face = indices[i * 3];
        var normalTemp = new THREE.Vector3(normals[face * 3], normals[face * 3 + 1], normals[face * 3 + 2]);
        var dot = normalTemp.dot(normal);
        if (Math.abs(dot - 1.0) < 0.001) {
            var pos = new THREE.Vector3(positions[face * 3], positions[face * 3 + 1], positions[face * 3 + 2]);
            var D = -pos.dot(normalTemp);
            var distance = Math.abs(position.dot(normalTemp) + D);
            if (Math.abs(distance) < 3.0) {
                indexArray.push(indices[i * 3], indices[i * 3 + 1], indices[i * 3 + 2]);
            }
        }

    }

    return indexArray;

}