CLOUD.GeomUtil = {

    // createInstancedBufferGeometry: function (mesh, objJSON) {
    //     var instances = objJSON.count;
    //
    //     // 转换buffer
    //     var geometry = new THREE.InstancedBufferGeometry();
    //     geometry.maxInstancedCount = instances;
    //     geometry.addAttribute('position', mesh.getAttribute("position"));
    //     geometry.setIndex(mesh.index);
    //
    //     var transformMatrixs = [];
    //     var userIds = [];
    //     var bboxs = [];
    //     var items = objJSON.items;
    //
    //     for (var key in items) {
    //         var item = items[key];
    //         transformMatrixs.push(item.worldMatrix);
    //         userIds.push(item.userId);
    //         bboxs.push(CLOUD.Utils.box3FromArray(item.bbox));
    //     }
    //
    //     var componentV1 = new THREE.InstancedBufferAttribute(new Float32Array(instances * 4), 4, 1);
    //     for (var i = 0, ul = componentV1.count; i < ul; i++) {
    //         componentV1.setXYZW(i, transformMatrixs[i][0], transformMatrixs[i][1], transformMatrixs[i][2], transformMatrixs[i][3]);
    //     }
    //     geometry.addAttribute('componentV1', componentV1);
    //
    //     var componentV2 = new THREE.InstancedBufferAttribute(new Float32Array(instances * 4), 4, 1);
    //     for (var i = 0, ul = componentV2.count; i < ul; i++) {
    //         componentV2.setXYZW(i, transformMatrixs[i][4], transformMatrixs[i][5], transformMatrixs[i][6], transformMatrixs[i][7]);
    //     }
    //     geometry.addAttribute('componentV2', componentV2);
    //
    //     var componentV3 = new THREE.InstancedBufferAttribute(new Float32Array(instances * 4), 4, 1);
    //     for (var i = 0, ul = componentV3.count; i < ul; i++) {
    //         componentV3.setXYZW(i, transformMatrixs[i][8], transformMatrixs[i][9], transformMatrixs[i][10], transformMatrixs[i][11]);
    //     }
    //     geometry.addAttribute('componentV3', componentV3);
    //
    //     var componentV4 = new THREE.InstancedBufferAttribute(new Float32Array(instances * 4), 4, 1);
    //     for (var i = 0, ul = componentV4.count; i < ul; i++) {
    //         componentV4.setXYZW(i, transformMatrixs[i][12], transformMatrixs[i][13], transformMatrixs[i][14], transformMatrixs[i][15]);
    //     }
    //     geometry.addAttribute('componentV4', componentV4);
    //
    //     // 计算法线，
    //     // 注意：在shader中处理时，应用于法线向量的变换矩阵是顶点变换矩阵的逆转置矩阵
    //     if (geometry.attributes.normal === undefined) {
    //         geometry.computeVertexNormals();
    //     }
    //
    //     geometry.boundingBox = CLOUD.Utils.box3FromArray(objJSON.bbox);
    //
    //     var extProperty = {
    //         bboxs: bboxs,
    //         userIds: userIds,
    //         transformMatrixs: transformMatrixs
    //     };
    //
    //     geometry.extProperty = extProperty;
    //
    //     return geometry;
    // },

    // parseNodeProperties: function (object, objJSON, nodeId, trf) {
    //
    //     //object.name = nodeId;
    //
    //     if (objJSON.userId)
    //         object.name = objJSON.userId;
    //     else
    //         object.name = nodeId;
    //
    //     CLOUD.Utils.parseTransform(object, objJSON, trf);
    // },

    // parseSceneNode: function (object, objJSON, modelManager, level) {
    //
    //     object.sceneId = objJSON.sceneId;
    //
    //     // set world bbox
    //     object.worldBoundingBox = object.boundingBox.clone();
    //     object.worldBoundingBox.applyMatrix4(modelManager.getGlobalTransform());
    //     object.level = objJSON.level;
    //     if (objJSON.order) {
    //         object.out = 1;
    //     }
    //
    //     if (CLOUD.GlobalData.ShowSubSceneBox) {
    //         var clr = 0xff;
    //         clr = clr << (level * 5);
    //
    //         var boxNode = new CLOUD.BBoxNode(object.boundingBox, clr);
    //         CLOUD.Utils.parseTransform(boxNode, objJSON);
    //         object.add(boxNode);
    //     }
    // },

    // parseCylinderNode: function () {
    //
    //     var reg = new RegExp("'", "g");
    //     var startPt = new THREE.Vector3();
    //     var endPt = new THREE.Vector3();
    //     var dir = new THREE.Vector3();
    //     var unitY = new THREE.Vector3(0, 1, 0);
    //
    //     return function (geometryNode, params) {
    //         if (params instanceof Object) {
    //
    //         }
    //         else {
    //             params = params.replace(reg, '"');
    //             params = JSON.parse(params);
    //         }
    //
    //
    //         startPt.fromArray(params.startPt);
    //         endPt.fromArray(params.endPt);
    //
    //         dir.subVectors(endPt, startPt);
    //
    //         var len = dir.length();
    //         dir.normalize();
    //
    //         var radius = params.radius;
    //         if (radius <= 1)
    //             radius = 100;
    //         geometryNode.scale.set(radius, len, radius);
    //         geometryNode.quaternion.setFromUnitVectors(unitY, dir);
    //         geometryNode.position.copy(startPt).addScaledVector(dir, len * 0.5);
    //         geometryNode.updateMatrix();
    //         geometryNode.matrixAutoUpdate = false;
    //     }
    //
    // }(),

    // parseBoxNode: function () {
    //
    //     var _boundingBox = new THREE.Box3();
    //     var _trf = new THREE.Matrix4();
    //
    //     return function (object, objJSON) {
    //         CLOUD.Utils.parseTransform(object, objJSON);
    //
    //         CLOUD.Utils.box3FromArray(objJSON.bbox, _boundingBox)
    //         var boxSize = _boundingBox.getSize();
    //         var center = _boundingBox.getCenter();
    //
    //         _trf.identity();
    //         _trf.scale(boxSize);
    //         _trf.setPosition(center);
    //
    //         object.matrix.multiply(_trf);
    //         object.matrixAutoUpdate = false;
    //     };
    //
    // }(),

    // parseHermitePipe: function (objJSON) {
    //     var reg = new RegExp("'", "g");
    //     var params = objJSON.params;
    //     params = params.replace(reg, '"');
    //     params = JSON.parse(params);
    //     var points = [];
    //
    //     for (var ii = 0, len = params.ctrlPts.length / 3; ii < len; ++ii) {
    //         var pt = new THREE.Vector3();
    //         pt.fromArray(params.ctrlPts, ii * 3);
    //         points.push(pt);
    //     }
    //
    //     var extrudePath = new THREE.CatmullRomCurve3(points);
    //     var tube = new THREE.TubeGeometry(extrudePath, 5, params.radius, 6, false);
    //     var bufferObj = new THREE.BufferGeometry();
    //     bufferObj.fromGeometry(tube);
    //
    //     return bufferObj;
    // },

    // parsePGeomNodeInstance: function (client, objJSON, matObj, trf, unloadable) {
    //
    //     var object = null;
    //
    //     if (objJSON.geomType == "pipe" || objJSON.geomType == "tube") {
    //
    //         var geometry = CLOUD.GeomUtil.UnitCylinderInstance;
    //         object = new THREE.Mesh(geometry, matObj);
    //
    //         if (!object) {
    //             return null;
    //         }
    //
    //
    //         CLOUD.GeomUtil.parseCylinderNode(object, objJSON.params);
    //
    //     }
    //     else if (objJSON.geomType == "box") {
    //
    //         var geometry = CLOUD.GeomUtil.UnitBoxInstance;
    //         object = new THREE.Mesh(geometry, matObj);
    //
    //         if (!object) {
    //             return null;
    //         }
    //         CLOUD.GeomUtil.parseBoxNode(object, objJSON);
    //
    //     }
    //     else if (objJSON.geomType == "hermitepipe") {
    //         var geometry = CLOUD.GeomUtil.parseHermitePipe(objJSON);
    //         object = new THREE.Mesh(geometry, matObj);
    //
    //         if (!object) {
    //             return null;
    //         }
    //     }
    //     else {
    //         CLOUD.Logger.log("unknonw geometry!");
    //         return object;
    //     }
    //
    //     if (trf) {
    //         var localTrf = trf.clone();
    //         localTrf.multiply(object.matrix);
    //         object.matrix = localTrf;
    //         object.matrixAutoUpdate = false;
    //     }
    //
    //     return object;
    // },

    EmptyGeometry: new THREE.Geometry(),
    UnitCylinderInstance: new THREE.CylinderBufferGeometry(1, 1, 1, 8, 1, false),
    UnitBoxInstance: new THREE.BoxBufferGeometry(1, 1, 1),
    UnitTextureCylinder: null,
    UnitTextureBox: null,

    initializeUnitInstances: function () {
        if (!CLOUD.GeomUtil.UnitCylinderInstance.boundingBox)
            CLOUD.GeomUtil.UnitCylinderInstance.computeBoundingBox();
        if (!CLOUD.GeomUtil.UnitBoxInstance.boundingBox)
            CLOUD.GeomUtil.UnitBoxInstance.computeBoundingBox();
    },

    destroyUnitInstances: function () {
        CLOUD.GeomUtil.UnitCylinderInstance.dispose();
        CLOUD.GeomUtil.UnitBoxInstance.dispose();
    },

    getBoxData: function (i) {

        // left side
        var vertexArray = [
            [-0.5, -0.5, -0.5,
                -0.5, -0.5, 0.5,
                -0.5, 0.5, -0.5,
                -0.5, 0.5, 0.5],

            // down side
            [-0.5, -0.5, -0.5,
                -0.5, -0.5, 0.5,
                0.5, -0.5, -0.5,
                0.5, -0.5, 0.5],

            // back side
            [-0.5, -0.5, -0.5,
                -0.5, 0.5, -0.5,
                0.5, -0.5, -0.5,
                0.5, 0.5, -0.5],

            // front side
            [-0.5, -0.5, 0.5,
                -0.5, 0.5, 0.5,
                0.5, -0.5, 0.5,
                0.5, 0.5, 0.5],

            // up side
            [-0.5, 0.5, -0.5,
                -0.5, 0.5, 0.5,
                0.5, 0.5, -0.5,
                0.5, 0.5, 0.5],

            // right side
            [0.5, -0.5, -0.5,
                0.5, -0.5, 0.5,
                0.5, 0.5, -0.5,
                0.5, 0.5, 0.5]];

        var indexArray = [
            // left
            [2,1,0,1,2,3],
            // down
            [0,1,2,3,2,1],
            // back
            [2,1,0,1,2,3],
            // front
            [0,1,2,3,2,1],
            // up
            [2,1,0,1,2,3],
            // right
            [0,1,2,3,2,1]
        ];

        var normalArray = [[], [], [], [], [], []];
        for (var j = 0; j < 4; ++j) {
            normalArray[0].push(-1.0, 0.0, 0.0);
        }
        for (var j = 0; j < 4; ++j) {
            normalArray[1].push(0.0, -1.0, 0.0);
        }
        for (var j = 0; j < 4; ++j) {
            normalArray[2].push(0.0, 0.0, -1.0);
        }
        for (var j = 0; j < 4; ++j) {
            normalArray[3].push(0.0, 0.0, 1.0);
        }
        for (var j = 0; j < 4; ++j) {
            normalArray[4].push(0.0, 1.0, 0.0);
        }
        for (var j = 0; j < 4; ++j) {
            normalArray[5].push(1.0, 0.0, 0.0);
        }

        var uvArray = [[], [], [], [], [], []];
        uvArray[0] = uvArray[2] = uvArray[4] = [-0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5];
        uvArray[1] = uvArray[3] = uvArray[5] = [0.5, -0.5, 0.5, 0.5, -0.5, -0.5, -0.5, 0.5];

        return {"vertex": vertexArray[i], 
                "normal": normalArray[i],
                "uv": uvArray[i],
                "index": indexArray[i]};

    },

    getBoxData2: function () {

        // left side
        var vertexArray = [
            [-0.5, -0.5, -0.5,
            -0.5, -0.5, 0.5,
            -0.5, 0.5, -0.5,
            -0.5, 0.5, 0.5],

            // down side
            [-0.5, -0.5, -0.5,
            -0.5, -0.5, 0.5,
            0.5, -0.5, -0.5,
            0.5, -0.5, 0.5],

            // back side
            [-0.5, -0.5, -0.5,
            -0.5, 0.5, -0.5,
            0.5, -0.5, -0.5,
            0.5, 0.5, -0.5],

            // front side
            [-0.5, -0.5, 0.5,
            -0.5, 0.5, 0.5,
            0.5, -0.5, 0.5,
            0.5, 0.5, 0.5],

            // up side
            [-0.5, 0.5, -0.5,
            -0.5, 0.5, 0.5,
            0.5, 0.5, -0.5,
            0.5, 0.5, 0.5],

            // right side
            [0.5, -0.5, -0.5,
            0.5, -0.5, 0.5,
            0.5, 0.5, -0.5,
            0.5, 0.5, 0.5]];

        var indexArray = [
            // left
             [2,1,0,1,2,3],
            // down
            [0,1,2,3,2,1],
            // back
            [2,1,0,1,2,3],
            // front
            [0,1,2,3,2,1],
            // up
            [2,1,0,1,2,3],
            // right
            [0,1,2,3,2,1]
        ];

        var normalArray = [[], [], [], [], [], []];
        for (var j = 0; j < 4; ++j) {
            normalArray[0].push(-1.0, 0.0, 0.0);
        }
        for (var j = 0; j < 4; ++j) {
            normalArray[1].push(0.0, -1.0, 0.0);
        }
        for (var j = 0; j < 4; ++j) {
            normalArray[2].push(0.0, 0.0, -1.0);
        }
        for (var j = 0; j < 4; ++j) {
            normalArray[3].push(0.0, 0.0, 1.0);
        }
        for (var j = 0; j < 4; ++j) {
            normalArray[4].push(0.0, 1.0, 0.0);
        }
        for (var j = 0; j < 4; ++j) {
            normalArray[5].push(1.0, 0.0, 0.0);
        }

        var uvArray = [[], [], [], [], [], []];
        uvArray[0] = uvArray[2] = uvArray[4] = [-0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5];
        uvArray[1] = uvArray[3] = uvArray[5] = [0.5, -0.5, 0.5, 0.5, -0.5, -0.5, -0.5, 0.5];

        return function(idx){
            return {
                vertex: vertexArray[idx],
                normal: normalArray[idx],
                uv: uvArray[idx],
                index: indexArray[idx]
            };
        };
    }(),

    getPipeData2: function () {

        var vertex = [
            0.5, 0.0, 0.5,
            0.353530875, 0.353530875, 0.5,
            0.0, 0.5, 0.5,
            -0.353530875, 0.353530875, 0.5,
            -0.5, 0.0, 0.5,
            -0.353530875, -0.353530875, 0.5,
            0.0, -0.5, 0.5,
            0.353530875, -0.353530875, 0.5,
            0.5, 0.0, 0.5,

            // edge_down
            0.5, 0.0, -0.5,
            0.353530875, 0.353530875, -0.5,
            0.0, 0.5, -0.5,
            -0.353530875, 0.353530875, -0.5,
            -0.5, 0.0, -0.5,
            -0.353530875, -0.353530875, -0.5,
            0.0, -0.5, -0.5,
            0.353530875, -0.353530875, -0.5,
            0.5, 0.0, -0.5,

            // front
            0.5, 0.0, 0.5,
            0.353530875, 0.353530875, 0.5,
            0.0, 0.5, 0.5,
            -0.353530875, 0.353530875, 0.5,
            -0.5, 0.0, 0.5,
            -0.353530875, -0.353530875, 0.5,
            0.0, -0.5, 0.5,
            0.353530875, -0.353530875, 0.5,

            // back
            0.5, 0.0, -0.5,
            0.353530875, 0.353530875, -0.5,
            0.0, 0.5, -0.5,
            -0.353530875, 0.353530875, -0.5,
            -0.5, 0.0, -0.5,
            -0.353530875, -0.353530875, -0.5,
            0.0, -0.5, -0.5,
            0.353530875, -0.353530875, -0.5
        ];

        var index = [
            // 1
            0, 9, 1,
            1, 9, 10,

            // 2
            1, 10, 2,
            2, 10, 11,

            // 3
            2, 11, 3,
            3, 11, 12,

            // 4
            3, 12, 4,
            4, 12, 13,

            // 5
            4, 13, 5,
            5, 13, 14,

            // 6
            5, 14, 6,
            6, 14, 15,

            // 7
            6, 15, 7,
            7, 15, 16,

            // 8
            7, 16, 8,
            8, 16, 17,

            // front
            18, 19, 20,
            18, 20, 21,
            18, 21, 22,
            18, 22, 23,
            18, 23, 24,
            18, 24, 25,

            // back
            26, 28, 27,
            26, 29, 28,
            26, 30, 29,
            26, 31, 30,
            26, 32, 31,
            26, 33, 32
        ];

        var normal = [
            // edge_up
            1.0, 0.0, 0.0,
            0.7, 0.7, 0.0,
            0.0, 1.0, 0.0,
            -0.7, 0.7, 0.0,
            -1.0, 0.0, 0.0,
            -0.7, -0.7, 0.0,
            0.0, -1.0, 0.0,
            0.7, -0.7, 0.0,
            1.0, 0.0, 0.0,

            // edge_do// edge_downn
            1.0, 0.0, 0.0,
            0.7, 0.7, 0.0,
            0.0, 1.0, 0.0,
            -0.7, 0.7, 0.0,
            -1.0, 0.0, 0.0,
            -0.7, -0.7, 0.0,
            0.0, -1.0, 0.0,
            0.7, -0.7, 0.0,
            1.0, 0.0, 0.0,

            // front
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,

            // back
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0,
            0.0, 0.0, 1.0
        ];

        var uv = [
            // edge_up
            0.0 * 0.125 - 0.5, 0.5,
            1.0 * 0.125 - 0.5, 0.5,
            2.0 * 0.125 - 0.5, 0.5,
            3.0 * 0.125 - 0.5, 0.5,
            4.0 * 0.125 - 0.5, 0.5,
            5.0 * 0.125 - 0.5, 0.5,
            6.0 * 0.125 - 0.5, 0.5,
            7.0 * 0.125 - 0.5, 0.5,
            8.0 * 0.125 - 0.5, 0.5,

            // edge_down
            0.0 * 0.125 - 0.5, -0.5,
            1.0 * 0.125 - 0.5, -0.5,
            2.0 * 0.125 - 0.5, -0.5,
            3.0 * 0.125 - 0.5, -0.5,
            4.0 * 0.125 - 0.5, -0.5,
            5.0 * 0.125 - 0.5, -0.5,
            6.0 * 0.125 - 0.5, -0.5,
            7.0 * 0.125 - 0.5, -0.5,
            8.0 * 0.125 - 0.5, -0.5,

            // front
            0.5, 0.0,
            0.353530875, 0.353530875,
            0.0, 0.5,
            -0.353530875, 0.353530875,
            -0.5, 0.0,
            -0.353530875, -0.353530875,
            0.0, -0.5,
            0.353530875, -0.353530875,

            // back
            0.5, 0.0,
            0.353530875, 0.353530875,
            0.0, 0.5,
            -0.353530875, 0.353530875,
            -0.5, 0.0,
            -0.353530875, -0.353530875,
            0.0, -0.5,
            0.353530875, -0.353530875,
        ];

        return function () {
            return {vertex: vertex, normal: normal, uv: uv, index: index};
        }
    }(),

    getPipeData: function (num_edges){

        if(num_edges === undefined || num_edges < 8)
            num_edges = 8;

        if(num_edges > 256)
            num_edges = 256;

        var PI = 3.14159265357;
        var PIPE_SIZE = 1.0;
        var PIPE_SIZE_HALF = PIPE_SIZE / 2.0;

        var num_vertices = num_edges * 4 + 2;
        var num_indices = ( num_edges * 4 - 4 ) * 3;
        var num_circle = num_edges + 1;

        var step_len = 1.0 / num_edges;
        var step_angle = PI * 2.0 / num_edges;
        var i, n;

        // ini circle buffer
        var circleArray = [];
        for(i = 0; i < num_edges; ++i){
            circleArray.push(PIPE_SIZE_HALF * Math.cos(i * step_angle));
            circleArray.push(PIPE_SIZE_HALF * Math.sin(i * step_angle));
        }
        circleArray.push(PIPE_SIZE_HALF);
        circleArray.push(0.0);

        // add vertices
        var vertexArray = [];
        n = num_circle * 2;
        for(i = 0; i < n; i += 2){
            vertexArray.push(circleArray[i]);
            vertexArray.push(circleArray[i + 1]);
            vertexArray.push(PIPE_SIZE_HALF);
        }
        for(i = 0; i < n; i += 2){
            vertexArray.push(circleArray[i]);
            vertexArray.push(circleArray[i + 1]);
            vertexArray.push(-PIPE_SIZE_HALF);
        }

        n = num_edges * 2;
        for(i = 0; i < n; i += 2){
            vertexArray.push(circleArray[i]);
            vertexArray.push(circleArray[i + 1]);
            vertexArray.push(PIPE_SIZE_HALF);
        }
        for(i = n; i > 0; i -= 2){
            vertexArray.push(circleArray[i]);
            vertexArray.push(circleArray[i + 1]);
            vertexArray.push(-PIPE_SIZE_HALF);
        }

        // add indices
        var indexArray = [];
        var len_edges = num_edges + 1;
        for(i = 0; i < num_edges; ++i){
            indexArray.push(i);
            indexArray.push(i + len_edges);
            indexArray.push(i + 1);

            indexArray.push(i + 1);
            indexArray.push(i + len_edges);
            indexArray.push(i + len_edges + 1);
        }

        var idx_s = num_circle * 2;
        for(i = 1; i < num_edges - 1; ++i){
            indexArray.push(idx_s);
            indexArray.push(idx_s + i);
            indexArray.push(idx_s + i + 1);
        }

        idx_s = idx_s + num_edges;
        for(i = 1; i < num_edges - 1; ++i){
            indexArray.push(idx_s);
            indexArray.push(idx_s + i);
            indexArray.push(idx_s + i + 1);
        }

        // add uv
        var uvArray = [];
        for(i = num_edges; i >= 0; --i){
            uvArray.push(i * step_len - PIPE_SIZE_HALF);
            uvArray.push(-PIPE_SIZE_HALF);
        }
        for(i = num_edges; i >= 0; --i){
            uvArray.push(i * step_len - PIPE_SIZE_HALF);
            uvArray.push(PIPE_SIZE_HALF);
        }

        n = num_edges * 2;
        for(i = 0; i < n; i += 2){
            uvArray.push(circleArray[i]);
            uvArray.push(circleArray[i + 1]);
        }
        for(i = n; i > 0; i -= 2){
            uvArray.push(circleArray[i]);
            uvArray.push(circleArray[i + 1]);
        }

        // add normals
        n = num_vertices * 3;
        var normalArray = [];
        for(i = 0; i < n; ++i){
            normalArray.push(0.0);
        }

        var vA, vB, vC;
        var pA = new THREE.Vector3(), pB = new THREE.Vector3(), pC = new THREE.Vector3();
        var cb = new THREE.Vector3(), ab = new THREE.Vector3();
        for(i = 0; i < num_indices; i += 3){
            vA = indexArray[i] * 3;
            vB = indexArray[i + 1] * 3;
            vC = indexArray[i + 2] * 3;

            pA.fromArray(vertexArray, vA);
            pB.fromArray(vertexArray, vB);
            pC.fromArray(vertexArray, vC);

            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);

            normalArray[vA] += cb.x;
            normalArray[vA + 1] += cb.y;
            normalArray[vA + 2] += cb.z;

            normalArray[vB] += cb.x;
            normalArray[vB + 1] += cb.y;
            normalArray[vB + 2] += cb.z;

            normalArray[vC] += cb.x;
            normalArray[vC + 1] += cb.y;
            normalArray[vC + 2] += cb.z;
        }

        var vector = new THREE.Vector3();
        n = num_vertices * 3;
        for(i = 0; i < n; i += 3){
            vector.fromArray(normalArray, i);
            vector.normalize();
            normalArray[i] = vector.x;
            normalArray[i + 1] = vector.y;
            normalArray[i + 2] = vector.z;
        }

        return {vertex : vertexArray, normal : normalArray, uv : uvArray, index : indexArray, edges : num_edges};
    },

    getUnitTextureCylinder: function () {

        if (CLOUD.GeomUtil.UnitTextureCylinder == null) {

            var data = CLOUD.GeomUtil.getPipeData(32);
            CLOUD.GeomUtil.UnitTextureCylinder = new THREE.BufferGeometry();
            CLOUD.GeomUtil.UnitTextureCylinder.setIndex(data.index);
            CLOUD.GeomUtil.UnitTextureCylinder.addAttribute("position", new THREE.Float32BufferAttribute(data.vertex, 3));
            CLOUD.GeomUtil.UnitTextureCylinder.addAttribute("normal", new THREE.Float32BufferAttribute(data.normal, 3));
            CLOUD.GeomUtil.UnitTextureCylinder.addAttribute("uv", new THREE.Float32BufferAttribute(data.uv, 2));
        }

        return CLOUD.GeomUtil.UnitTextureCylinder;

    },

    getUnitTextureBox: function () {
        if (CLOUD.GeomUtil.UnitTextureBox === null) {
            CLOUD.GeomUtil.UnitTextureBox = new Array(6);
            for (var i = 0; i < 6; ++i) {
                var data = CLOUD.GeomUtil.getBoxData(i);
                CLOUD.GeomUtil.UnitTextureBox[i] = new THREE.BufferGeometry();
                CLOUD.GeomUtil.UnitTextureBox[i].setIndex(data.index);
                CLOUD.GeomUtil.UnitTextureBox[i].addAttribute('position', new THREE.Float32BufferAttribute(data.vertex, 3));
                CLOUD.GeomUtil.UnitTextureBox[i].addAttribute('normal', new THREE.Float32BufferAttribute(data.normal, 3));
                CLOUD.GeomUtil.UnitTextureBox[i].addAttribute('uv', new THREE.Float32BufferAttribute(data.uv, 2));
            }
        }
        return CLOUD.GeomUtil.UnitTextureBox;
    },

    getBoxBufferGeometryWithUvMatrices: function (uvMatricesArrayBuffer) {
        var geometries = [];
        var geoTmp;
        var uvMatrix = new THREE.Matrix3();
        var uvTmp = new THREE.Vector3();
        var hasUV = uvMatricesArrayBuffer ? true : false;
        for (var i = 0; i < 6; ++i) {
            geoTmp = new THREE.BufferGeometry();
            var data = CLOUD.GeomUtil.getBoxData(i);
            if (hasUV) {
                var newUv = [];
                uvMatrix.set(uvMatricesArrayBuffer[i * 6], uvMatricesArrayBuffer[i * 6 + 2], uvMatricesArrayBuffer[i * 6 + 4],
                    uvMatricesArrayBuffer[i * 6 + 1], uvMatricesArrayBuffer[i * 6 + 3], uvMatricesArrayBuffer[i * 6 + 5],
                    0, 0, 1.0);
                for (var j = 0, jLen = data.uv.length; j < jLen; j += 2) {
                    uvTmp.set(data.uv[j], data.uv[j + 1], 1.0);
                    uvTmp.applyMatrix3(uvMatrix);
                    newUv.push(uvTmp.x);
                    newUv.push(uvTmp.y);
                }
                geoTmp.addAttribute('uv', new THREE.Float32BufferAttribute(newUv, 2));
            }
            // index 使用 Uint32Array
            geoTmp.setIndex(new THREE.BufferAttribute(Uint32Array.from(data.index), 1));
            geoTmp.addAttribute('position', new THREE.Float32BufferAttribute(data.vertex, 3));
            geoTmp.addAttribute('normal', new THREE.Float32BufferAttribute(data.normal, 3));
            geometries.push(geoTmp);
        }
        var geometry = CLOUD.GeomUtil.mergeBufferGeometries2(geometries);
        return geometry;
    },

    getPipeBufferGeometryWithUvMatrices: function (uvMatricesArrayBuffer) {
        var data = CLOUD.GeomUtil.getPipeData(32);
        var edges = data.edges;
        var hasUV = (uvMatricesArrayBuffer && uvMatricesArrayBuffer.length === 18) ? true : false;
        var geometry = new THREE.BufferGeometry();
        if (hasUV){
            var matrices = [];
            for (var i = 0, len = uvMatricesArrayBuffer.length; i < len; i += 6) {
                var uvMatrix = new THREE.Matrix3();
                uvMatrix.set(
                    uvMatricesArrayBuffer[i * 6], uvMatricesArrayBuffer[i * 6 + 2], uvMatricesArrayBuffer[i * 6 + 4],
                    uvMatricesArrayBuffer[i * 6 + 1], uvMatricesArrayBuffer[i * 6 + 3], uvMatricesArrayBuffer[i * 6 + 5],
                    0, 0, 1.0);
                matrices.push(uvMatrix);
            }
            var newUv = [];
            var uvTmp = new THREE.Vector3();
            var uvNum1 = (edges + 1)*4 ;//edges = 8时为36
            var uvNum2 = uvNum1 + edges*2;//edges = 8时为52
            for(var j = 0, jLen = data.uv.length; j < jLen; j+=2) {
                uvTmp.set(data.uv[j], data.uv[j + 1], 1.0);
                if (j  < uvNum1) {
                    uvTmp.applyMatrix3(matrices[0]);
                } else if (j < uvNum2 ) {
                    uvTmp.applyMatrix3(matrices[1]);
                } else {
                    uvTmp.applyMatrix3(matrices[2]);
                }
                newUv.push(uvTmp.x);
                newUv.push(uvTmp.y);
            }
            geometry.addAttribute('uv', new THREE.Float32BufferAttribute(newUv, 2));
        }
        // index 使用 Uint32Array
        geometry.setIndex(new THREE.Uint32BufferAttribute(data.index, 1));
        geometry.addAttribute('position', new THREE.Float32BufferAttribute(data.vertex, 3));
        geometry.addAttribute('normal', new THREE.Float32BufferAttribute(data.normal, 3));
        return geometry;
    },

    // 遍历父节点获得当前mesh的世界矩阵
    getWorldMatrixOfMesh: function (mesh) {

        var matList = [];
        var parent = mesh.parent;

        while (parent) {

            matList.push(parent.matrix);
            parent = parent.parent;
        }

        var matTmp = new THREE.Matrix4();

        if (matList.length > 0) {
            matTmp = matList[matList.length - 1];

            for (var i = matList.length - 2; i >= 0; --i) {
                matTmp.multiply(matList[i]);
            }
        }

        var objMatrixWorld = new THREE.Matrix4();
        objMatrixWorld.multiplyMatrices(matTmp, mesh.matrix);

        return objMatrixWorld;
    },

    getWorldPositionOfMesh: function (position, sceneMatrix) {

        if (!sceneMatrix) {
            sceneMatrix = new THREE.Matrix4();
        }

        var inverseScaleMatrix = new THREE.Matrix4();
        inverseScaleMatrix.getInverse(sceneMatrix);

        // 计算世界坐标下的位置
        var worldPosition = position.clone();
        worldPosition.applyMatrix4(inverseScaleMatrix);

        return worldPosition;
    },

    getBoundingBoxWorldOfMesh: function (mesh, sceneMatrix) {

        // 计算世界坐标下的包围盒
        var bBox = mesh.boundingBox;
        if (!bBox) {
            if (!mesh.geometry.boundingBox) {
                mesh.geometry.computeBoundingBox();
            }
            bBox = mesh.geometry.boundingBox;
        }

        var boundingBox = bBox.clone();

        boundingBox.applyMatrix4(mesh.matrixWorld);
        var inverseScaleMatrix = new THREE.Matrix4();
        inverseScaleMatrix.getInverse(sceneMatrix);
        boundingBox.applyMatrix4(inverseScaleMatrix);

        return boundingBox;
    },

    /**
     * @param  {Array<THREE.Mesh>} meshes
     * @return {THREE.BufferGeometry}
     */
    mergeBufferGeometries: function ( meshes , indicesGroup) {

        var isIndexed = meshes[0].geometry.index !== null;

        var attributesUsed = new Set( Object.keys( meshes[0].geometry.attributes ) );
        var morphAttributesUsed = new Set( Object.keys( meshes[0].geometry.morphAttributes ) );

        var attributes = {};
        var morphAttributes = {};

        var mergedGeometry = new THREE.BufferGeometry();

        for ( var i = 0; i < meshes.length; ++ i ) {

            var geometry = meshes[i].geometry;

            // ensure that all geometries are indexed, or none

            if ( isIndexed !== ( geometry.index !== null ) ) {
                return null;
            }

            // gather attributes, exit early if they're different

            for ( var name in geometry.attributes ) {

                if ( !attributesUsed.has( name ) ) {
                    console.log("attributes not Used: ", name);
                    return null;
                }

                if ( attributes[ name ] === undefined ) {
                    attributes[ name ] = [];
                }

                attributes[ name ].push( geometry.attributes[ name ] );

            }

            // gather morph attributes, exit early if they're different

            for ( var name in geometry.morphAttributes ) {

                if ( !morphAttributesUsed.has( name ) ) {
                    return null;
                }

                if ( morphAttributes[ name ] === undefined ) {
                    morphAttributes[ name ] = [];
                }

                morphAttributes[ name ].push( geometry.morphAttributes[ name ] );

            }

            // gather .userData

            if ( geometry.userData !== undefined ) {

                mergedGeometry.userData = mergedGeometry.userData || {};
                mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];
                mergedGeometry.userData.mergedUserData.push( geometry.userData );

            }

        }

        // merge indices

        if ( isIndexed ) {

            var indexOffset = 0;
            var indexList = [];
            var indexTotal = 0;//

            for ( var i = 0; i < meshes.length; ++ i ) {

                var index = meshes[ i ].geometry.index;

                if ( indexOffset > 0 ) {

                    index = index.clone();

                    for ( var j = 0; j < index.count; ++ j ) {

                        index.setX( j, index.getX( j ) + indexOffset );

                    }

                }

                indexList.push( index );
                indexOffset += meshes[ i ].geometry.attributes.position.count;

                if (indicesGroup[meshes[ i ].name] === void 0) {
                    indicesGroup[meshes[ i ].name] = [];
                }

                indicesGroup[meshes[ i ].name].push({nodeId: meshes[ i ].nodeId, indexStart:indexTotal, indexCount:index.count});
                indexTotal += index.count;//
            }

            var mergedIndex = this.mergeBufferAttributes( indexList );

            if ( !mergedIndex ) {
                return null;
            }

            mergedGeometry.index = mergedIndex;

        }

        // merge attributes

        for ( var name in attributes ) {

            var mergedAttribute = this.mergeBufferAttributes( attributes[ name ] );

            if ( ! mergedAttribute ) {
                return null;
            }

            mergedGeometry.addAttribute( name, mergedAttribute );

        }

        // merge morph attributes

        for ( var name in morphAttributes ) {

            var numMorphTargets = morphAttributes[ name ][ 0 ].length;

            if ( numMorphTargets === 0 ) {
                break;
            }

            mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
            mergedGeometry.morphAttributes[ name ] = [];

            for ( var i = 0; i < numMorphTargets; ++ i ) {

                var morphAttributesToMerge = [];

                for ( var j = 0; j < morphAttributes[ name ].length; ++ j ) {

                    morphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );

                }

                var mergedMorphAttribute = this.mergeBufferAttributes( morphAttributesToMerge );

                if ( !mergedMorphAttribute ) {
                    return null;
                }

                mergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );

            }

        }

        return mergedGeometry;

    },

    mergeBufferGeometries2: function ( geometries ) {

        var isIndexed = geometries[ 0 ].index !== null;

        var attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );

        var attributes = {};

        var mergedGeometry = new THREE.BufferGeometry();

        for ( var i = 0; i < geometries.length; ++ i ) {

            var geometry = geometries[ i ];

            // ensure that all geometries are indexed, or none

            if ( isIndexed !== ( geometry.index !== null ) ) return null;

            // gather attributes, exit early if they're different

            for ( var name in geometry.attributes ) {

                if ( !attributesUsed.has( name ) ) return null;

                if ( attributes[ name ] === undefined ) attributes[ name ] = [];

                attributes[ name ].push( geometry.attributes[ name ] );

            }

        }

        // merge indices

        if ( isIndexed ) {

            var indexOffset = 0;
            var indexList = [];

            for ( var i = 0; i < geometries.length; ++ i ) {

                var index = geometries[ i ].index;

                if ( indexOffset > 0 ) {

                    index = index.clone();

                    for ( var j = 0; j < index.count; ++ j ) {

                        index.setX( j, index.getX( j ) + indexOffset );

                    }

                }

                indexList.push( index );
                indexOffset += geometries[ i ].attributes.position.count;

            }

            var mergedIndex = this.mergeBufferAttributes( indexList );

            if ( !mergedIndex ) return null;

            mergedGeometry.index = mergedIndex;

        }

        // merge attributes

        for ( var name in attributes ) {

            var mergedAttribute = this.mergeBufferAttributes( attributes[ name ] );

            if ( ! mergedAttribute ) return null;

            mergedGeometry.addAttribute( name, mergedAttribute );

        }

        return mergedGeometry;

    },

    /**
     * @param {Array<THREE.BufferAttribute>} attributes
     * @return {THREE.BufferAttribute}
     */
    mergeBufferAttributes: function ( attributes ) {

        var TypedArray;
        var itemSize;
        var normalized;
        var arrayLength = 0;

        for ( var i = 0; i < attributes.length; ++ i ) {

            var attribute = attributes[ i ];

            if ( attribute.isInterleavedBufferAttribute ) {
                return null;
            }

            if ( TypedArray === undefined ) {
                TypedArray = attribute.array.constructor;
            }
            if ( TypedArray !== attribute.array.constructor ) {
                return null;
            }

            if ( itemSize === undefined ) {
                itemSize = attribute.itemSize;
            }
            if ( itemSize !== attribute.itemSize ) {
                return null;
            }

            if ( normalized === undefined ) {
                normalized = attribute.normalized;
            }
            if ( normalized !== attribute.normalized ) {
                return null;
            }

            arrayLength += attribute.array.length;

        }

        var array = new TypedArray( arrayLength );
        var offset = 0;

        for ( var j = 0; j < attributes.length; ++ j ) {

            array.set( attributes[ j ].array, offset );

            offset += attributes[ j ].array.length;

        }

        return new THREE.BufferAttribute( array, itemSize, normalized );

    },

    applyMatrix3ToBuffer : function () {
        var v1 = new THREE.Vector3();

        return function applyMatrix3ToBuffer( matrix, array ) {

            for ( var i = 0, len = array.length; i < len; i += 3 ) {

                v1.x = array[i + 0];
                v1.y = array[i + 1];
                v1.z = array[i + 2];

                v1.applyMatrix3( matrix );

                array[ i + 0 ] = v1.x;
                array[ i + 1 ] = v1.y;
                array[ i + 2 ] = v1.z;

            }

            return array;

        };
    }(),

    applyMatrix4ToBuffer: function () {
        var v1 = new THREE.Vector3();

        return function applyMatrix4ToBuffer( matrix, array ) {

            for ( var i = 0, len = array.length; i < len; i += 3 ) {

                v1.x = array[i + 0];
                v1.y = array[i + 1];
                v1.z = array[i + 2];

                v1.applyMatrix4( matrix );

                array[ i + 0 ] = v1.x;
                array[ i + 1 ] = v1.y;
                array[ i + 2 ] = v1.z;

            }

            return array;

        };
    }(),

    normalizeBuffer: function (array) {
        var x, y, z, n;

        for ( var i = 0, il = array.length; i < il; i += 3 ) {

            x = array[i];
            y = array[i + 1];
            z = array[i + 2];

            n = 1.0 / Math.sqrt( x * x + y * y + z * z );

            array[ i + 0 ] = x * n;
            array[ i + 1 ] = y * n;
            array[ i + 2 ] = z * n;

        }
    }
};

CLOUD.GeomUtil.getBoxMBuffer = (function () {
    var j, jLen;
    var vertex = [];
    var normal = [];
    var index = [];
    var indexOffset = 0;

    for (var i = 0; i < 6; ++i) {
        var boxData = CLOUD.GeomUtil.getBoxData2(i);
        for (j = 0, jLen = boxData.vertex.length; j < jLen; j++) {
            vertex.push(boxData.vertex[j]);
        }

        for (j = 0, jLen = boxData.index.length; j < jLen; j++) {
            index.push(boxData.index[j] + indexOffset);
        }
        indexOffset += boxData.vertex.length / 3;

        for (j = 0, jLen = boxData.normal.length; j < jLen; j++) {
            normal.push(boxData.normal[j]);
        }
    }

    return function (uvMatricesArrayBuffer) {
        var uv = null;

        if (uvMatricesArrayBuffer) {
            var uvMatrix = new THREE.Matrix3();
            var uvTmp = new THREE.Vector3();
            uv = [];
            for (var i = 0; i < 6; ++i) {
                var data = CLOUD.GeomUtil.getBoxData2(i);
                uvMatrix.set(uvMatricesArrayBuffer[i * 6], uvMatricesArrayBuffer[i * 6 + 2], uvMatricesArrayBuffer[i * 6 + 4],
                    uvMatricesArrayBuffer[i * 6 + 1], uvMatricesArrayBuffer[i * 6 + 3], uvMatricesArrayBuffer[i * 6 + 5],
                    0, 0, 1.0);
                for (var j = 0, jLen = data.uv.length; j < jLen; j += 2) {
                    uvTmp.set(data.uv[j], data.uv[j + 1], 1.0);
                    uvTmp.applyMatrix3(uvMatrix);
                    uv.push(uvTmp.x);
                    uv.push(uvTmp.y);
                }
            }
        }

        return {vertex: vertex, normal: normal, uv: uv, index: index};
    }
})();

CLOUD.GeomUtil.getPipeMBuffer = (function () {
    var data2 = CLOUD.GeomUtil.getPipeData2();
    var vertex = data2.vertex;
    var normal = data2.normal;
    var index = data2.index;

    return function (uvMatricesArrayBuffer) {

        var uv = null;
        var hasUV = (uvMatricesArrayBuffer && uvMatricesArrayBuffer.length === 18) ? true : false;

        if (hasUV){
            uv = [];
            var matrices = [];
            for (var i = 0, len = uvMatricesArrayBuffer.length; i < len; i += 6) {
                var uvMatrix = new THREE.Matrix3();
                uvMatrix.set(
                    uvMatricesArrayBuffer[i * 6], uvMatricesArrayBuffer[i * 6 + 2], uvMatricesArrayBuffer[i * 6 + 4],
                    uvMatricesArrayBuffer[i * 6 + 1], uvMatricesArrayBuffer[i * 6 + 3], uvMatricesArrayBuffer[i * 6 + 5],
                    0, 0, 1.0);
                matrices.push(uvMatrix);
            }

            var data = CLOUD.GeomUtil.getPipeData2();
            var uvTmp = new THREE.Vector3();
            for(var j = 0, jLen = data.uv.length; j < jLen; j+=2) {
                uvTmp.set(data.uv[j], data.uv[j + 1], 1.0);
                if (j  < 36) {
                    uvTmp.applyMatrix3(matrices[0]);
                } else if (j < 52 ) {
                    uvTmp.applyMatrix3(matrices[1]);
                } else {
                    uvTmp.applyMatrix3(matrices[2]);
                }
                uv.push(uvTmp.x);
                uv.push(uvTmp.y);
            }
        }

        return {vertex: vertex, normal: normal, uv: uv, index: index};
    }
})();