CLOUD.CameraInfo = function (name, position, target, up, version) {
    this.name = name;
    this.position = position;
    this.target = target;
    this.up = up;

    // 0：老版本, 1: 新版版
    this.version = (version === undefined) ? 1 : version; // 用于兼容处理
};

CLOUD.CameraUtil = {

    // 创建相机信息
    createCameraInfo: function (cameraControl) {
        var camera = cameraControl.camera;
        var camInfo = new CameraInfo(cameraControl.getCameraName(), camera.position, camera.target, camera.up);
        return JSON.stringify(camInfo);
    },

    // camera = {"position":"26513.603437903, -14576.4810728955, 15107.6582255056","direction":"-220.050259546712, 169.277369901229, -125.801809656091","up":"0, 0, 304.8"}
    transformCamera: function (camera, scene) {

        var position = new THREE.Vector3();

        var str2float = function (strarr) {
            return [parseFloat(strarr[0]), parseFloat(strarr[1]), parseFloat(strarr[2])];
        };

        position.fromArray(str2float(camera.position.split(",")));
        var dir = new THREE.Vector3();
        dir.fromArray(str2float(camera.direction.split(",")));
        var up = new THREE.Vector3();
        up.fromArray(str2float(camera.up.split(",")));

        var target = new THREE.Vector3();
        target.addVectors(position, dir);

        position.applyMatrix4(scene.rootNode.matrix);
        target.applyMatrix4(scene.rootNode.matrix);

        var rotMat = new THREE.Matrix4();
        rotMat.makeRotationFromEuler(scene.rootNode.rotation);
        up.applyMatrix4(rotMat);
        up.normalize();

        return new CLOUD.CameraInfo(camera.name, position, target, up);
    },

    parseCameraInfo: function (jsonStr) {
        if (!jsonStr)
            return null;

        var jsonObj = JSON.parse(jsonStr);

        if (!jsonObj.hasOwnProperty("position") ||
            !jsonObj.hasOwnProperty("target") ||
            !jsonObj.hasOwnProperty("up"))
            return null;

        // 老版数据没有name属性
        var name = jsonObj.name || 'persp';

        var position = new THREE.Vector3();
        position.x = jsonObj.position.x;
        position.y = jsonObj.position.y;
        position.z = jsonObj.position.z;

        var target = new THREE.Vector3();
        target.x = jsonObj.target.x;
        target.y = jsonObj.target.y;
        target.z = jsonObj.target.z;

        var up = new THREE.Vector3();
        up.x = jsonObj.up.x;
        up.y = jsonObj.up.y;
        up.z = jsonObj.up.z;

        // 老版本数据 jsonObj.version === undefined
        var version = (jsonObj.version === undefined) ? 0 : jsonObj.version; // 注意：这里和构造函数的默认值不同

        return new CLOUD.CameraInfo(name, position, target, up, version);
    },

    /**
     * 局部坐标(相对于canvas)转正规化坐标
     *
     * @param {object} point - 局部坐标(相对于canvas) {x:0, y:0, z:0}
     * @param {Number} width - canvas区域宽度
     * @param {Number} height - canvas区域高度
     * @return {object} 正规化坐标[-1, 1] {x:0, y:0, z:0}
     */
    canvasToNormalized: function (point, width, height) {

        var result = {x: 0, y: 0, z: 0};

        result.x = point.x / width * 2 - 1;
        result.y = -point.y / height * 2 + 1;
        result.z = point.z || 0;

        return result;
    },

    /**
     * 正规化坐标转局部坐标(相对于canvas)
     *
     * @param {object} point - 正规化坐标[-1, 1] {x:0, y:0, z:0}
     * @param {Number} width - canvas区域宽度
     * @param {Number} height - canvas区域高度
     * @return {object} 局部坐标(相对于canvas) {x:0, y:0, z:0}
     */
    normalizedToCanvas: function (point, width, height) {

        var result = {x: 0, y: 0, z: 0};

        result.x = Math.floor(0.5 * (point.x + 1) * width + 0.5);
        result.y = Math.floor(-0.5 * (point.y - 1) * height + 0.5);
        result.z = point.z || 0;

        return result;
    },

    /**
     * 绘图空间坐标(场景变换后)转客户坐标(相对于canvas)
     *
     * @param {object} camera - 相机对象
     * @param {object} point - 世界坐标(场景变换后) {x:0, y:0, z:0}
     * @param {Number} width - canvas区域宽度
     * @param {Number} height - canvas区域高度
     * @return {object} 客户坐标(相对于canvas) {x:0, y:0, z:0}
     */
    drawingToCanvas: function (camera, point, width, height) {

        var normalizedPoint = new THREE.Vector3(point.x, point.y, point.z);
        normalizedPoint.project(camera);

        var result = this.normalizedToCanvas(normalizedPoint, width, height);

        return result;
    },

    /**
     * 绘图空间坐标(场景变换后)转客户坐标(相对于canvas)
     *
     * @param {object} camera - 相机对象
     * @param {object} start - 世界坐标起点(场景变换后) {x:0, y:0, z:0}
     * @param {object} end - 世界坐标终点(场景变换后) {x:0, y:0, z:0}
     * @param {Number} width - canvas区域宽度
     * @param {Number} height - canvas区域高度
     * @return {object} 客户坐标(相对于canvas) {start:{x:0, y:0, z:0}, end:{x:0, y:0, z:0}}
     */
    drawingPointsToCanvas: function (camera, start, end, width, height) {

        var result = {};

        var inverseMatrix = new THREE.Matrix4().getInverse(camera.matrixWorld);

        var _start = new THREE.Vector3(start.x, start.y, start.z);
        _start.applyMatrix4(inverseMatrix);

        var _end = new THREE.Vector3(end.x, end.y, end.z);
        _end.applyMatrix4(inverseMatrix);

        if (_start.z > 0 && _end.z > 0) {
            return null;
        }

        var direction = _start.clone().sub(_end);
        direction.normalize();
        if (_start.z > 0) {

            var length = (_start.z + camera.near) / direction.z;
            _start.sub(direction.multiplyScalar(length));

        }
        else if (_end.z > 0) {

            var length = (_end.z + camera.near) / direction.z;
            _end.sub(direction.multiplyScalar(length));

        }

        _start.applyMatrix4(camera.projectionMatrix);
        _end.applyMatrix4(camera.projectionMatrix);

        result.start = this.normalizedToCanvas(_start, width, height);
        result.end = this.normalizedToCanvas(_end, width, height);

        return result;
    },

    /**
     * 客户坐标(相对于canvas)转绘图空间(场景变换后)
     *
     * @param {object} camera - 相机对象
     * @param {object} point - 客户坐标((相对于canvas) {x:0, y:0, z:0}
     * @param {Number} width - canvas区域宽度
     * @param {Number} height - canvas区域高度
     * @return {object} 绘图空间坐标(场景变换后) {x:0, y:0, z:0}
     */
    canvasToDrawing: function (camera, point, width, height) {

        // 转正规化坐标
        var normalizedPoint = this.canvasToNormalized(point, width, height);

        var result = new THREE.Vector3(normalizedPoint.x, normalizedPoint.y, normalizedPoint.z);
        result.unproject(camera);

        return {x: result.x, y: result.y, z: result.z};
    },

    intersectBoxByRay: function (ray, box) {

        var tmin, tmax, tymin, tymax, tzmin, tzmax;

        var invdirx = 1 / ray.direction.x,
            invdiry = 1 / ray.direction.y,
            invdirz = 1 / ray.direction.z;

        var origin = ray.origin;

        if (invdirx >= 0) {

            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;

        } else {

            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;

        }

        if (invdiry >= 0) {

            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;

        } else {

            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;

        }

        if ((tmin > tymax) || (tymin > tmax)) return null;

        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN

        if (tymin > tmin || tmin !== tmin) tmin = tymin;

        if (tymax < tmax || tmax !== tmax) tmax = tymax;

        if (invdirz >= 0) {

            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;

        } else {

            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;

        }

        if ((tmin > tzmax) || (tzmin > tmax)) return null;

        if (tzmin > tmin || tmin !== tmin) tmin = tzmin;

        if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

        //return point closest to the ray (positive side)

        if (tmax < 0) return null;

        return tmin >= 0 ? tmin : tmax;

    },

    intersectObjectWithFrustum: (function() {

        var box = new THREE.Box3();

        return function (object, frustum) {

            if (object.boundingBox && !(object instanceof THREE.Mesh)) {

                box.copy(object.boundingBox);

            } else {

                var geometry = object.geometry;

                if (geometry.boundingBox === null) {
                    geometry.computeBoundingBox();
                }

                box.copy(geometry.boundingBox);
            }

            box.applyMatrix4(object.matrixWorld);

            return frustum.intersectsBox(box);
        }
    })()

};