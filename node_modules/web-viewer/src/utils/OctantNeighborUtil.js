CLOUD.OctantNeighborUtil = function (camera, root) {
    this.camera = camera;
    this.root = root;           // octree root node

    // flag to search neighbor octant of the direct neighbor octant
    this.searchNeighborOfNeighbor = false;
    // flag to get the child octant of neighbor octant if the neighbor is not leaf node
    this.containChildOfNeighbor = false;

    // octant list which contains camera, from leaf to root
    this.containedOctants = [];
    
    // nIndex index in containedOctants
    this.father = function (nIndex) {
        nIndex++;
        if (nIndex < this.containedOctants.length) {
            return this.containedOctants[nIndex];
        }
        
        return null;
    };

    this.adjFace = function (I, sonType) {
        return faceAdjTable[I*8+sonType];
    };

    this.adjEdge = function (I, sonType) {
        return edgeAdjTable[I*8+sonType];
    };

    this.adjVertex = function (I, sonType) {
        return I == sonType;
    };

    this.refelectFace = function (I, sonType) {
        return faceRefTable[I*8+sonType];
    };

    this.refelectEdge = function (I, sonType) {
        return edgeRefTable[I*8+sonType];
    };

    this.refelectVertex = function (I, sonType) {
        return this.OctType.MAXTYPEID - sonType;
    };

    this.common_face_edge = function (I, sonType) {
        return edgeOfComFaceTable[I*8+sonType];
    };

    this.common_face_vertex = function (I, sonType) {
        return vertOfComFaceTable[I*8+sonType];
    };

    this.common_edge = function (I, sonType) {
        return commonEdgeTable[I*8+sonType];
    };
    
    // get child node of 'octant' in direction 'sonType'
    this.son= function (octant, sonType) {
        var i;
        var length = octant.childOctants.length;
        for (i = 0; i < length; i++) {
            if (octant.childOctants[i].octType == sonType) {
                return octant.childOctants[i];
            }
        }

        return null;
    };

    // direction
    this.FaceType = {
        L : 0,
        R : 1,
        D : 2,
        U : 3,
        B : 4,
        F : 5,
        UNKNOWN : 6
    };

    this.EdgeType = {
        LD : 0,
        LU : 1,
        LB : 2,
        LF : 3,
        RD : 4,
        RU : 5,
        RB : 6,
        RF : 7,
        DB : 8,
        DF : 9,
        UB : 10,
        UF : 11,
        UNKNOWN : 12
    };

    this.OctType = { // also VertexType
        RUF : 0,
        LUF : 1,
        RDF : 2,
        LDF : 3,
        RUB : 4,
        LUB : 5,
        RDB : 6,
        LDB : 7,
        MAXTYPEID : 7
    };


//
// ADJ table
//
// Face table
//                    RUF    LUF    RDF    LDF    RUB    LUB    RDB    LDB
    var faceAdjTable = [ false, true,  false,  true,  false, true,  false, true,  // L
        true,  false, true,   false, true,  false, true,  false, // R
        false, false, true,   true,  false, false, true,  true,  // D
        true,  true,  false,  false, true,  true,  false, false, // U
        false, false, false,  false, true,  true,  true,  true,  // B
        true,  true,  true,   true,  false, false, false, false];// F

// Edge table
    var edgeAdjTable = [ false, false, false,  true,  false, false, false, true,  // LD
        false, true,  false,  false, false, true,  false, false, // LU
        false, false, false,  false, false, true,  false, true,  // LB
        false, true,  false,  true,  false, false, false, false, // LF
        false, false, true,   false, false, false, true,  false, // RD
        true,  false, false,  false, true,  false, false, false, // RU
        false, false, false,  false, true,  false, true,  false, // RB
        true,  false, true,   false, false, false, false, false, // RF
        false, false, false,  false, false, false, true,  true,  // DB
        false, false, true,   true,  false, false, false, false, // DF
        false, false, false,  false, true,  true,  false, false, // UB
        true,  true,  false,  false, false, false, false, false];// UF

//
// REFLECT table
//
// Face table
//                   RUF LUF RDF LDF RUB LUB RDB LDB
    var faceRefTable = [  1,  0,  3,  2,  5,  4,  7,  6,   // L
        1,  0,  3,  2,  5,  4,  7,  6,   // R
        2,  3,  0,  1,  6,  7,  4,  5,   // D
        2,  3,  0,  1,  6,  7,  4,  5,   // U
        4,  5,  6,  7,  0,  1,  2,  3,   // B
        4,  5,  6,  7,  0,  1,  2,  3];  // F

// Edge table
//                   0   1   2   3   4   5   6   7
//                  RUF LUF RDF LDF RUB LUB RDB LDB
    var edgeRefTable = [ 3,  2,  1,  0,  7,  6,  5,  4,  // LD  0
        3,  2,  1,  0,  7,  6,  5,  4,  // LU  1
        5,  4,  7,  6,  1,  0,  3,  2,  // LB  2
        5,  4,  7,  6,  1,  0,  3,  2,  // LF  3
        3,  2,  1,  0,  7,  6,  5,  4,  // RD  4
        3,  2,  1,  0,  7,  6,  5,  4,  // RU  5
        5,  4,  7,  6,  1,  0,  3,  2,  // RB  6
        5,  4,  7,  6,  1,  0,  3,  2,  // RF  7
        6,  7,  4,  5,  2,  3,  0,  1,  // DB  8
        6,  7,  4,  5,  2,  3,  0,  1,  // DF  9
        6,  7,  4,  5,  2,  3,  0,  1,  // UB  10
        6,  7,  4,  5,  2,  3,  0,  1]; // UF  11

// Common Face table
//
// Edge table
//                        RUF LUF RDF LDF RUB LUB RDB LDB
    var edgeOfComFaceTable = [ 6,  0,  2,  6,  6,  0,  2,  6,  // LD  0
        3,  6,  6,  0,  3,  6,  6,  0,  // LU  1
        6,  0,  6,  0,  4,  6,  4,  6,  // LB  2
        5,  6,  5,  6,  6,  0,  6,  0,  // LF  3
        1,  6,  6,  2,  1,  6,  6,  2,  // RD  4
        6,  3,  1,  6,  6,  3,  1,  6,  // RU  5
        1,  6,  1,  6,  6,  4,  6,  4,  // RB  6
        6,  5,  6,  5,  1,  6,  1,  6,  // RF  7
        6,  6,  2,  2,  4,  4,  6,  6,  // DB  8
        5,  5,  6,  6,  6,  6,  2,  2,  // DF  9
        3,  3,  6,  6,  6,  6,  4,  4,  // UB  10
        6,  6,  5,  5,  3,  3,  6,  6]; // UF  11

// Vertex table
//                        RUF LUF RDF LDF RUB LUB RDB LDB
    var vertOfComFaceTable = [ 6,  6,  6,  5,  6,  3,  1,  6,   // RUF
        6,  6,  5,  6,  3,  6,  6,  0,   // LUF
        6,  5,  6,  6,  1,  6,  6,  2,   // RDF
        5,  6,  6,  6,  6,  0,  2,  6,   // LDF
        6,  3,  1,  6,  6,  6,  6,  4,   // RUB
        3,  6,  6,  0,  6,  6,  4,  6,   // LUB
        1,  6,  6,  2,  6,  4,  6,  6,   // RDB
        6,  0,  2,  6,  1,  6,  6,  6];  // LDB

// Common Edge table
//                      0   1   2   3   4   5   6   7
//                     RUF LUF RDF LDF RUB LUB RDB LDB
    var commonEdgeTable = [ 12, 11, 7,  12, 5,  12, 12, 12,  // RUF
        11, 12, 12, 3,  12, 1,  12, 12,  // LUF
        7,  12, 12, 9,  12, 12, 4,  12,  // RDF
        12, 3,  9,  12, 12, 12, 12, 0,   // LDF
        5,  12, 12, 12, 12, 10, 6,  12,  // RUB
        12, 1,  12, 12, 10, 12, 12, 2,   // LUB
        12, 12, 4,  12, 6,  12, 12, 8,   // RDB
        12, 12, 12, 0,  12, 2,  8,  12]; // LDB
};

// Locate a face-neighbor of node P, of size greater than
// or equal to P, in direction I. If such a node does not
// exist, then return NIL.
CLOUD.OctantNeighborUtil.prototype.findFaceNeighborImpl
    = function(nIndex, I) {

    var ret = {node: null, cont: false};

    var ancestors = this.containedOctants;
    var P = ancestors[nIndex];
    
    if (nIndex >= ancestors.length) {
        return ret;
    }

    if (this.father(nIndex) && this.adjFace(I, P.octType)) {
        ret = this.findFaceNeighborImpl(nIndex+1, I);
    } else {
        ret.node = this.father(nIndex);
        ret.cont = true;
    }

    if (ret.cont && ret.node !== null && ret.node.childOctants.length > 0) {
        // get child node
        var Q = this.son(ret.node, this.refelectFace(I, P.octType));
        if (Q) {
            return {node: Q, cont: true};
        }
        else {
            return {node: ret.node, cont: false};
        }
    }

    return ret;
};

CLOUD.OctantNeighborUtil.prototype.findFaceNeighbor
    = function(nIndex, I) {

    var ret = this.findFaceNeighborImpl(nIndex, I);

    if (ret.node && !ret.node.isRoot()) {
        return ret.node;
    }

    return null;
};

// Locate an edge-neighbor of node P, of size greater 
// than or equal to P, in direction I. If such a node
// does not exist, then return NIL.
CLOUD.OctantNeighborUtil.prototype.findEdgeNeighborImpl
    = function(nIndex, I) {

    var ret = {node: null, cont: false};

    var ancestors = this.containedOctants;
    var P = ancestors[nIndex];

    if (nIndex >= ancestors.length) {
        return ret;
    }

    if (this.father(nIndex)) {
        if (this.adjEdge(I, P.octType)) {
            ret = this.findEdgeNeighborImpl(nIndex+1, I);
        } else if (this.common_face_edge(I, P.octType) !== this.FaceType.UNKNOWN) {
            ret = this.findFaceNeighborImpl(nIndex+1, this.common_face_edge(I, P.octType));
        } else {
            ret.node = this.father(nIndex);
            ret.cont = true;
        }
    }

    if (ret.cont && ret.node !== null && ret.node.childOctants.length > 0) {
        // get child node
        var Q = this.son(ret.node, this.refelectEdge(I, P.octType));
        if (Q) {
            return {node: Q, cont: true};
        }
        else {
            return {node: ret.node, cont: false};
        }
    }

    return ret;
};

CLOUD.OctantNeighborUtil.prototype.findEdgeNeighbor
    = function(nIndex, I) {

    var ret = this.findEdgeNeighborImpl(nIndex, I);

    if (ret.node && !ret.node.isRoot()) {
        return ret.node;
    }

    return null;
};

// Locate a vertex-neighbor of node P, of size greater than
// or equal to P, in direction I. If such a node does not 
// exist, then return NIL.
CLOUD.OctantNeighborUtil.prototype.findVertexNeighborImpl
    = function(nIndex, I) {

    var ret = {node: null, cont: false};
    var ancestors = this.containedOctants;
    var P = ancestors[nIndex];

    if (nIndex >= ancestors.length) {
        return ret;
    }

    if (this.father(nIndex)) {
        if (this.adjVertex(I, P.octType)) {
            ret = this.findVertexNeighborImpl(nIndex+1, I);
        } else if (this.common_edge(I, P.octType) !== this.EdgeType.UNKNOWN) {
            ret = this.findVertexNeighborImpl(nIndex+1, this.common_edge(I, P.octType));
        } else if (this.common_face_vertex(I, P.octType) != this.FaceType.UNKNOWN) {
            ret = this.findVertexNeighborImpl(nIndex+1, this.common_face_vertex(I, P.octType));
        } else {
            ret.node = this.father(nIndex);
            ret.cont = true;
        }
    }

    if (ret.cont && ret.node !== null && ret.node.childOctants.length > 0) {
        // get child node
        var Q = this.son(ret.node, this.refelectVertex(I, P.octType));
        if (Q) {
            return {node: Q, cont: true};
        }
        else {
            return {node: ret.node, cont: false};
        }
    }

    return ret;
};

CLOUD.OctantNeighborUtil.prototype.findVertexNeighbor
    = function(nIndex, I) {

    var ret = this.findVertexNeighborImpl(nIndex, I);

    if (ret.node && !ret.node.isRoot()) {
        return ret.node;
    }

    return null;
};

// 查找包含照相机的八叉树最深层叶子节点，如果该叶子节点为空，则使用父节点或
// 中央点离照相机最近的八叉树节点
// 结果是从叶子节点到父节点，一直到根节点的数组，保持在containedOctants中
CLOUD.OctantNeighborUtil.prototype.findContainNode
    = function (octant) {
    var node;
    var camera = this.camera;
    var cameraPos = camera.position;

    var cameraOutsideOctant = cameraPos.x < octant.min.x || cameraPos.x > octant.max.x ||
        cameraPos.y < octant.min.y || cameraPos.y > octant.max.y ||
        cameraPos.z < octant.min.z || cameraPos.z > octant.max.z;

    if (!cameraOutsideOctant)
    {
        //如果该节点是叶子节点，则返回
        if (octant.childOctants.length != 0) {
            // 继续查找子节点
            var i;
            var length;
            for (i = 0, length = octant.childOctants.length; i < length; ++i) {
                node = octant.childOctants[i];
                if (this.findContainNode(node)) {
                    break;
                }
            }
        }

        this.containedOctants.push(octant);
        /*
        // 没有子节点包含照相机，说明子节点塌陷了，根据子节点中心离照相机的距离来确定
        var distance = 0;
        var minDistanceNode = 0;
        for (i = 0, length = octant.childOctants.length; i < length; ++i) {
            node = octant.childOctants[i];

            var camToOctantDir = new THREE.Vector3(node.center.x - cameraPos.x,
                node.center.y - cameraPos.y, node.center.z - cameraPos.z);
            var d = camToOctantDir.lengthSq();
            if (i == 0) {
                distance = d;
            }
            else if (distance > d){
                distance = d;
                minDistanceNode = i;
            }
        }
        */
        return true;
    }

    return false;
};

// octants是包含camera的八叉树叶子节点数组，第一个元素是叶子节点，然后是父节点，最后是根节点
// 根据camera的方向，得到和octant相邻的八叉树节点
CLOUD.OctantNeighborUtil.prototype.findNeighborNode
    = function () {
    var searchNeighborOfNeighbor = this.searchNeighborOfNeighbor;
    var containChildOfNeighbor = this.containChildOfNeighbor;

    var camera = this.camera;
    var octants = this.containedOctants;

    var OctType = this.OctType;
    var EdgeType = this.EdgeType;

    var neighborOctants = [];
    var oct;

    if (octants.length == 0) {
        return neighborOctants; // return empty neighbor list
    }

    var frustum = camera.frustum;
    var i, j, k;
    var dx, dy, dz;


    var min;
    var max;
    var octant = octants[0];
    min = octant.min;
    max = octant.max;

    // follow the camera direction and get neighbor face octant
    var target = camera.target;
    var cameraPos = camera.position;
    var camDir = new THREE.Vector3(target.x - cameraPos.x, target.y - cameraPos.y, target.z - cameraPos.z);

    var cameraRay = new THREE.Ray(cameraPos, camDir);
    var intersectFaces = [];

    // faces: left, right, down, up, back, front

    var box3 = new THREE.Box3(min, max);
    var intersectPoint = cameraRay.intersectBox(box3);

    // get intersect face by camera dir
    if (intersectPoint) {
        // check if the intersect point is in the box plane
        if ( intersectPoint.y == min.y || intersectPoint.y == max.y ) { // Up/Down face intersectPoint.y == max.y or min.y
            if (intersectPoint.x <= max.x && intersectPoint.x >= min.x &&
                intersectPoint.z <= max.z && intersectPoint.z >= min.z) {
                if ( intersectPoint.y == min.y) {
                    intersectFaces.push(2);
                }
                else  {
                    intersectFaces.push(3);
                }
            }
        }
        else if (intersectPoint.z == min.z || intersectPoint.z == max.z) { // Front/Back face
            if (intersectPoint.x <= max.x && intersectPoint.x >= min.x &&
                intersectPoint.y <= max.y && intersectPoint.y >= min.y) {
                if ( intersectPoint.z == min.z) {
                    intersectFaces.push(4);
                }
                else  {
                    intersectFaces.push(5);
                }
            }
        }
        else if (intersectPoint.x == min.x || intersectPoint.x == max.x) { // Left/Right face
            if (intersectPoint.z <= max.z && intersectPoint.z >= min.z &&
                intersectPoint.y <= max.y && intersectPoint.y >= min.y) {
                if ( intersectPoint.x == min.x) {
                    intersectFaces.push(0);
                }
                else  {
                    intersectFaces.push(1);
                }
            }
        }
    }

    if (intersectFaces.length == 0) {
        // something goes wrong
        return neighborOctants;
    }

    // get intersect faces by frustum
    // 1, construct outer box from faces

    dx = max.x - min.x;
    dy = max.y - min.y;
    dz = max.z - min.z;
    if (dy > dx) dx = dy;
    if (dz > dx) dx = dz;
    var octLength = dx;
    var tmpBoxCenter = new THREE.Vector3();
    for (i = 0; i < 6; i++) {
        if (i == intersectFaces[0]) {
            continue;
        }
        tmpBoxCenter.copy(octant.center);
        switch (i) {
            case 0:
                tmpBoxCenter.x -= octLength;
                break;
            case 1:
                tmpBoxCenter.x += octLength;
                break;
            case 2:
                tmpBoxCenter.y -= octLength;
                break;
            case 3:
                tmpBoxCenter.y += octLength;
                break;
            case 4:
                tmpBoxCenter.z -= octLength;
                break;
            case 5:
                tmpBoxCenter.z += octLength;
                break;
        }

        var halfLength = octLength / 2.0;
        var tmpBox3 = new THREE.Box3(new THREE.Vector3(tmpBoxCenter.x - halfLength,
                                                       tmpBoxCenter.y - halfLength,
                                                       tmpBoxCenter.z - halfLength),
                                     new THREE.Vector3(tmpBoxCenter.x + halfLength,
                                                       tmpBoxCenter.y + halfLength,
                                                       tmpBoxCenter.z + halfLength));

        if (frustum.intersectsBox(tmpBox3)) {
            intersectFaces.push(i);
        }
    }

    if (intersectFaces.length > 1) {
        intersectFaces.sort();
    }

 // RUF : 0,     LUF : 1,      RDF : 2,     LDF : 3,
 // RUB : 4,     LUB : 5,      RDB : 6,     LDB : 7,
    if (intersectFaces.length > 2) {
        // find neighbor from vertex
        var vertex = 0;
        for (i = 0; i < intersectFaces.length; i++) {
            for (j = i+1; j < intersectFaces.length; j++) {
                for (k = j+1; k < intersectFaces.length; k++) {
                    if (intersectFaces[i] == 1 && intersectFaces[j] == 3 && intersectFaces[k] == 5) {
                        vertex = OctType.RUF;
                    }
                    else if (intersectFaces[i] == 0 && intersectFaces[j] == 3 && intersectFaces[k] == 5) {
                        vertex = OctType.LUF;
                    }
                    else if (intersectFaces[i] == 1 && intersectFaces[j] == 2 && intersectFaces[k] == 5) {
                        vertex = OctType.RDF;
                    }
                    else if (intersectFaces[i] == 0 && intersectFaces[j] == 2 && intersectFaces[k] == 5) {
                        vertex = OctType.LDF;
                    }
                    else if (intersectFaces[i] == 1 && intersectFaces[j] == 3 && intersectFaces[k] == 4) {
                        vertex = OctType.RUB;
                    }
                    else if (intersectFaces[i] == 0 && intersectFaces[j] == 3 && intersectFaces[k] == 4) {
                        vertex = OctType.LUB;
                    }
                    else if (intersectFaces[i] == 1 && intersectFaces[j] == 2 && intersectFaces[k] == 4) {
                        vertex = OctType.RDB;
                    }
                    else if (intersectFaces[i] == 0 && intersectFaces[j] == 2 && intersectFaces[k] == 4) {
                        vertex = OctType.LDB;
                    }
                    else {
                        continue;
                    } //these faces have no common edge
                    oct = this.findVertexNeighbor(0, vertex);
                    if (oct) {
                        neighborOctants.push(oct);
                        if (containChildOfNeighbor) {
                            this.getChildOfOctant(oct, 2, vertex, neighborOctants);
                        }
                        if (searchNeighborOfNeighbor) {
                            oct = this.getNeighborOfSecondLevel(oct, 2, vertex);
                            if (oct) {
                                neighborOctants.push(oct);
                            }
                        }
                    }
                }
            }
        }
    }

// LD = 0; LU = 1; LB = 2; LF = 3; RD = 4; RU = 5; 
// RB = 6; RF = 7; DB = 8; DF = 9; UB = 10; UF = 11;
    if (intersectFaces.length > 1) {
        // find neighbor from edge
        var edge = 0;
        for (i = 0; i < intersectFaces.length; i++) {
            for (j = i+1; j < intersectFaces.length; j++) {
                if (intersectFaces[i] == 0 && intersectFaces[j] == 2) {
                    edge = EdgeType.LD;
                }
                else if (intersectFaces[i] == 0 && intersectFaces[j] == 3) {
                    edge = EdgeType.LU;
                }
                else if (intersectFaces[i] == 0 && intersectFaces[j] == 4) {
                    edge = EdgeType.LB;
                }
                else if (intersectFaces[i] == 0 && intersectFaces[j] == 5) {
                    edge = EdgeType.LF;
                }
                else if (intersectFaces[i] == 1 && intersectFaces[j] == 2) {
                    edge = EdgeType.RD;
                }
                else if (intersectFaces[i] == 1 && intersectFaces[j] == 3) {
                    edge = EdgeType.RU;
                }
                else if (intersectFaces[i] == 1 && intersectFaces[j] == 4) {
                    edge = EdgeType.RB;
                }
                else if (intersectFaces[i] == 1 && intersectFaces[j] == 5) {
                    edge = EdgeType.RF;
                }
                else if (intersectFaces[i] == 2 && intersectFaces[j] == 4) {
                    edge = EdgeType.DB;
                }
                else if (intersectFaces[i] == 2 && intersectFaces[j] == 5) {
                    edge = EdgeType.DF;
                }
                else if (intersectFaces[i] == 3 && intersectFaces[j] == 4) {
                    edge = EdgeType.UB;
                }
                else if (intersectFaces[i] == 3 && intersectFaces[j] == 5) {
                    edge = EdgeType.UF;
                }
                else {
                    continue;
                } //these faces have no common edge
                oct = this.findEdgeNeighbor(0, edge);
                if (oct) {
                    neighborOctants.push(oct);
                    if (containChildOfNeighbor) {
                        this.getChildOfOctant(oct, 1, edge, neighborOctants);
                    }
                    if (searchNeighborOfNeighbor) {
                        oct = this.getNeighborOfSecondLevel(oct, 1, edge);
                        if (oct) {
                            neighborOctants.push(oct);
                        }
                    }
                }
            }
        }
    }

    for (i = 0; i < intersectFaces.length; i++) {
        // find neighbor from face
        oct = this.findFaceNeighbor(0, intersectFaces[i]);
        if (oct) {
            neighborOctants.push(oct);
            if (containChildOfNeighbor) {
                this.getChildOfOctant(oct, 0, intersectFaces[i], neighborOctants);
            }
            if (searchNeighborOfNeighbor) {
                oct = this.getNeighborOfSecondLevel(oct, 0, intersectFaces[i]);
                if (oct) {
                    neighborOctants.push(oct);
                }
            }
        }
    }

    neighborOctants.sort(function(a, b) {
        if (a.octantId < b.octantId) {
            return -1;
        } else {
            return 1;
        }
    });

    return neighborOctants;
};

// kind: 0 - face, 1 - edge, 2 - vertex
// I: camera direction to search, need to reverse
CLOUD.OctantNeighborUtil.prototype.getChildOfOctant
    = function(octant, kind, I, neighborOctants) {
    var childNum = octant.childOctants.length;
    if (childNum == 0 || octant.depth < 4) {
        return;
    }

    var faceType = this.FaceType;
    var faceDir = [];
    switch (kind) {
        case 0: // face
            faceDir.push( I%2 == 0 ? I+1 : I-1);
            break;
        case 1: // edge
            var edgeType = this.EdgeType;
            switch (I) {
                case edgeType.LD:
                    faceDir.push(faceType.R); faceDir.push(faceType.U);
                    break;
                case edgeType.LU:
                    faceDir.push(faceType.R); faceDir.push(faceType.D);
                    break;
                case edgeType.LB:
                    faceDir.push(faceType.R); faceDir.push(faceType.F);
                    break;
                case edgeType.LF:
                    faceDir.push(faceType.R); faceDir.push(faceType.B);
                    break;
                case edgeType.RD:
                    faceDir.push(faceType.L); faceDir.push(faceType.U);
                    break;
                case edgeType.RU:
                    faceDir.push(faceType.L); faceDir.push(faceType.D);
                    break;
                case edgeType.RB:
                    faceDir.push(faceType.L); faceDir.push(faceType.F);
                    break;
                case edgeType.RF:
                    faceDir.push(faceType.L); faceDir.push(faceType.B);
                    break;
                case edgeType.DB:
                    faceDir.push(faceType.U); faceDir.push(faceType.F);
                    break;
                case edgeType.DF:
                    faceDir.push(faceType.U); faceDir.push(faceType.B);
                    break;
                case edgeType.UB:
                    faceDir.push(faceType.D); faceDir.push(faceType.F);
                    break;
                case edgeType.UF:
                    faceDir.push(faceType.D); faceDir.push(faceType.B);
                    break;
            }
            break;
        case 2: //vertex
            var octType = this.OctType;
            switch (I) {
                case octType.RUF:
                    faceDir.push(faceType.L); faceDir.push(faceType.D); faceDir.push(faceType.B);
                    break;
                case octType.LUF:
                    faceDir.push(faceType.R); faceDir.push(faceType.D); faceDir.push(faceType.B);
                    break;
                case octType.RDF:
                    faceDir.push(faceType.L); faceDir.push(faceType.U); faceDir.push(faceType.B);
                    break;
                case octType.LDF:
                    faceDir.push(faceType.R); faceDir.push(faceType.U); faceDir.push(faceType.B);
                    break;
                case octType.RUB:
                    faceDir.push(faceType.L); faceDir.push(faceType.D); faceDir.push(faceType.F);
                    break;
                case octType.LUB:
                    faceDir.push(faceType.R); faceDir.push(faceType.D); faceDir.push(faceType.F);
                    break;
                case octType.RDB:
                    faceDir.push(faceType.L); faceDir.push(faceType.U); faceDir.push(faceType.F);
                    break;
                case octType.LDB:
                    faceDir.push(faceType.R); faceDir.push(faceType.U); faceDir.push(faceType.F);
                    break;
            }
            break;
    }

    // get child octants in each face direction
    for (var i = 0; i < faceDir.length; i++) {
        this.getFaceChildOfOctant(octant, faceDir[i], neighborOctants);
    }
};

CLOUD.OctantNeighborUtil.prototype.getFaceChildOfOctant
    = function(octant,faceDir, neighborOctants) {
    var curOct;
    var reflectFace;
    for (var i = 0, length = octant.childOctants.length; i < length; i++ ) {
        curOct = octant.childOctants[i];
        if (this.adjFace(faceDir, curOct.octType)) {
            neighborOctants.push(curOct);
            this.getFaceChildOfOctant(curOct, faceDir, neighborOctants);
        }
        else {
            reflectFace = this.refelectFace(faceDir, curOct.octType);
            for (var j = 0; j < length; j++ ) {
                if (octant.childOctants[j].octType == reflectFace) {
                    break;
                }
            }

            if (j == length) {
                neighborOctants.push(curOct);
                this.getFaceChildOfOctant(curOct, faceDir, neighborOctants);
            }
        }
    }
};

// kind: 0 - face, 1 - edge, 2 - vertex
// I: direction to search
CLOUD.OctantNeighborUtil.prototype.getNeighborOfSecondLevel
    = function(octant, kind, I) {
    var curNodeStack = [];
    var ancestorOctants = [];
    var neighborOctants = [];
    neighborOctants[0] = octant;
    this.getAncestorNodes(this.root, neighborOctants, 0, curNodeStack, ancestorOctants);
    var util = new CLOUD.OctantNeighborUtil(this.camera, this.root);
    util.containedOctants = ancestorOctants;

    var oct = null;
    switch (kind) {
        case 0:
            oct = util.findFaceNeighbor(0, I);
            break;
        case 1:
            oct = util.findEdgeNeighbor(0, I);
            break;
        case 2:
            oct = util.findVertexNeighbor(0, I);
            break;
    }

    return oct;
};

CLOUD.OctantNeighborUtil.prototype.getAncestorAndNeighbors
    = function() {
    this.searchNeighborOfNeighbor = true;
    this.containChildOfNeighbor = true;

    //this.outputOctree(this.root, -1);
    var containedOctants = this.containedOctants;

    this.findContainNode(this.root);
    var neighborOctants = this.findNeighborNode(this.camera, containedOctants);

    // get ancestor nodes of neighbor octants
    var curNodeStack = [];
    var ancestorOctants = [];
    this.getAncestorNodes(this.root, neighborOctants, 0, curNodeStack, ancestorOctants);

     var ancestorAndNeighbors = {};
    var i;
    var length;
    for (i = 0, length = containedOctants.length; i < length; i++) {
        ancestorAndNeighbors[containedOctants[i].octantId] = 1;
    }

    for (i = 0, length = neighborOctants.length; i < length; i++) {
        ancestorAndNeighbors[neighborOctants[i].octantId] = 1;
    }

    for (i = 0, length = ancestorOctants.length; i < length; i++) {
        ancestorAndNeighbors[ancestorOctants[i].octantId] = 1;
    }

    //this.outputOctants(ancestorAndNeighbors, containedOctants[0]);

    return ancestorAndNeighbors;
};

// Get ancestor octree nodes of the nodes in octants
CLOUD.OctantNeighborUtil.prototype.getAncestorNodes
    = function(root, octants, curIndex, stack, ancestors) {

    var i;
    var length;
    var curNode;
    for (i = 0, length = root.childOctants.length; i < length && curIndex < octants.length; i++) {
        curNode = root.childOctants[i];
        stack.push(curNode);
        if (curNode.octantId == octants[curIndex].octantId) {
            for (var j=stack.length-1; j>=0; j--) {
                ancestors.push(stack[j]);
            }
            curIndex++;
        }
        else if ( i == length-1 || root.childOctants[i+1].octantId > octants[curIndex].octantId) {
            // search child tree
            curIndex = this.getAncestorNodes(curNode, octants, curIndex, stack, ancestors);
        }
        // else continue to search next child
        stack.pop();
    }

    return curIndex;
};

CLOUD.OctantNeighborUtil.prototype.outputOctants
    = function(octants, cameraNode) {
    console.group();

    console.log("Node that contains camera: %d", cameraNode.octantId);
    var nodes = "";
    var i = 0;
    for (var o in octants) {
        nodes += o;
        nodes += "  ";
        if ((i % 9) == 0) {
            nodes += "\n";
        }
        i++;
    }
    console.log("nodes: %s", nodes);
    console.groupEnd();
};

CLOUD.OctantNeighborUtil.prototype.outputOctree
    = function(node, parentId) {
    console.group();
    var i;
    var indent = "";
    for (i=0; i<node.depth; i++) { indent += "  "; }
    console.log("%sNode id: %i, depth: %i, octType: %i, parent: %i", indent, node.octantId,
                         node.depth, node.octType, parentId);
    console.log("%s  size: %f, center: %f, %f, %f", indent, node.size, node.center.x, node.center.y, node.center.z);
    console.log("%s  child number: %i", indent, node.childOctants.length);
    var children = "";
    for (i=0; i<node.childOctants.length; i++) {
        children += node.childOctants[i].octantId;
        children += "  ";
    }
    console.log("%s  children: %i", indent, children);
    for (i=0; i<node.childOctants.length; i++) {
        this.outputOctree(node.childOctants[i], node.octantId);
    }
    console.groupEnd();
};
