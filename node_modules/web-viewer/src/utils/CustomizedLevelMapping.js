
/**
 * Mapping user defined image with 3D model.
 */
CLOUD.CustomizedLevelMapping = {

    /**
     * @param viewer the 3D viewer
     * @param levelHeight {float} the level height
     * @param locatingPoints  [{x:0,y:0},{x:100, y:0},{x:0, y:100}] the positions for top-left, top-right, bottom right of the image
     * @param imagePixelSize {x:100, y:100}
     */
    initialize: function(viewer, levelHeight, locatingPoints, imagePixelSize){

        this.levelHeight = levelHeight;
        this.locatingPoints = locatingPoints;
        this.imagePixelSize = imagePixelSize;

        var scene = viewer.getScene();
        var sceneMatrix = scene.getMatrixGlobal();
        var inverseScaleMatrix = new THREE.Matrix4();
        inverseScaleMatrix.getInverse(sceneMatrix);

        var projectPlane = new THREE.Plane();
        // in model space
        projectPlane.setFromNormalAndCoplanarPoint(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,levelHeight));
        // to scene space
        projectPlane.applyMatrix4(sceneMatrix);

        // get the container offset relative to client
        var offset = viewer.cameraControl.getContainerDimensions();

        var worldPoints = [];
        for(var ii=0;ii<locatingPoints.length; ++ii){
            var pt = locatingPoints[ii];
            var raycaster = viewer.cameraControl.getRaycaster(pt.x+offset.left, pt.y+offset.top);
            var pt3d = raycaster.ray.intersectPlane(projectPlane);
            // to model space
            pt3d.applyMatrix4(inverseScaleMatrix);

            worldPoints.push(pt3d);
        }

        var origin = worldPoints[0];
        var dirX = worldPoints[1].sub(worldPoints[0]);
        var dirY = worldPoints[2].sub(worldPoints[0]);
        var worldSize = {x:dirX.length(),y: dirY.length()};
        dirX.normalize();
        dirY.normalize();
        var scaleX = worldSize.x/imagePixelSize.x;
        var scaleY = worldSize.y/imagePixelSize.y;

        return {
          dirX: dirX,
          dirY: dirY,
          origin: origin,
          scaleX: scaleX,
          scaleY: scaleY
        }
    },

    /**
     * @param pixelX the x position in image pixel space.
     * @param pixelY the y position in image pixel space.
     * @return the point in model space.
     */
    toWorldPoint: function(formula, pixelX, pixelY){

        var offsetX = new THREE.Vector3(formula.dirX.x, formula.dirX.y, formula.dirX.z);
        offsetX.multiplyScalar(pixelX*formula.scaleX);

        var offsetY = new THREE.Vector3(formula.dirY.x, formula.dirY.y, formula.dirY.z); 
        offsetY.multiplyScalar(pixelY*formula.scaleY);

        var pt = new THREE.Vector3(formula.origin.x, formula.origin.y, formula.origin.z);
        pt.add(offsetX).add(offsetY);

        return pt;
    },

    /**
     * @param x the x position in model space
     * @param y the y position in model space
     * @param z the z position in model space
     * @return the point in image pixel space
     */
    toImagePixelPoint: function(formula, x, y, z){

        var dir = new THREE.Vector3(x, y, z);
        dir.sub(formula.origin);

        var dirX = dir.clone().projectOnVector(formula.dirX);
        var dirY = dir.clone().projectOnVector(formula.dirY);

        return {x:dirX.length()/formula.scaleX, y: dirY.length()/formula.scaleY};
    },

    /**
     * 计算相机的位置
     * @param viewer the cloud viewer
     * @param worldPt the world position
     * @return the cameram position
     */
    toCameraPosition: function(viewer, worldPt){
        var scene = viewer.getScene();
        var sceneMatrix = scene.getMatrixGlobal();
        var inverseScaleMatrix = new THREE.Matrix4();
        inverseScaleMatrix.getInverse(sceneMatrix);
        var pt = new THREE.Vector3(worldPt.x, worldPt.y, worldPt.z);
        pt.applyMatrix4(sceneMatrix);
        
        var camera = viewer.camera;
        var dir = camera.position.clone().sub(camera.target);
        pt.add(dir);
        pt.applyMatrix4(inverseScaleMatrix);
        return pt;
    },

    /**
     * 移动相机到指定位置
     * @param {Viewer} viewer  
     * @param {Vector3} worldPt 位置
     * @param {float} manHeight 高度便宜，默认大小1700mm
     */
    moveCamera(viewer, worldPt, manHeight){
        var offset = manHeight || 1700;
        var worldPosition = new THREE.Vector3(worldPt.x, worldPt.y, worldPt.z+offset);
        var scene = viewer.getScene();
        var sceneMatrix = scene.getMatrixGlobal();
        worldPosition.applyMatrix4(sceneMatrix);
        viewer.cameraControl.flyToPointWithParallelEye(worldPosition);
    }
}
